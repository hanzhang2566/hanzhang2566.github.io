<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>入站必读</title>
    <url>/2024/01/01/README/</url>
    <content><![CDATA[<p>欢迎来到张晗_Jeremy 的个人博客，源代码<a href="https://github.com/hanzhang2566/hanzhang2566.github.io">点击</a>。</p>
<h1 id="首页"><a href="#首页" class="headerlink" title="首页"></a>首页</h1><p>本站所有文章都会以分页的方式展示在这里，如果您需要快速找到感兴趣的内容，使用标签或搜索的方式会更高效。</p>
<h1 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h1><p>相同主题的文章会被归类在同一个标签中。</p>
<h1 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h1><p>文章标题、文章内容、代码都可以通过搜索查询。</p>
<h1 id="知识共创协议"><a href="#知识共创协议" class="headerlink" title="知识共创协议"></a>知识共创协议</h1><p>本站使用了最宽松的 <a href="https://creativecommons.org/licenses/by/4.0/deed.zh">CC 协议</a>，使用仅需署名即可。点击<a href="https://creativecommons.org/licenses/">这里</a>，了解更多。</p>
]]></content>
  </entry>
  <entry>
    <title>微服务不是银弹</title>
    <url>/2023/06/28/essay-20230628/</url>
    <content><![CDATA[<blockquote>
<p><a href="https://en.wikipedia.org/wiki/Fred_Brooks">Fred Brooks</a> 在他的两本著作《<a href="https://en.wikipedia.org/wiki/No_Silver_Bullet">没有银弹：软件工程的本质性与附属性工作</a>》和《<a href="https://en.wikipedia.org/wiki/The_Mythical_Man-Month">人月神话：软件项目管理之道</a>》里都反复强调着一个观点：“<strong>软件研发中任何一项技术、方法、架构都不可能是银弹</strong>”。</p>
</blockquote>
<h1 id="目的：为什么选择微服务"><a href="#目的：为什么选择微服务" class="headerlink" title="目的：为什么选择微服务"></a>目的：为什么选择微服务</h1><p>微服务的目的是有效的拆分应用，实现敏捷开发和部署。</p>
<h2 id="外部因素"><a href="#外部因素" class="headerlink" title="外部因素"></a>外部因素</h2><ul>
<li>没有什么技术能包打天下。考虑到技术异构选择微服务是没有选择、无可避免的。</li>
<li>人才储备。选择微服务能使高水平开发、运维人员来实现关键业务服务，外围功能交给非核心人员，以便保证系统整体的稳定和局部的容错、自愈与快速迭代。</li>
<li>甲方要求。甲方招投标文件技术规范明文要求。</li>
<li>…</li>
</ul>
<h2 id="内部因素"><a href="#内部因素" class="headerlink" title="内部因素"></a>内部因素</h2><ul>
<li>快速变化业务的自主选择。微服务让系统有更好的可观测性、快速迭代和自愈能力。</li>
<li>大规模的、业务复杂的、历史包袱沉重的单体系统会自然向微服务演进。</li>
<li>…</li>
</ul>
<h1 id="前提：微服务的条件"><a href="#前提：微服务的条件" class="headerlink" title="前提：微服务的条件"></a>前提：微服务的条件</h1><h2 id="康威定律"><a href="#康威定律" class="headerlink" title="康威定律"></a>康威定律</h2><p>决策者与执行者都能意识到康威定律在软件设计中的关键作用。康威定律的核心观点是“沟通决定设计”，其社会学和管理学的规律决定了假如产品和组织能够经受住市场竞争，长期发展的话，最终都会自发地调整成组织与产品互相匹配的状态。</p>
<p>为了推进软件架构的微服务化而配合地调整组织架构，通常不是一件容易的事情。因为所有的技术上的决策实际都是政治上的决策。解决这个问题不仅需要执行者有良好的社交能力，还需要更上层的决策者充分理解架构演变同步调整组织结构的必要性，为微服务化打破局部的利益藩篱。</p>
<h2 id="技术专家"><a href="#技术专家" class="headerlink" title="技术专家"></a>技术专家</h2><p>开发业务的普通程序员可以不去深究跟踪治理、负载均衡、故障隔离、认证授权、伸缩扩展这些系统性的问题，它们被隐藏于软件架构的最底层，被掩埋在基础设施之下。靠谱的软件架构应该要由深刻理解微服务的技术专家来设计建造，健壮的基础设施也离不开有经验的运维专家的持续运维。</p>
<p>如果整个团队中缺乏能够在微服务架构中撑起系统主干的技术和运维专家，强行进行微服务化并不会有任何好处，至少收益不足以抵消复杂性增加而导致的成本。</p>
<p>一个残忍的真相是：软件架构的趋势将导致开发者的分层，从如今所有开发者都普遍被认为是“高智商人群”的状态，转变为大部分工业化软件生产工人加上小部分软件设计专家的金字塔结构。</p>
<h2 id="自治和监控"><a href="#自治和监控" class="headerlink" title="自治和监控"></a>自治和监控</h2><p>由于微服务数量多、发布快，迅速升级和回滚的自动化是必要的，但监控对于任何一个系统都需要。</p>
<p>微服务自动化的最终目的是构筑一个可持续的生态系统，现阶段仍然是一个过于理想化的目标。建设微服务的不同时期，由不同程度的人力去参与运维完全可行的，只要满足与系统规模和目标相匹配的自动化能力。只有朝着这个目标去发展自动化与监控度量，避免自动化与度量监控反过来成为人与系统的负担。</p>
<h2 id="复杂性"><a href="#复杂性" class="headerlink" title="复杂性"></a>复杂性</h2><p>架构是演进式设计的，对于小型系统，单体架构就是最好的架构。复杂度的提升自然而然过渡到微服务架构中。</p>
<h1 id="边界：微服务的粒度"><a href="#边界：微服务的粒度" class="headerlink" title="边界：微服务的粒度"></a>边界：微服务的粒度</h1><h2 id="下界"><a href="#下界" class="headerlink" title="下界"></a>下界</h2><p>微服务粒度的下界是它至少应满足独立，内聚，完备三个特征。</p>
<p>独立：独立发布、独立部署、独立运行与独立测试。</p>
<p>内聚：强相关的功能与数据在同一个服务中处理。</p>
<p>完备：个服务包含至少一项业务实体与对应的完整操作。</p>
<h2 id="上界"><a href="#上界" class="headerlink" title="上界"></a>上界</h2><p>微服务粒度的上界是一个 2 Pizza Team，能够在一个研发周期内完成的全部需求范围。</p>
<p>这是由于<a href="https://en.wikipedia.org/wiki/Dunbar%27s_number">邓巴数</a>的存在。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://icyfenix.cn/methodology/forward-msa/">向微服务迈进</a></p>
]]></content>
      <tags>
        <tag>essay</tag>
      </tags>
  </entry>
  <entry>
    <title>成为问题解决者</title>
    <url>/2023/06/21/become-problem-solver/</url>
    <content><![CDATA[<p>我的伙伴：</p>
<p>截止到 2023 年 6 月，我经历了 1 年实习，不到 2 年的工作，完成了一些里程碑。编写过 Java、Dart、Golang、JavaScript 等语言程序。研究了 Spring、Gin 后端框架。尝试了 React、Vue 前端框架和 Flutter 跨平台框架。对于需求分析与整理、架构设计与落地、编程规范与重构、Codebase、DevOps 等研发流程，也积累了一些思考。<a href="https://space.bilibili.com/504736668">B 站</a>中， 上传 11 支技术视频，获得 5000+ 播放量和 100+ 粉丝。<a href="https://hanzhang2566.github.io/">个人博客</a>中，发表 51 篇技术文章，42 千的字数和 150 分钟的阅读时长。<a href="https://github.com/hanzhang2566">Github</a> 中，提交 265 次代码，收获 3 个 star 和 5 次 fork。</p>
<p>如今，大厂小厂纷纷裁员，中年失业屡见不鲜，寒气的的确确传递给每位从业者。古人说：“不以物喜，不以己悲”。<a href="https://baike.baidu.com/item/%E5%AE%81%E5%90%91%E4%B8%9C/61892?fr=aladdin">宁向东教授</a>说：“低谷的时候，多读书，多做准备，冷静判断时势，对自己有信心”。</p>
<p>我崇拜 Linus Torvalds、Jeff Dean 这样用技术改变世界的天才，钦佩 Rod Johnson、Evan You 这样技术解放开发者的大佬，佩服对技术有追求的同行们。对我来说，单纯的几行漂亮代码什么也做不了。技术要赋能业务，业务成功体现技术价值。技术也可赋能商业，商业是更宏大的命题。</p>
<h1 id="一切以解决问题为中心"><a href="#一切以解决问题为中心" class="headerlink" title="一切以解决问题为中心"></a>一切以解决问题为中心</h1><p>目前，衡量自己是否成功的一个最基本的标准，就在于是否彻底解决了问题。</p>
<p>作为公司的一员，问题直接来源于公司业务，解决业务问题的能力越强，个人就越有竞争力。帮助公司占领市场领导地位，公司才能有更高的利润，个人才能有更高的收入。</p>
<p>基于此长期价值，我将展示自己的做事方法，以便各位判断我们是否是同路人：</p>
<ul>
<li>全力解决 BUG；</li>
<li>需求分析有输出，文档清晰后再编码；</li>
<li>谦逊，爱护同事；</li>
<li>多分享，有输出；</li>
<li>与优秀者共事；</li>
<li>接触社区，融入社区，反馈社区；</li>
<li>先开始，在学习；</li>
<li>关注商业，关注产业，关注盈利；</li>
</ul>
<p>我不敢宣称自己的方法是“正确”，但至少这是我的做事哲学。如果自己都不清楚如何去做，那只能被解释为混日子。在此基础上，写下自己对未来的展望。</p>
<h1 id="工作要求"><a href="#工作要求" class="headerlink" title="工作要求"></a>工作要求</h1><p>对自己负责的需求点、模块和项目，需要详细的需求分析，架构设计和实现要主动调研主流实现方案，最后进行编码。产生的 BUG 要第一时间解决，小步快跑，快速迭代。</p>
<p>不属于自己的负责范畴的内容，以解决问题为目的。不抱怨，不分心。</p>
<h1 id="参与社区"><a href="#参与社区" class="headerlink" title="参与社区"></a>参与社区</h1><p>积极参与行业会议，以便熟悉行业主流的技术方案和选型；</p>
<p>拥抱社区，尝试解决社区问题，贡献代码；</p>
<h1 id="积极分享"><a href="#积极分享" class="headerlink" title="积极分享"></a>积极分享</h1><p>视频、文章、问答等各种方式，分享不限于技术的观点。</p>
]]></content>
      <tags>
        <tag>yearly report</tag>
      </tags>
  </entry>
  <entry>
    <title>最简明好用的 BP 撰写指南</title>
    <url>/2023/06/10/reading-note-killer-business-plan/</url>
    <content><![CDATA[<p>向投资人讲解自己的创业项目，本质上是一次推销。一次精彩的演讲必定是一篇引人入胜的故事，故事创造连接，产生触动，改变观念，进而施加影响。商业计划书（BP）就是创业者第一次对外讲故事的载体。</p>
<h1 id="企业是做什么的？"><a href="#企业是做什么的？" class="headerlink" title="企业是做什么的？"></a>企业是做什么的？</h1><p>用一个陈述句来定义自己的公司，讲清楚自己的企业是做什么的。</p>
<h1 id="为什么要做？"><a href="#为什么要做？" class="headerlink" title="为什么要做？"></a>为什么要做？</h1><p>市场发生了什么样的改变，这些为你创造了什么样的机会。</p>
<p>为什么你的技术、业务和解决方案，在此之前并没有建立起来？</p>
<p>目标客户面临的具体痛点，以及为什么当下的解决方案并不能解决它。</p>
<p>如果你的产品成功，世界会变成什么样子。</p>
<h1 id="做成什么样？"><a href="#做成什么样？" class="headerlink" title="做成什么样？"></a>做成什么样？</h1><p>清晰地表达产品的特性和架构，解释产品是如何工作。</p>
<p>你的产品如何解决痛点。</p>
<p>你的护城河。</p>
<p>市场营销和变现策略。</p>
<h1 id="目前是什么阶段？"><a href="#目前是什么阶段？" class="headerlink" title="目前是什么阶段？"></a>目前是什么阶段？</h1><p>解释当前产品的现状，如客户获取、使用和留存、单位经济效益（Unit Economics）和损益情况（P&amp;L）。</p>
<p>解释为何你的产品能够脱颖而出。</p>
<h1 id="下一阶段的目标是？"><a href="#下一阶段的目标是？" class="headerlink" title="下一阶段的目标是？"></a>下一阶段的目标是？</h1><p>公司和产品接下来的 5 年规划。</p>
<p>市场有多大，增长有多快，处于什么样的位置。</p>
<p>如何分配利润。</p>
<p>竞争对手是谁，如何赢得竞争。</p>
<h1 id="你的伙伴是谁？"><a href="#你的伙伴是谁？" class="headerlink" title="你的伙伴是谁？"></a>你的伙伴是谁？</h1><p>讲述主要团队成员，和二级管理团队。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>每个要点 3 - 5 张幻灯片，突出重点、关键点和记忆点。</p>
<p>分享你的愿景；阐述你正在解决的问题；客户成功是什么样的；</p>
<p>通过解释如何创造价值（产品策略），如何传递价值（市场策略），如何获取价值（变现策略），如何获得1亿美元的收入以及围绕业务的关键护城河来谈论企业和商业模式。</p>
<p>展示运营指标（获取、使用、留存和转换）、财务数据、产品指标。</p>
<p><a href="https://www.sequoiacap.cn/article/killer-business-plan/">原文</a></p>
]]></content>
      <tags>
        <tag>reading notes</tag>
      </tags>
  </entry>
  <entry>
    <title>凤凰架构</title>
    <url>/2023/05/31/reading-note-phoenix-project/</url>
    <content><![CDATA[<p>⭐⭐⭐⭐⭐</p>
<p>这是一副帮助开发者、技术决策者的技能地图，一份参考手册。</p>
<p>从架构演进开始，循序渐进走向分布式和云原生。除了不同架构主流方案外，更重要的是叙述了这些方案的来龙去脉、利弊选择，同时提供了代码工程。虽然周老师文笔谦逊，但能感受到文字中蕴含的海纳百川的容量。</p>
<p>技术决策者重要的是取舍，在能满足需求的前提下，<strong>最简单的系统就是最好的系统</strong>。</p>
<p><a href="https://icyfenix.cn/">在线阅读</a></p>
<span id="more"></span>

<p>技术架构者的第一职责就是做决策权衡，有利有弊才需要决策，有取有舍才需要权衡，如果架构者本身的知识面不足以覆盖所需要决策的内容，不清楚其中利弊，恐怕也就无可避免地陷入选择困难的困境之中。</p>
<h1 id="演进中的架构"><a href="#演进中的架构" class="headerlink" title="演进中的架构"></a>演进中的架构</h1><p>架构不是被发明出来的，而是持续演进的。</p>
<h2 id="原始分布式时代"><a href="#原始分布式时代" class="headerlink" title="原始分布式时代"></a>原始分布式时代</h2><h3 id="UNIX-的分布式设计"><a href="#UNIX-的分布式设计" class="headerlink" title="UNIX 的分布式设计"></a>UNIX 的分布式设计</h3><p>保持接口与实现的简单性，比系统的任何其他属性，包括准确性、一致性和完整性，都来得更加重要。</p>
<h3 id="教训"><a href="#教训" class="headerlink" title="教训"></a>教训</h3><p>某个功能能够进行分布式，不意味着它就应该进行分布式，强行追求透明的分布式操作，只会自寻苦果。</p>
<p>原因在于：将一个系统拆分到不同的机器中运行，解决服务发现、跟踪、通信、容错、隔离、配置、传输、数据一致性和编码复杂度等带来的问题，所付出的代价远远超过了分布式所取得的收益。</p>
<h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>现实情况下，有两条通往更大规模软件系统的道路。</p>
<ol>
<li>尽快提升单机的处理能力，以避免分布式带来的种种问题；</li>
<li>找到更完美的解决如何构筑分布式系统的解决方案。</li>
</ol>
<h2 id="单体系统时代"><a href="#单体系统时代" class="headerlink" title="单体系统时代"></a>单体系统时代</h2><p>“单体”仅仅表明系统中主要的过程调用都是进程内调用，不会发生进程间通信而已。</p>
<h3 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h3><p>对于小型系统，单台机器就足以支撑其良好运行的系统，单体不仅易于开发、易于测试、易于部署，且由于系统中各个功能、模块、方法的调用过程都是进程内调用，不会发生进程间通信因此也是运行效率最高的一种架构风格。</p>
<h3 id="劣势"><a href="#劣势" class="headerlink" title="劣势"></a>劣势</h3><p>劣势必须是基于软件性能需求超过单机，开发人员规模超过 “2 Pizza”范畴的前提下才有价值。</p>
<p>单体系统的缺陷不是系统如何拆分，而是拆分之后的隔离与自治能力上的欠缺。</p>
<ol>
<li>获得了进程内调用的简单、高效等好处的同时，也意味着如果任何一部分代码出现了缺陷，过度消耗了进程空间内的资源，所造成的影响也是全局性的、难以隔离的；</li>
<li>无法做到单独停止、更新、升级某一部分代码；</li>
<li>程序升级、修改缺陷往往需要制定专门的停机更新计划，做灰度发布、A&#x2F;B 测试也相对更复杂；</li>
<li>技术异构困难；</li>
<li>最重要的一点：单体系统潜在的希望每个组件和代码都尽量可靠，用减少缺陷来搭建可靠系统。由于墨菲定律的存在，观念的转变才是微服务替代单体的底气；</li>
</ol>
<h3 id="结论-1"><a href="#结论-1" class="headerlink" title="结论"></a>结论</h3><p>摩尔定律减速的同时，为了允许程序出错，为了获得隔离、自治的能力，为了技术异构等目标，程序选择分布式再次成为焦点。</p>
<p>分布式除了适用微服务架构外，将一个大的单体系统拆分为若干个更小的、不运行在同一个进程的独立服务，衍生出了面向服务架构，也就是 SOA。</p>
<h2 id="SOA-时代"><a href="#SOA-时代" class="headerlink" title="SOA 时代"></a>SOA 时代</h2><p>为了解决单体服务拆分的问题，面向服务的架构是一次具体地、系统性地成功解决分布式服务主要问题的架构模式。</p>
<h3 id="烟囱式"><a href="#烟囱式" class="headerlink" title="烟囱式"></a>烟囱式</h3><p>被拆分的服务完全不与其他系统进行互操作和协调。</p>
<h3 id="微内核"><a href="#微内核" class="headerlink" title="微内核"></a>微内核</h3><p>将各个子系统使用到的公共服务、资源和数据集中到一起，形成一个核心系统，具体业务系统以插件模块形式存在。缺点是：插件模块只能和核心系统交互，相互之间无法通信。</p>
<h3 id="事件驱动"><a href="#事件驱动" class="headerlink" title="事件驱动"></a>事件驱动</h3><p>在子系统之间建立一套事件队列管道（Event Queues），来自系统外部的消息以事件的形式发送至管道中，各个子系统从管道里获取自己感兴趣、能够处理的事件消息，同时能发送事件到管道中。</p>
<h3 id="SOA"><a href="#SOA" class="headerlink" title="SOA"></a>SOA</h3><p>是一套软件设计的基础平台。</p>
<h3 id="结论-2"><a href="#结论-2" class="headerlink" title="结论"></a>结论</h3><p>由于 SOA 过于严格的规范定义，带来过度的复杂性，注定了它只能是少数系统阳春白雪式的精致奢侈品，很难作为一种具有广泛普适性的软件架构风格来推广。</p>
<h2 id="微服务时代"><a href="#微服务时代" class="headerlink" title="微服务时代"></a>微服务时代</h2><p>微服务是一种通过多个小型服务组合来构建单个应用的架构风格，这些服务围绕业务能力而非特定的技术标准来构建。各个服务可以采用不同的编程语言，不同的数据存储技术，运行在不同的进程之中。服务采取轻量级的通信机制和自动化的部署机制实现通信与运维。</p>
<h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ol>
<li><p>围绕业务能力构建——康威定律</p>
<p>有怎样结构、规模、能力的团队，就会产生出对应结构、规模、能力的产品。这个结论不是某个团队、某个公司遇到的巧合，而是必然的演化结果。</p>
</li>
<li><p>分散治理</p>
<p>服务对应的开发团队有直接对服务运行质量负责的责任，并且有选择性掌控服务各个方面的权力。</p>
</li>
<li><p>通过服务来实现组件</p>
<p>类库是在编译器期静态链接到程序中，而服务是进程外组件。虽然远程服务有更高昂的调用成本，但这是需要隔离与自治能力的必要代价。</p>
</li>
<li><p>产品化思维</p>
<p>开发者不仅应该知道软件如何开发，还应该知道它如何运作，用户如何反馈，乃至售后支持工作是怎样进行的。</p>
</li>
<li><p>数据去中心化</p>
<p>数据应该按领域分散管理、更新、维护、存储。</p>
</li>
<li><p>强终端弱管道</p>
<p>终端是 Endpoint，对应于 RESTful 风格的接口。管道是 SOAP 协议中的概念。</p>
</li>
<li><p>容错性设计</p>
<p>承认服务中总会出错的现实，有机制进行快速的故障检测、服务隔离和恢复重连。</p>
</li>
<li><p>演进式设计</p>
<p>承认服务会被报废淘汰。假如系统中出现不可更改、无可替代的服务，这并不能说明这个服务是多么的优秀、多么的重要，反而是一种系统设计上脆弱的表现。</p>
</li>
<li><p>基础设施自动化</p>
<p>人工难以支持很多服务。</p>
</li>
</ol>
<h3 id="结论-3"><a href="#结论-3" class="headerlink" title="结论"></a>结论</h3><p>微服务所带来的自由是一把双刃开锋的宝剑，当架构者拿起这把宝剑，一刃指向 SOA 定下的复杂技术标准，将选择的权力夺回的同一时刻，另外一刃也正朝向着自己映出冷冷的寒光。</p>
<h2 id="后微服务时代"><a href="#后微服务时代" class="headerlink" title="后微服务时代"></a>后微服务时代</h2><p>软、硬一体，合力应对微服务架构的问题。</p>
<p>微服务使用容器作为载体，管理载体的平台则是 k8s。</p>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="center">Kubernetes</th>
<th align="center">Spring Cloud</th>
</tr>
</thead>
<tbody><tr>
<td align="center">弹性伸缩</td>
<td align="center">Autoscaling</td>
<td align="center">N&#x2F;A</td>
</tr>
<tr>
<td align="center">服务发现</td>
<td align="center">KubeDNS &#x2F; CoreDNS</td>
<td align="center">Spring Cloud Eureka</td>
</tr>
<tr>
<td align="center">配置中心</td>
<td align="center">ConfigMap &#x2F; Secret</td>
<td align="center">Spring Cloud Config</td>
</tr>
<tr>
<td align="center">服务网关</td>
<td align="center">Ingress Controller</td>
<td align="center">Spring Cloud Gateway</td>
</tr>
<tr>
<td align="center">负载均衡</td>
<td align="center">Load Balancer</td>
<td align="center">Spring Cloud Ribbon</td>
</tr>
<tr>
<td align="center">服务安全</td>
<td align="center">RBAC API</td>
<td align="center">Spring Cloud Security</td>
</tr>
<tr>
<td align="center">跟踪监控</td>
<td align="center">Metrics API &#x2F; Dashboard</td>
<td align="center">Spring Cloud Turbine</td>
</tr>
<tr>
<td align="center">降级熔断</td>
<td align="center">N&#x2F;A</td>
<td align="center">Spring Cloud Hystrix</td>
</tr>
</tbody></table>
<p>k8s 是针对整个容器来管理的，粒度相对粗旷，只能到容器层面，对单个远程服务就很难有效管控。</p>
<p>为了解决这个问题，虚拟化的基础设施进化到“服务网格”。具体含义是由系统自动在服务容器中注入一个通信代理服务器，在应用毫无感知的情况下，悄然接管应用所有对外通信。这个代理除了实现正常的服务间通信外（称为数据平面通信），还接收来自控制器的指令（称为控制平面通信），根据控制平面中的配置，对数据平面通信的内容进行分析处理，以实现熔断、认证、度量、监控、负载均衡等各种附加功能。这样便实现了既不需要在应用层面加入额外的处理代码，也提供了几乎不亚于程序代码的精细管理能力。</p>
<h3 id="结论-4"><a href="#结论-4" class="headerlink" title="结论"></a>结论</h3><p>未来 Kubernetes 将会成为服务器端标准的运行环境，如同现在 Linux 系统；服务网格将会成为微服务之间通信交互的主流模式，把“选择什么通信协议”、“怎样调度流量”、“如何认证授权”之类的技术问题隔离于程序代码之外。</p>
<h2 id="无服务时代"><a href="#无服务时代" class="headerlink" title="无服务时代"></a>无服务时代</h2><p>开发者只需要纯粹地关注业务，不需要考虑技术组件，后端的技术组件是现成的，可以直接取用，没有采购、版权和选型的烦恼；不需要考虑如何部署，部署过程完全是托管到云端的，工作由云端自动完成；不需要考虑算力，有整个数据中心支撑，算力可以认为是无限的；也不需要操心运维，维护系统持续平稳运行是云计算服务商的责任而不再是开发者的责任。</p>
<h3 id="结论-5"><a href="#结论-5" class="headerlink" title="结论"></a>结论</h3><p>微服务架构是分布式系统这条路当前所能做到的极致，而无服务架构也许是“不分布式”的云端系统这条路的起点。</p>
<h1 id="架构师的视角"><a href="#架构师的视角" class="headerlink" title="架构师的视角"></a>架构师的视角</h1><h2 id="远程服务"><a href="#远程服务" class="headerlink" title="远程服务"></a>远程服务</h2><p>远程服务将计算机程序的工作范围从单机扩展到网络，从本地延伸至远程，是构建分布式系统的首要基础。</p>
<h3 id="远程服务调用-RPC"><a href="#远程服务调用-RPC" class="headerlink" title="远程服务调用 RPC"></a>远程服务调用 RPC</h3><h4 id="进程内调用"><a href="#进程内调用" class="headerlink" title="进程内调用"></a>进程内调用</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Caller    :  调用者，代码里的 main()</span></span><br><span class="line"><span class="comment">// Callee    ： 被调用者，代码里的 println()</span></span><br><span class="line"><span class="comment">// Call Site ： 调用点，即发生方法调用的指令流位置</span></span><br><span class="line"><span class="comment">// Parameter ： 参数，由 Caller 传递给 Callee 的数据，即 “hello world”</span></span><br><span class="line"><span class="comment">// Retval    ： 返回值，由 Callee 传递给 Caller 的数据。以下代码中如果方法能够正常结束，它是 void，如果方法异常完成，它是对应的异常</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">	System.out.println(“hello world”);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>计算机执行步骤：</p>
<ol>
<li>传递方法参数：将字符串<code>helloworld</code>的引用地址压栈；</li>
<li>确定方法版本：根据<code>println()</code>方法的签名，确定其执行版本‘</li>
<li>执行被调方法：从栈中弹出<code>Parameter</code>的值或引用，以此为输入，执行<code>Callee</code>内部的逻辑；</li>
<li>返回执行结果：将<code>Callee</code>的执行结果压栈，并将程序的指令流恢复到<code>Call Site</code>的下一条指令，继续向下执行；</li>
</ol>
<p>当 <code>main</code> 和 <code>println</code> 分属不同进程中，则：</p>
<ol>
<li>压栈执行毫无意义；</li>
<li>不同语言实现 2 个方法的情况下，版本选择是不可知行为；</li>
</ol>
<h4 id="进程间调用-IPC"><a href="#进程间调用-IPC" class="headerlink" title="进程间调用 IPC"></a>进程间调用 IPC</h4><ul>
<li>管道 | 具名管道：类似于 2 个进程之间的桥梁，通过管道在进程间传递少量字符流或字节流；</li>
<li>信号：通知目标进程产生某种行为；</li>
<li>信号量： OS 提供的特殊变量，用于 2 进程之间同步；</li>
<li>消息队列：可以传递更多消息的管道；</li>
<li>共享内存：多个进程共享公共内存空间，效率最高；</li>
<li>套接字接口：消息队列和共享内存只适合于单机多进程通讯，Socket 更加普适；</li>
</ul>
<p>RPC 最初是作为 IPC 的一种特例来处理的。但忽略了 8 个问题：</p>
<ol>
<li>The network is reliable —— 网络是可靠的。</li>
<li>Latency is zero —— 延迟是不存在的。</li>
<li>Bandwidth is infinite —— 带宽是无限的。</li>
<li>The network is secure —— 网络是安全的。</li>
<li>Topology doesn’t change —— 拓扑结构是一成不变的。</li>
<li>There is one administrator —— 总会有一个管理员。</li>
<li>Transport cost is zero —— 不必考虑传输成本。</li>
<li>The network is homogeneous —— 网络是同质化的。</li>
</ol>
<p>基于以上 8 大问题，证明了 RPC 应该是一种高层次的或者说语言层次的特征，而非 IPC 这样低层次的或者说系统层次的特征，同时否定了 RPC 最初是作为 IPC 的一种特例来处理的可能。</p>
<h4 id="RPC-的三个基本问题"><a href="#RPC-的三个基本问题" class="headerlink" title="RPC 的三个基本问题"></a>RPC 的三个基本问题</h4><ol>
<li><p>如何表示数据</p>
<p>包括了传递给方法的参数，以及方法执行后的返回值。。有效的做法是将交互双方所涉及的数据转换为某种事先约定好的中立数据流格式来进行传输，将数据流转换回不同语言中对应的数据类型来进行使用。也就是说，每种 RPC 协议都要对应各自的<code>序列化协议</code>。例如，gRPC 的 <a href="https://developers.google.com/protocol-buffers">Protocol Buffers</a>。</p>
</li>
<li><p>如何传递数据</p>
<p>两个服务交互不仅仅使用序列化数据流来表示参数和结果就行，还有譬如异常、超时、安全、认证、授权、事务，等等，都可能产生双方需要交换信息的需求。例如，JSON-RPC 直接使用 HTTP 协议。</p>
</li>
<li><p>如何确定方法</p>
<p>对于不同语言实现的方法，需要根据方法签名转换为进程空间中子过程入口位置的指针。</p>
</li>
</ol>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>不同的 RPC 框架所提供的特性或多或少是有矛盾的，很难有某一种 RPC 框架既有面向对象特性、又有高性能，还有简化的大一统框架。</p>
<h3 id="RESTful-风格"><a href="#RESTful-风格" class="headerlink" title="RESTful 风格"></a>RESTful 风格</h3><h4 id="理解-REST"><a href="#理解-REST" class="headerlink" title="理解 REST"></a>理解 REST</h4><p>REST 即”表征状态转移“。</p>
<ul>
<li>资源：信息、数据本身就称为资源；</li>
<li>表征：服务端向客户端返回资源的特征称为表征。例如，服务端可以返回 HTML、JSON、MD、PDF 等等；</li>
<li>状态：在特定语境中才能产生的上下文信息称为“状态”。客户端记住状态，请求时告诉服务器称为无状态；服务端保持客户端状态则成为有状态；</li>
<li>转移：服务端通过某种方式，将资源转换，就是称为转移；</li>
</ul>
<h4 id="RESTful-系统"><a href="#RESTful-系统" class="headerlink" title="RESTful 系统"></a>RESTful 系统</h4><ul>
<li>客户端与服务端分离：服务端提供数据，客户端进行渲染。有利于提高用户界面的跨平台的移植性；</li>
<li>无状态：服务端无状态在分布式计算中价值很大。但实际上服务端持有内存、会话、数据库或者缓存等已经事实存在，并将长期存在、被广泛使用的主流的方案；</li>
<li>可缓存：无状态服务虽然提升了系统的可见性、可靠性和可伸缩性，但降低了系统的网络性。因为有状态的设计只需要一次或者少量请求，但无状态设计就要多次请求，为了缓解多次请求的压力，就要增加缓存设计；</li>
<li>分层系统：客户端不需要知道是否连接到最终的服务器。因为 CDN 可以加速访问过程；</li>
<li>统一接口：HTTP 协议中提前约定好的 GET、POST 等 7 种动作；</li>
</ul>
<h4 id="不足"><a href="#不足" class="headerlink" title="不足"></a>不足</h4><ol>
<li>面向资源的编程思想只适合做 CRUD，面向过程、面向对象编程才能处理真正复杂的业务逻辑。因为复杂的场景，很难用 HTTP 的统一接口去描述;</li>
<li>REST 与 HTTP 完全绑定，不适合应用于要求高性能传输的场景中；</li>
<li>不利于事务；</li>
<li>REST 没有传输可靠性支持;</li>
<li>REST 缺乏对资源进行“部分”和“批量”的处理能力。由于 HTTP 协议完全没有对请求资源的结构化描述能力，所以返回资源的哪些内容、以什么数据类型返回等等，都不可能得到协议层面的支持；</li>
</ol>
<h3 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h3><p>RPC 是将本地的方法调用思路迁移到远程方法调用上，开发者是围绕着“远程方法”去设计两个系统间交互的。这样做的坏处不仅是“如何在异构系统间表示一个方法”、“如何获得接口能够提供的方法清单”，更在于服务的每个方法都是完全独立的，服务使用者必须逐个学习才能正确地使用它们。</p>
<p>REST 中因为有统一接口的存在，降低服务接口的学习成本；方法是动词，逻辑上每个接口都相互独立，而资源是名词，天生具有集合与层次结构；REST 绑定于 HTTP 协议；</p>
<h2 id="事务处理"><a href="#事务处理" class="headerlink" title="事务处理"></a>事务处理</h2><p>事务处理的意义是为了保证系统中所有的数据都是符合期望的，且相互关联的数据之间不会产生矛盾，即数据状态的<strong>一致性（Consistency）</strong>。</p>
<h3 id="单服务单数据源"><a href="#单服务单数据源" class="headerlink" title="单服务单数据源"></a>单服务单数据源</h3><p>这是最基础的事务解决方案。</p>
<p><a href="https://icyfenix.cn/architect-perspective/general-architecture/transaction/local.html">基于语义的恢复与隔离算法</a>是数据库关系系统实现 ACID 事务的理论依据。</p>
<blockquote>
<p>每当一本书被成功售出时，需要确保以下三件事情被正确地处理：</p>
<ul>
<li>用户的账号扣减相应的商品款项。</li>
<li>商品仓库中扣减库存，将商品标识为待配送状态。</li>
<li>商家的账号增加相应的商品款项。</li>
</ul>
</blockquote>
<ul>
<li><strong>未提交事务，写入后崩溃</strong>：程序还没修改完三个数据，但数据库已经将其中一个或两个数据的变动写入磁盘，此时出现崩溃，一旦重启之后，数据库必须要有办法得知崩溃前发生过一次不完整的购物操作，将已经修改过的数据从磁盘中恢复成没有改过的样子，以保证<code>原子性</code>。</li>
<li><strong>已提交事务，写入前崩溃</strong>：程序已经修改完三个数据，但数据库还未将全部三个数据的变动都写入到磁盘，此时出现崩溃，一旦重启之后，数据库必须要有办法得知崩溃前发生过一次完整的购物操作，将还没来得及写入磁盘的那部分数据重新写入，以保证<code>持久性</code>。</li>
</ul>
<p>为了处理崩溃恢复，必须将修改数据这个操作所需的全部信息，以日志的形式记录到磁盘中。数据库会根据日志的提交记录（Commit Record）对真正的数据进行修改，完成后再在日志中加入一条“结束记录”（End Record），表示持久化完成。</p>
<p>Commit Record 方式存在的前提是：所有对数据的真实修改都必须发生在事务提交以后。这对提升数据库性能十分不利。</p>
<h4 id="原子性和持久性"><a href="#原子性和持久性" class="headerlink" title="原子性和持久性"></a>原子性和持久性</h4><p>原子性保证了事务的多个操作要么都生效要么都不生效，不会存在中间状态；持久性保证了一旦事务生效，就不会再因为任何原因而导致其修改的内容被撤销或丢失。实现原子性和持久性的最大困难是“写入磁盘”这个操作并不是原子的，不仅有“写入”与“未写入”状态，还客观地存在着“正在写”的中间状态。</p>
<p>为了解决 Commit Record 的问题，ARIES 提出了“Write-Ahead Logging”的日志改进方案，就是允许在事务提交之前，提前写入变动数据。</p>
<p>Write-Ahead Logging 在崩溃恢复时会执行以下三个阶段的操作：</p>
<ul>
<li><strong>分析阶段</strong>（Analysis）：该阶段从最后一次检查点（Checkpoint，可理解为在这个点之前所有应该持久化的变动都已安全落盘）开始扫描日志，找出所有没有 End Record 的事务，组成待恢复的事务集合，这个集合至少会包括 Transaction Table 和 Dirty Page Table 两个组成部分。</li>
<li><strong>重做阶段</strong>（Redo）：该阶段依据分析阶段中产生的待恢复的事务集合来重演历史（Repeat History），具体操作为：找出所有包含 Commit Record 的日志，将这些日志修改的数据写入磁盘，写入完成后在日志中增加一条 End Record，然后移除出待恢复事务集合。</li>
<li><strong>回滚阶段</strong>（Undo）：该阶段处理经过分析、重做阶段后剩余的恢复事务集合，此时剩下的都是需要回滚的事务，它们被称为 Loser，根据 Undo Log 中的信息，将已经提前写入磁盘的信息重新改写回去，以达到回滚这些 Loser 事务的目的。</li>
</ul>
<h4 id="隔离性"><a href="#隔离性" class="headerlink" title="隔离性"></a>隔离性</h4><p>隔离性保证了并发事务各自读、写的数据互相独立，不会彼此影响。</p>
<p>现代数据库均提供了以下三种锁：</p>
<ul>
<li><p><strong>写锁</strong>（Write Lock，也叫作排他锁，eXclusive Lock，简写为 X-Lock）：如果数据有加写锁，就只有持有写锁的事务才能对数据进行写入操作，数据加持着写锁时，其他事务不能写入数据，也不能施加读锁。</p>
</li>
<li><p><strong>读锁</strong>（Read Lock，也叫作共享锁，Shared Lock，简写为 S-Lock）：多个事务可以对同一个数据添加多个读锁，数据被加上读锁后就不能再被加上写锁，所以其他事务不能对该数据进行写入，但仍然可以读取。对于持有读锁的事务，如果该数据只有它自己一个事务加了读锁，允许直接将其升级为写锁，然后写入数据。</p>
</li>
<li><p><strong>范围锁</strong>（Range Lock）：对于某个范围直接加排他锁，在这个范围内的数据不能被写入。如下语句是典型的加范围锁的例子：</p>
<p><code>SELECT * FROM books WHERE price &lt; 100 FOR UPDATE;</code></p>
</li>
</ul>
<ol>
<li><p>可串行化</p>
</li>
<li><p>可重复读</p>
<p>对事务所涉及的数据加读锁和写锁，且直到事务结束，但不再加范围锁。会产生幻读问题，即在事务执行过程中，两个完全相同的范围查询得到了不同的结果集。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 可重复读</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">count</span>(<span class="number">1</span>) <span class="keyword">FROM</span> books <span class="keyword">WHERE</span> price <span class="operator">&lt;</span> <span class="number">100</span>					<span class="comment">/* 时间顺序：1，事务： T1 */</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 没有范围锁来禁止在该范围内插入新的数据</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> books(name,price) <span class="keyword">VALUES</span> (<span class="string">&#x27;深入理解Java虚拟机&#x27;</span>,<span class="number">90</span>)	   <span class="comment">/* 时间顺序：2，事务： T2 */</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">count</span>(<span class="number">1</span>) <span class="keyword">FROM</span> books <span class="keyword">WHERE</span> price <span class="operator">&lt;</span> <span class="number">100</span>					<span class="comment">/* 时间顺序：3，事务： T1 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 可串行化</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">count</span>(<span class="number">1</span>) <span class="keyword">FROM</span> books <span class="keyword">WHERE</span> price <span class="operator">&lt;</span> <span class="number">100</span>					<span class="comment">/* 时间顺序：1，事务： T1 */</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 由于没有获得范围锁，故阻塞</span></span><br><span class="line"><span class="comment"> * 直到 T1 完成提交</span></span><br><span class="line"><span class="comment"> * 解决幻读问题</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> books(name,price) <span class="keyword">VALUES</span> (<span class="string">&#x27;深入理解Java虚拟机&#x27;</span>,<span class="number">90</span>)	   <span class="comment">/* 时间顺序：2，事务： T2 */</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">count</span>(<span class="number">1</span>) <span class="keyword">FROM</span> books <span class="keyword">WHERE</span> price <span class="operator">&lt;</span> <span class="number">100</span>					<span class="comment">/* 时间顺序：3，事务： T1 */</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>读已提交</p>
<p>对事务涉及的数据加的写锁会一直持续到事务结束，但加的读锁在查询操作完成后就马上会释放。会产生不可重复读的问题，即在事务执行过程中，对同一行数据的两次查询得到了不同的结果——不可重复读。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 读已提交</span></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * T1 第一次读取后，读锁就释放了</span></span><br><span class="line"><span class="comment"> * 缺乏贯穿整个事务周期的读锁，无法禁止读取过的数据发生变化</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> books <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">1</span>;   						<span class="comment">/* 时间顺序：1，事务： T1 */</span></span><br><span class="line"><span class="keyword">UPDATE</span> books <span class="keyword">SET</span> price <span class="operator">=</span> <span class="number">110</span> <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">1</span>; <span class="keyword">COMMIT</span>;			<span class="comment">/* 时间顺序：2，事务： T2 */</span></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * T1 的第二次读到 110</span></span><br><span class="line"><span class="comment"> * 和第一次读到的数据不一致</span></span><br><span class="line"><span class="comment"> * 不可重复读问题</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> books <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">1</span>; <span class="keyword">COMMIT</span>;   				<span class="comment">/* 时间顺序：3，事务： T1 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 可重复读</span></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * T1 第一次读取后，读锁会一直持有</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> books <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">1</span>;   						<span class="comment">/* 时间顺序：1，事务： T1 */</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 由于 T2 获取不到写锁，会阻塞</span></span><br><span class="line"><span class="comment"> * 直到 T1 提交</span></span><br><span class="line"><span class="comment"> * 解决不可重复读问</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">UPDATE</span> books <span class="keyword">SET</span> price <span class="operator">=</span> <span class="number">110</span> <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">1</span>; <span class="keyword">COMMIT</span>;			<span class="comment">/* 时间顺序：2，事务： T2 */</span></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * 正常读取</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> books <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">1</span>; <span class="keyword">COMMIT</span>;   				<span class="comment">/* 时间顺序：3，事务： T1 */</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>读未提交</p>
<p>对事务涉及的数据只加写锁，会一直持续到事务结束，但完全不加读锁。会产生脏读问题，即在事务执行过程中，一个事务读取到了另一个事务未提交的数据。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 读未提交</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> books <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">1</span>;   						<span class="comment">/* 时间顺序：1，事务： T1 */</span></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * 注意没有COMMIT</span></span><br><span class="line"><span class="comment"> * T2 只添加写锁，并未禁止读操作</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">UPDATE</span> books <span class="keyword">SET</span> price <span class="operator">=</span> <span class="number">90</span> <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">1</span>;					<span class="comment">/* 时间顺序：2，事务： T2 */</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 读到 T2 还未提交的数据 90</span></span><br><span class="line"><span class="comment"> * 脏读问题</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> books <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">1</span>;			  				<span class="comment">/* 时间顺序：3，事务： T1 */</span></span><br><span class="line"><span class="keyword">ROLLBACK</span>;			  										<span class="comment">/* 时间顺序：4，事务： T2 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 读已提交</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> books <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">1</span>;   						<span class="comment">/* 时间顺序：1，事务： T1 */</span></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * 注意没有COMMIT</span></span><br><span class="line"><span class="comment"> * T2 添加写锁和读锁</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">UPDATE</span> books <span class="keyword">SET</span> price <span class="operator">=</span> <span class="number">90</span> <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">1</span>;					<span class="comment">/* 时间顺序：2，事务： T2 */</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 由于 id = 1 的数据需要获取读锁后才能读数据</span></span><br><span class="line"><span class="comment"> * 故在 T1 没有提交前，都会阻塞</span></span><br><span class="line"><span class="comment"> * 解决脏读的问题</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> books <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">1</span>;			  				<span class="comment">/* 时间顺序：3，事务： T1 */</span></span><br><span class="line"><span class="keyword">ROLLBACK</span>;			  										<span class="comment">/* 时间顺序：4，事务： T2 */</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="结论-6"><a href="#结论-6" class="headerlink" title="结论"></a>结论</h4><p>四种隔离级别是各种锁在不同加锁时间上组合应用所产生的结果，以锁为手段来实现隔离性才是数据库表现出不同隔离级别的根本原因。</p>
<p>四种隔离级别产生的问题都是由于一个事务在读数据过程中，受另外一个写数据的事务影响而破坏了隔离性。也就是“读 + 写”的模式。多版本并发控制 MVCC 是优化该模式的主流方案。</p>
<p>如果是两个事务同时修改数据，即“写+写”的情况，加锁几乎是唯一可行的解决方案，就要选择是“乐观加锁”还是“悲观加锁”。</p>
<h3 id="单服务多数据源"><a href="#单服务多数据源" class="headerlink" title="单服务多数据源"></a>单服务多数据源</h3><p>X&#x2F;Open 组织提出了一套处理事务架构 X&#x2F;Open XA，它定义了全局的事务管理器和局部的资源管理器之间的通信接口。</p>
<p>事务处理器负责协调全局事务，资源管理器用于驱动本地事务。XA 接口是双向的，能在一个事务管理器和多个资源管理器之间形成通信桥梁，通过协调多个数据源的一致动作，实现全局事务的统一提交或者统一回滚。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 假设：书店的用户、商家、仓库分别处于不同的数据库中</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">buyBook</span><span class="params">(PaymentBill bill)</span> &#123;</span><br><span class="line">    userTransaction.begin();</span><br><span class="line">    warehouseTransaction.begin();</span><br><span class="line">    businessTransaction.begin();</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">        userAccountService.pay(bill.getMoney());</span><br><span class="line">        warehouseService.deliver(bill.getItems());</span><br><span class="line">        businessAccountService.receipt(bill.getMoney());</span><br><span class="line">        userTransaction.commit();</span><br><span class="line">        warehouseTransaction.commit();</span><br><span class="line">        <span class="comment">// 此时出现错误，userTransaction 和 warehouseTransaction 已经提交，catch 中 rollback 无济于事</span></span><br><span class="line">        <span class="comment">// 导致一部分数据被提交（user、warehouse），一部分被回滚（business），一致性无法保证</span></span><br><span class="line">        businessTransaction.commit();</span><br><span class="line">	&#125; <span class="keyword">catch</span>(Exception e) &#123;</span><br><span class="line">        userTransaction.rollback();</span><br><span class="line">        warehouseTransaction.rollback();</span><br><span class="line">        businessTransaction.rollback();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="二阶段提交"><a href="#二阶段提交" class="headerlink" title="二阶段提交"></a>二阶段提交</h4><h5 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h5><ol>
<li>提交阶段的网络短时间内可靠。</li>
<li>节点失联可恢复。</li>
</ol>
<h5 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h5><p><strong>准备阶段（投票阶段）</strong>：协调者询问事务的所有参与者是否准备好提交，参与者如果已经准备好提交则回复 Prepared，否则回复 Non-Prepared；</p>
<p><strong>提交阶段（执行阶段）</strong>：协调者如果在上一阶段收到所有事务参与者回复的 Prepared 消息，则先自己在本地持久化事务状态为 Commit，在此操作完成后向所有参与者发送 Commit 指令，所有参与者立即执行提交操作；否则，任意一个参与者回复了 Non-Prepared 消息，或任意一个参与者超时未回复，协调者将自己的事务状态持久化为 Abort 之后，向所有参与者发送 Abort 指令，参与者立即执行回滚操作；</p>
<h5 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h5><pre><code class="highlight mermaid">sequenceDiagram
participant coordinators as 协调者
participant participants as 参与者
    coordinators -&gt;&gt; participants: 要求所有参与者进入准备阶段
    activate participants
    participants --&gt;&gt; coordinators: 已进入准备阶段
    deactivate participants
    
    coordinators -&gt;&gt; participants: 要求所有参与者进入提交阶段
    activate participants
    participants --&gt;&gt; coordinators: 已进入提交阶段
    deactivate participants

    opt 失败或超时
 	   coordinators -&gt;&gt; participants: 要求所有参与者回滚
 	   activate participants
 	   participants --&gt;&gt; coordinators: 已回滚事务
 	   deactivate participants
    end</code></pre>



<h5 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h5><ol>
<li>单点问题。协调者很重要；</li>
<li>性能问题：参与者进行 2 次 RPC，3 次持久化（准备阶段写重做日志，协调者做状态持久化，提交阶段在日志写入 Commit Record）；</li>
<li>一致性风向：前提会导致一致性风险；</li>
</ol>
<h4 id="三段式提交"><a href="#三段式提交" class="headerlink" title="三段式提交"></a>三段式提交</h4><p>三段式提交把原本的两段式提交的<strong>准备阶段</strong>再细分为1. CanCommit、2. PreCommit，把<strong>提交阶段</strong>改称为 DoCommit 阶段。</p>
<p>CanCommit 是一个询问阶段，协调者让每个参与的数据库根据自身状态，评估该事务是否有可能顺利完成。增加一轮询问阶段，意味着因某个参与者提交时发生崩溃而导致大家全部回滚的风险相对变小。因此，在事务需要回滚的场景中，三段式的性能通常是要比两段式好很多的，但在事务能够正常提交的场景中，两者的性能都依然很差，甚至三段式因为多了一次询问，还要稍微更差一些。</p>
<p>同样也是由于事务失败回滚概率变小的原因，在三段式提交中，如果在 PreCommit 阶段之后发生了协调者宕机，即参与者没有能等到 DoCommit 的消息的话，默认的操作策略将是提交事务而不是回滚事务或者持续等待，这就相当于避免了协调者单点问题的风险。</p>
<p>由于事务失败回滚概率变小的原因，PreCommit 阶段之后发生了协调者宕机（即参与者没有能等到 DoCommit），默认策略是提交事务相当于避免了协调者单点问题的风险。</p>
<p>从以上过程可以看出，三段式提交对单点问题和回滚时的性能问题有所改善，但是它对一致性风险问题并未有任何改进，在这方面它面临的风险甚至反而是略有增加了的。</p>
<pre><code class="highlight mermaid">sequenceDiagram
participant coordinators as 协调者
participant participants as 参与者
    coordinators -&gt;&gt; participants: 询问阶段：是否有把握完成事务
    activate participants
    participants --&gt;&gt; coordinators: 是
    deactivate participants
    
    coordinators -&gt;&gt; participants: 准备阶段：写入日志，锁定资源
    activate participants
    participants --&gt;&gt; coordinators: ACK
    deactivate participants
    
    coordinators -&gt;&gt; participants: 提交阶段：提交事务
    activate participants
    participants --&gt;&gt; coordinators: 已提交
    deactivate participants
    opt 失败
 	   coordinators -&gt;&gt; participants: 要求回滚
 	   activate participants
 	   participants --&gt;&gt; coordinators: 已回滚
 	   deactivate participants
    end
    
    opt 超时
 	   participants -&gt;&gt; participants: 提交事务
    end</code></pre>

<h3 id="多服务单数据源"><a href="#多服务单数据源" class="headerlink" title="多服务单数据源"></a>多服务单数据源</h3><pre><code class="highlight mermaid">flowchart LR

user[用户服务]
business[商家服务]
commodity[商品服务]
exchange(交易服务器或消息队列)
database[(数据库)]

user --&gt; exchange
business --&gt; exchange
commodity --&gt; exchange

exchange --&gt; database</code></pre>

<p>一个服务集群里压力最大的往往是数据库，所以该方案往往与实际生产系统相悖。相应地，如果你有充足理由让多个微服务去共享数据库，就向团队解释为什么要服务拆分。</p>
<h3 id="多服务多数据源"><a href="#多服务多数据源" class="headerlink" title="多服务多数据源"></a>多服务多数据源</h3><p>分布式服务环境下的事务处理机制。</p>
<h4 id="CAP"><a href="#CAP" class="headerlink" title="CAP"></a>CAP</h4><p><strong>分区容忍性</strong>（<strong>P</strong>artition Tolerance）：代表分布式环境中部分节点因网络原因而彼此失联后，即与其他节点形成“网络分区”时，系统仍能正确地提供服务的能力。放弃分区容忍性（CA without P）意味着假设节点之间通信永远是可靠的，可靠系统的通讯在分布式系统中必定不成立。</p>
<p><strong>可用性</strong>（<strong>A</strong>vailability）：代表系统不间断地提供服务的能力，由可靠性（平均无故障时间）和可维护性（平均可修复时间）计算得出的比例值；放弃可用性（AP without C)意味着一旦网络发生分区，节点之间的信息同步时间可以无限制地延长。此时，问题相当于退化单服务多数据源的场景之中，我们可以通过 2PC&#x2F;3PC 等手段，同时获得分区容忍性和一致性；</p>
<p><strong>一致性</strong>（<strong>C</strong>onsistency）：代表数据在任何时刻、任何分布式节点中所看到的都是符合预期的。放弃可用性（CP without A）意味着假设一旦发生分区，节点之间所提供的数据可能不一致。&#x3D;&#x3D;放弃一致性是目前分布式系统的主流选择&#x3D;&#x3D;，因为分区容忍性是分布式网络的天然属性，可用性通常是建设分布式的目的。分布式系统种放弃追求强一致性，降低为最终一致性。由于一致性定义变动，ACID 的事务称为”刚性事务“，把分布式事务称为”柔性事务“。</p>
<h4 id="可靠事件队列"><a href="#可靠事件队列" class="headerlink" title="可靠事件队列"></a>可靠事件队列</h4><p>将最有可能出错的业务以本地事务的方式完成后，采用不断重试的方式（不限于消息系统）来促使同一个分布式事务中的其他关联业务全部完成。</p>
<pre><code class="highlight mermaid">sequenceDiagram
participant user as 外部调用
participant account as 账号服务
participant mq as 消息队列
participant warehorse as 仓库服务
participant business as 商家服务
    alt 有风险
        account -&gt;&gt; user: 失败
    else 评估通过
        account -&gt;&gt; user: 成功
    end
    
    user -&gt;&gt; account: 启动事务
    activate account
		account --&gt;&gt; account: 扣减货款，保存消息
	    account -&gt;&gt; mq: 提交本地事务，发出消息
    deactivate account
    loop 循环直至全部成功
        mq -&gt;&gt; warehorse: 扣减库存
        alt 扣减成功
            warehorse --&gt;&gt; mq: 成功
        else 业务或网络异常
            warehorse --&gt;&gt; mq: 失败
        end
    end
    mq --&gt;&gt; account: 更新消息表，仓库服务完成

    loop 循环直至全部成功
        mq -&gt;&gt; business: 货款收款
        alt 收款成功
            business --&gt;&gt; mq: 成功
        else 业务或网络异常
            business --&gt;&gt; mq: 失败
        end
    end
    mq --&gt;&gt; account: 更新消息表，商家服务完成</code></pre>

<h4 id="TCC-事务"><a href="#TCC-事务" class="headerlink" title="TCC 事务"></a>TCC 事务</h4><p>TCC 事务是 Try-Confirm-Cancel 的缩写，主要用来解决分布式业务中的隔离性。在具体实现上，TCC 较为烦琐，它是一种业务侵入式较强的事务方案，要求业务处理过程必须拆分为“预留业务资源“（冻结）和“确认&#x2F;释放消费资源”（消费）两个子过程。如同 TCC 的名字所示，它分为以下三个阶段。</p>
<ul>
<li><strong>Try</strong>：尝试执行阶段，完成所有业务可执行性的检查（保障一致性），并且预留好全部需用到的业务资源（保障隔离性）。</li>
<li><strong>Confirm</strong>：确认执行阶段，不进行任何业务检查，直接使用 Try 阶段准备的资源来完成业务处理。Confirm 阶段可能会重复执行，因此本阶段所执行的操作需要具备幂等性。</li>
<li><strong>Cancel</strong>：取消执行阶段，释放 Try 阶段预留的业务资源。Cancel 阶段可能会重复执行，也需要满足幂等性。</li>
</ul>
<p>TCC 类似 2PC 的准备阶段和提交阶段，但 TCC 是位于用户代码层面，而不是在基础设施层面。TCC 在业务执行时只操作预留资源，几乎不会涉及锁和资源的争用，具有很高的性能潜力，也可以根据资源锁定的粒度，带来较高灵活性。但同时带来了更高的开发成本和业务侵入性。我们通常基于某些分布式事务中间件（譬如阿里开源的<a href="https://seata.io/zh-cn/">Seata</a>）去完成，而非裸实现 TCC。</p>
<pre><code class="highlight mermaid">sequenceDiagram
participant user as 外部调用
participant account as 账号服务
participant warehorse as 仓库服务
participant business as 商家服务
    user -&gt;&gt; account: 业务检查，冻结货款
    alt 成功
    	account --&gt;&gt; user: 记录进入 Confirm 阶段
    else 业务或网络异常
        account --&gt;&gt; user: 记录进入 Cancel 阶段
    end
    
    user -&gt;&gt; warehorse: 业务检查，冻结商品
    alt 成功
    	warehorse --&gt;&gt; user: 记录进入 Confirm 阶段
    else 业务或网络异常
        warehorse --&gt;&gt; user: 记录进入 Cancel 阶段
    end
    
    user -&gt;&gt; business: 业务检查
    alt 成功
    	business --&gt;&gt; user: 记录进入 Confirm 阶段
    else 业务或网络异常
        business --&gt;&gt; user: 记录进入 Cancel 阶段
    end
    
    opt 全部记录均返回 Confirm 阶段
        loop 循环直至全部成功
        	user -&gt;&gt; account: 完成业务，扣减冻结的货款
            user -&gt;&gt; warehorse: 完成业务，扣减冻结的货物
            user -&gt;&gt; business: 完成业务，货款收款
    	end
    end
    opt 任意服务超时或返回 Cancel 阶段
        loop 循环直至全部成功
        	user -&gt;&gt; account: 取消业务，解冻货款
            user -&gt;&gt; warehorse: 取消业务，解冻货物
            user -&gt;&gt; business: 取消业务
    	end
    end</code></pre>

<h4 id="SAGA-事务"><a href="#SAGA-事务" class="headerlink" title="SAGA 事务"></a>SAGA 事务</h4><p>由于 Try 阶段的冻结操作可能不由自己控制，导致 Try 阶段无法实施。这时就需要另一种柔性事务方案：SAGA 事务，大致思路是把一个大事务分解为可以交错运行的一系列子事务集合。</p>
<ul>
<li>大事务拆分若干个小事务，将整个分布式事务 T 分解为 n 个子事务，命名为 T1，T2，…，Ti，…，Tn。每个子事务都应该是或者能被视为是原子行为；</li>
<li>为每一个子事务设计对应的补偿动作，满足以下条件：<ol>
<li>Ti 与 Ci都具备幂等性。</li>
<li>Ti 与 Ci 满足交换律（Commutative），即先执行 Ti 还是先执行 Ci，其效果都是一样的。</li>
<li>Ci 必须能成功提交，即不考虑 Ci 本身提交失败被回滚的情形，如出现就必须持续重试直至成功，或者要人工介入。</li>
</ol>
</li>
</ul>
<p>所有事务提交成功，则事务完成。否则，要采取以下两种恢复策略之一：</p>
<ul>
<li><strong>正向恢复</strong>（Forward Recovery）：不需要补偿，一直重试失败事务，直到成功。</li>
<li><strong>反向恢复</strong>（Backward Recovery）：子事务执行失败，一直执行对应的补偿动作，直到成功。</li>
</ul>
<p>SAGA 必须保证所有子事务都得以提交或者补偿，但 SAGA 系统本身也有可能会崩溃，所以它必须设计成与数据库类似的日志机制（被称为 SAGA Log）以保证系统恢复后可以追踪到子事务的执行情况。另外，尽管补偿操作通常比冻结&#x2F;撤销容易实现，但保证正向、反向恢复过程的能严谨地进行也需要花费不少的工夫。我们通常基于某些分布式事务中间件（譬如阿里开源的<a href="https://seata.io/zh-cn/">Seata</a>）去完成，而非裸实现 SAGA。</p>
<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>通常来说，脏写是一定要避免的，因为脏写情况一旦发生，人工其实也很难进行有效处理。所有传统关系数据库在最低的隔离级别上都仍然要加锁以避免脏写。分布式事务中没有一揽子包治百病的解决办法，因地制宜地选用合适的事务处理方案才是唯一有效的做法。</p>
<h2 id="透明多级分流系统"><a href="#透明多级分流系统" class="headerlink" title="透明多级分流系统"></a>透明多级分流系统</h2><p>用户请求从浏览器触发，直至末端数据库，然后逐级返回用户浏览器之中。要历经很多部件，作为系统设计者，应该意识到不同的设施、部件在系统中不同的价值。比如：</p>
<ol>
<li>本地缓存、CDN、反向代理等位于客户端或网络边缘，需要迅速响应用户请求，避免给后方的 I&#x2F;O 与 CPU 带来压力；</li>
<li>能够伸缩的服务节点（后端服务），尽量作为业务逻辑的主要载体，以达到机器换并发；</li>
<li>注册中心、配置中心等，要时刻保持着容错备份以维护高可用；</li>
<li>系统入口的路由、网关、DB等单点不见，只能依靠机器本身的网络、存储和运算性能来提升处理能力；</li>
</ol>
<p>对系统进行流量规划时，充分理解这些部件的价值差异，以及 2 条设计原则：</p>
<ol>
<li>尽可能减少单点部件，如果某些单点是无可避免的，则应尽最大限度减少到达单点部件的流量；</li>
<li>更关键的是：奥卡姆剃刀原则。一方面，要对多级分流的手段有全面的理解和充分的准备，同时意识到这些设施不是越多越好；另一方面，并不是每个系统都追求三高，要依靠的是康威定律，有明确的需求采取部署，在能满足需求的前提下，<strong>最简单的系统就是最好的系统</strong>。</li>
</ol>
<h3 id="客户端缓存"><a href="#客户端缓存" class="headerlink" title="客户端缓存"></a>客户端缓存</h3><p>HTTP 协议的无状态性决定了它必须依靠客户端缓存来解决网络传输效率上的缺陷，手段包括：状态缓存、强制缓存和协商缓存。</p>
<h4 id="强制缓存"><a href="#强制缓存" class="headerlink" title="强制缓存"></a>强制缓存</h4><p>强制缓存是基于时效性的，假设在某个时点到来以前，资源的内容和状态一定不会被改变。因此，客户端无须经过任何请求，在该时点前一直持有和使用该资源的本地缓存副本。</p>
<p>HTTP 协议中设有以下两类 Header 实现强制缓存。</p>
<ul>
<li>Expires ： HTTP&#x2F;1.0</li>
</ul>
<figure class="highlight http"><table><tr><td class="code"><pre><span class="line"><span class="meta">HTTP/1.1</span> <span class="number">200</span> OK</span><br><span class="line"><span class="attribute">Expires</span><span class="punctuation">: </span>Wed, 8 Apr 2020 07:28:00 GMT</span><br></pre></td></tr></table></figure>

<p>存在问题：</p>
<ol>
<li>受限于客户端的本地时间；2. 无法处理涉及到用户身份的私有资源；3. 无法描述“不缓存”；</li>
</ol>
<ul>
<li>Cache-Control : HTTP&#x2F;1.1</li>
</ul>
<figure class="highlight http"><table><tr><td class="code"><pre><span class="line"><span class="meta">HTTP/1.1</span> <span class="number">200</span> OK</span><br><span class="line"><span class="attribute">Cache-Control</span><span class="punctuation">: </span>max-age=600</span><br></pre></td></tr></table></figure>

<p>Cache-Control 在客户端的请求 Header 或服务器的响应 Header 中都可以存在，它定义了一系列的参数，且允许自行扩展。主要参数：</p>
<table>
<thead>
<tr>
<th align="center">参数</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">max-age &amp;&amp; s-maxage</td>
<td align="center">相对于请求时间多少秒内缓存有效;s 是 share 的缩写，允许被 CDN、代理等持有的缓存有效时间</td>
</tr>
<tr>
<td align="center">public &amp;&amp; private</td>
<td align="center">public 可以被代理、CDN 等缓存；private 意味着只能由客户端缓存</td>
</tr>
<tr>
<td align="center">no-cache &amp;&amp; no-store</td>
<td align="center">no-cache 指明该资源不应该被缓存;no-store 不强制会话中相同 URL 资源的重复获取，但禁止浏览器、CDN 等以任何形式保存该资源</td>
</tr>
<tr>
<td align="center">no-transform</td>
<td align="center">禁止资源被任何形式地修改</td>
</tr>
<tr>
<td align="center">min-fresh</td>
<td align="center">仅用于客户端的请求 Header，建议服务器能返回一个不少于该时间的缓存资源</td>
</tr>
<tr>
<td align="center">only-if-cached</td>
<td align="center">求不必给它发送资源的具体内容，此时客户端就仅能使用事先缓存的资源来进行响应</td>
</tr>
<tr>
<td align="center">must-revalidate</td>
<td align="center">资源过期后，一定需要从服务器中进行获取</td>
</tr>
<tr>
<td align="center">proxy-revalidate</td>
<td align="center">除了用来提示代理、CDN 等对象外，语义与 must-revalidate 相同</td>
</tr>
</tbody></table>
<h4 id="协商缓存"><a href="#协商缓存" class="headerlink" title="协商缓存"></a>协商缓存</h4><p>协商缓存基于变化检测，在一致性上会有比强制缓存更好的表现，但需要一次变化检测的交互开销，性能上就会略差。HTTP 中协商缓存与强制缓存并没有互斥性，这两套机制是并行工作的。</p>
<p>协商缓存有两种变动检查机制，分别是检查资源的<code>修改时间</code>和<code>资源唯一标识</code>是否发生变化来检查。它们都是靠一组成对出现的请求、响应 Header 来实现的：</p>
<ul>
<li><p>修改时间的方式：Last-Modified 和 If-Modified-Since</p>
<p>Last-Modified 是服务器的响应 Header，用于告诉客户端这个资源的最后修改时间。对于带有这个 Header 的资源，当客户端需要再次请求时，会通过 If-Modified-Since 把之前收到的资源最后修改时间发送回服务端。如果此时服务端发现资源在该时间后没有被修改过，就只要返回一个没有消息体的 304&#x2F;Not Modified 的响应即可</p>
<figure class="highlight http"><table><tr><td class="code"><pre><span class="line"><span class="meta">HTTP/1.1</span> <span class="number">304</span> Not Modified</span><br><span class="line"><span class="attribute">Cache-Control</span><span class="punctuation">: </span>public, max-age=600</span><br><span class="line"><span class="attribute">Last-Modified</span><span class="punctuation">: </span>Wed, 8 Apr 2020 15:31:30 GMT</span><br></pre></td></tr></table></figure>

<p>如果时间有变动，则返回带有 Last-Modified 的 Header，200 的完整响应</p>
<figure class="highlight http"><table><tr><td class="code"><pre><span class="line"><span class="meta">HTTP/1.1</span> <span class="number">200</span> OK</span><br><span class="line"><span class="attribute">Cache-Control</span><span class="punctuation">: </span>public, max-age=600</span><br><span class="line"><span class="attribute">Last-Modified</span><span class="punctuation">: </span>Wed, 8 Apr 2020 15:31:30 GMT</span><br><span class="line"></span><br><span class="line"><span class="language-css"><span class="attribute">Content</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><p>资源标识的方式：Etag 和 If-None-Match</p>
<p>Etag 是服务器的响应 Header，用于告诉客户端这个资源的唯一标识。当客户端需要再次请求时，会通过 If-None-Match 把之前收到的资源唯一标识发送回服务端。如果此时服务端计算后发现资源的唯一标识与上传回来的一致，说明资源没有被修改过，就只要返回一个没有消息体的 304&#x2F;Not Modified 的响应即可</p>
<figure class="highlight http"><table><tr><td class="code"><pre><span class="line"><span class="meta">HTTP/1.1</span> <span class="number">304</span> Not Modified</span><br><span class="line"><span class="attribute">Cache-Control</span><span class="punctuation">: </span>public, max-age=600</span><br><span class="line"><span class="attribute">ETag</span><span class="punctuation">: </span>&quot;28c3f612-ceb0-4ddc-ae35-791ca840c5fa&quot;</span><br></pre></td></tr></table></figure>

<p>如果资源有变动，则返回带有 Last-Modified 的 Header，200 的完整响应</p>
<figure class="highlight http"><table><tr><td class="code"><pre><span class="line"><span class="meta">HTTP/1.1</span> <span class="number">200</span> OK</span><br><span class="line"><span class="attribute">Cache-Control</span><span class="punctuation">: </span>public, max-age=600</span><br><span class="line"><span class="attribute">ETag</span><span class="punctuation">: </span>&quot;28c3f612-ceb0-4ddc-ae35-791ca840c5fa&quot;</span><br><span class="line"></span><br><span class="line"><span class="language-css"><span class="attribute">Content</span></span></span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h4><p>强制缓存中，如果 Cache-Control 和 Expires 同时存在，并且语义存在冲突，必须以 Cache-Control 为准。</p>
<p>协商缓存中，Etag 是 HTTP 中一致性最强的缓存机制，却是最差的缓存机制。但 Etag 和 Last-Modified 是允许一起使用的，服务器会优先验证 Etag，在 Etag 一致的情况下，再去对比 Last-Modified。</p>
<p>根据约定，协商缓存不仅在浏览器的地址输入、页面链接跳转、新开窗口、前进、后退中生效，而且在用户主动刷新页面（F5）时也同样是生效的，只有用户强制刷新（Ctrl+F5）或者明确禁用缓存（譬如在 DevTools 中设定）时才会失效，此时客户端向服务端发出的请求会自动带有“Cache-Control: no-cache”。</p>
<p>更多信息：<a href="https://book.douban.com/subject/10746113/">HTTP 权威指南</a></p>
<h3 id="域名解析-DNS"><a href="#域名解析-DNS" class="headerlink" title="域名解析 DNS"></a>域名解析 DNS</h3><p>DNS 就是将域名翻译为域名地址记录（通常是 ip）的系统。域名解析对于大多数信息系统，尤其是对于基于互联网的系统来说是必不可少的组件，却没有太高存在感。不过 DNS 本身的工作过程，本身堪称是示范性的透明多级分流系统。</p>
<h4 id="步骤-1"><a href="#步骤-1" class="headerlink" title="步骤"></a>步骤</h4><p>以 <code>www.baidu.com</code> 为例，有如下步骤：</p>
<ol>
<li>DNS 会将域名还原为 <code>www.baidu.com.</code>;</li>
<li>客户端先检查本地的 DNS 缓存；</li>
<li>客户端将地址发送给本机操作系统中配置的本地 DNS；</li>
<li>本地 DNS 收到查询请求后，会按照 a. 是否有<code>www.baidu.com</code>的权威服务器; b. 是否有<code>baidu.com</code>的权威服务器; c. 是否有<code>com</code>的权威服务器的顺序，依次查询自己的地址记录，如果都没有查询到，就会一直找到最后点号代表的根域名服务器；</li>
<li>根据名服务器返回 <code>com</code>的地址记录，通过 <code>com</code> 的权威服务器，得到 <code>baidu.com</code>的地址记录，以此反推，得到 <code>www.baidu.com</code>的权威服务器地址；</li>
<li>通过 <code>www.baidu.com</code>的权威服务器地址，得到地址记录；</li>
</ol>
<pre><code class="highlight mermaid">sequenceDiagram
participant browser as 浏览器
participant local as 本地DNS
participant authority as 权威DNS
participant server as 网站服务器
    browser -&gt;&gt; local: 查询网站icyfenix.cn
    loop 递归查询
        local -&gt;&gt; authority: 查询网站icyfenix.cn
    end
    authority --&gt;&gt; local: 地址：xxx.xxx.xxx.xxx
    local --&gt;&gt; browser: 地址：xxx.xxx.xxx.xxx
    browser -&gt;&gt; server: 请求
    server --&gt;&gt; browser: 响应</code></pre>



<h4 id="问题-1"><a href="#问题-1" class="headerlink" title="问题"></a>问题</h4><ol>
<li><p>响应速度</p>
<p>极端情况下，域名解析都需要递归到根域名服务器才能查询到结果，响应速度变慢；</p>
</li>
<li><p>中间人攻击</p>
<p>这是更严重的问题。攻陷根域名或者权威域名是非常困难的，但很多递归底层和本地运营商的 DNS 服务器防护相对松懈，甚至会主动进行劫持（加入广告进行牟利）。一种解决办法是：<a href="https://en.wikipedia.org/wiki/DNS_over_HTTPS">HTTPDNS</a>，通俗的讲：就是讲 DNS 查询转换为 HTTP 请求来查询地址记录。</p>
</li>
</ol>
<h3 id="传输链路"><a href="#传输链路" class="headerlink" title="传输链路"></a>传输链路</h3><p>经过客户端缓存的节流和 DNS 服务的指引，程序发出的请求正式离开客户端，踏上以服务器为目的地的旅途。这就是：传输链路。</p>
<p>优化链路传输的前端设计原则：<a href="https://developer.yahoo.com/performance/rules.html">雅虎 YSlow-23 条规则</a></p>
<h4 id="连接数优化"><a href="#连接数优化" class="headerlink" title="连接数优化"></a>连接数优化</h4><p>HTTP&#x2F;3 以前TCP 为传输层的应用层协议，但 HTTP over TCP 这种搭配只能说是 TCP 在当今网络中统治性地位所造就的结果，而不能说它们两者配合工作就是合适的。</p>
<p>HTTP 的设计者们也尝试在协议层面去解决连接成本过高的问题，比如 HTTP&#x2F;1.1 中的连接复用技术和 HTTP&#x2F;2 中的多路复用技术，但都不完美。</p>
<h4 id="传输压缩"><a href="#传输压缩" class="headerlink" title="传输压缩"></a>传输压缩</h4><p>静态预压缩（由于 Web 性能提升，已很少采用）：静态资源预先以 .gz 文件形式存放起来，需要哪个返回哪个；</p>
<p>即时压缩：整个压缩过程全部在内存的数据流中完成，不必等资源压缩完成再返回响应。缺点是没法在 Header 中添加 Content-Length，因为输出 Header 服务器无法知道压缩后资源的确切大小。为保证持久连接，最初使用 Content-Length 来判断资源是否请求结束，但即时压缩与最初设计冲突。HTTP&#x2F;1.1 版本中修复了这个缺陷，增加了另一种“<a href="https://en.wikipedia.org/wiki/Chunked_transfer_encoding">分块传输编码</a>”（Chunked Transfer Encoding）的资源结束判断机制。</p>
<figure class="highlight http"><table><tr><td class="code"><pre><span class="line"><span class="meta">HTTP/1.1</span> <span class="number">200</span> OK</span><br><span class="line"><span class="attribute">Date</span><span class="punctuation">: </span>Sat, 11 Apr 2020 04:44:00 GMT</span><br><span class="line"><span class="attribute">Transfer-Encoding</span><span class="punctuation">: </span>chunked</span><br><span class="line"><span class="attribute">Connection</span><span class="punctuation">: </span>keep-alive</span><br><span class="line"></span><br><span class="line"><span class="language-livecodeserver"><span class="number">25</span></span></span><br><span class="line"><span class="language-livecodeserver">This is <span class="keyword">the</span> data <span class="keyword">in</span> <span class="keyword">the</span> <span class="keyword">first</span> chunk</span></span><br><span class="line"><span class="language-livecodeserver"></span></span><br><span class="line"><span class="language-livecodeserver"><span class="number">1</span>C</span></span><br><span class="line"><span class="language-livecodeserver"><span class="keyword">and</span> this is <span class="keyword">the</span> <span class="keyword">second</span> <span class="literal">one</span></span></span><br><span class="line"><span class="language-livecodeserver"></span></span><br><span class="line"><span class="language-livecodeserver"><span class="number">3</span></span></span><br><span class="line"><span class="language-livecodeserver">con</span></span><br><span class="line"><span class="language-livecodeserver"></span></span><br><span class="line"><span class="language-livecodeserver"><span class="number">8</span></span></span><br><span class="line"><span class="language-livecodeserver">sequence</span></span><br><span class="line"><span class="language-livecodeserver"></span></span><br><span class="line"><span class="language-livecodeserver"><span class="number">0</span></span></span><br><span class="line"><span class="language-livecodeserver"></span></span><br><span class="line"><span class="language-livecodeserver"><span class="string">&quot;This is the data in the first chunk\r\n&quot;</span>      (<span class="number">37</span> 字符 =&gt; 十六进制: <span class="number">0x25</span>)</span></span><br><span class="line"><span class="language-livecodeserver"><span class="string">&quot;and this is the second one\r\n&quot;</span>               (<span class="number">28</span> 字符 =&gt; 十六进制: <span class="number">0x1C</span>)</span></span><br><span class="line"><span class="language-livecodeserver"><span class="string">&quot;con&quot;</span>                                          (<span class="number">3</span>  字符 =&gt; 十六进制: <span class="number">0x03</span>)</span></span><br><span class="line"><span class="language-livecodeserver"><span class="string">&quot;sequence&quot;</span>                                     (<span class="number">8</span>  字符 =&gt; 十六进制: <span class="number">0x08</span>)</span></span><br><span class="line"><span class="language-livecodeserver"><span class="comment"></span></span></span><br><span class="line"><span class="comment"><span class="language-livecodeserver">// 解码后</span></span></span><br><span class="line"><span class="language-livecodeserver">This is <span class="keyword">the</span> data <span class="keyword">in</span> <span class="keyword">the</span> <span class="keyword">first</span> chunk</span></span><br><span class="line"><span class="language-livecodeserver"><span class="keyword">and</span> this is <span class="keyword">the</span> <span class="keyword">second</span> <span class="literal">one</span></span></span><br><span class="line"><span class="language-livecodeserver">consequence</span></span><br></pre></td></tr></table></figure>

<p>到了 HTTP&#x2F;2，由于多路复用和单域名单连接的设计，已经无须再刻意去提持久链接机制了，但数据压缩仍然有节约传输带宽的重要价值。</p>
<h4 id="快速-UDP-网络连接"><a href="#快速-UDP-网络连接" class="headerlink" title="快速 UDP 网络连接"></a>快速 UDP 网络连接</h4><p>HTTP 是应用层协议，它的设计不应该过多地考虑底层的传输细节。从职责上讲，持久连接、多路复用、分块编码这些能力，已经或多或少超过了应用层的范畴。要从根本上改进 HTTP，必须直接替换掉 HTTP over TCP 的根基，即替换掉 TCP 传输协议，最新一代 HTTP&#x2F;3 协议的设计重点就在这儿。</p>
<p><a href="https://en.wikipedia.org/wiki/QUIC">快速 UDP 网络连接</a>（Quick UDP Internet Connections，QUIC）是由 Google 公司推动，以 UDP 协议为基础，不仅能满足 HTTP 传输协议，日后还能支持 SMTP、DNS、SSH、Telnet、NTP 等多种其他上层协议的最新一代互联网标准，即 HTTP over QUIC 的  HTTP&#x2F;3 版本号。</p>
<p>一方面，可靠传输能力完全是 QUIC 实现。另一方面，面向移动设备的专门支持。</p>
<h4 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h4><p>一旦在技术根基上出现问题，依靠使用者通过 Tricks 去解决，无论如何都难以摆脱“两害相权取其轻”的权衡困境，否则这就不是 Tricks 而是会成为一种标准的设计模式了。</p>
<h3 id="内容分发网络"><a href="#内容分发网络" class="headerlink" title="内容分发网络"></a>内容分发网络</h3><p>如果抛弃其他影响服务质量的因素，仅从网络传输的角度看，一个互联网系统的速度取决于以下四点因素：</p>
<ol>
<li>网站服务器接入网络运营商的链路的出口带宽；</li>
<li>用户客户端接入网络运营商的链路的入口带宽；</li>
<li>不同运营商之间互联节点的带宽。一般不同运营商只有若干个节点是互通的；</li>
<li>从网站到用户之间的物理链路传输时延；</li>
</ol>
<p>以上四个网络问题，除了第二个只能通过换一个更好的宽带才能解决之外，其余三个都能通过内容分发网络来显著改善。一个运作良好的内容分发网络，能为互联网系统解决跨运营商、跨地域物理距离所导致的时延问题，能为网站流量带宽起到分流、减负的作用。内容分发网络的工作过程，主要涉及域名解析、内容分发、负载均衡和所能支持的 CDN 应用内容四个方面。</p>
<h4 id="域名解析"><a href="#域名解析" class="headerlink" title="域名解析"></a>域名解析</h4><ol>
<li>架设好“icyfenix.cn”的服务器后，会将服务器 IP 地址在 CDN 服务商上注册为“源站”，CDN 服务商会生成一个“源站”的 CNAME 记录；</li>
<li>将 CNAME 记录注册到域名权威 DNS 和 CNAME 的权威 DNS 上；</li>
<li>域名权威DNS 发现是 CNAME 记录后，返回给本地 DNS，之后链路解析的主导权就开始由内容分发网络的调度服务接管了；</li>
<li>CNAME 的权威 DNS 根据负载均衡策略和参数，挑选一个最合适的 CDN 节点，将其 IP 进行返回；</li>
<li>访问 IP 即可；</li>
</ol>
<pre><code class="highlight mermaid">sequenceDiagram
participant browser as 浏览器
participant local as 本地DNS
participant authority as 域名权威DNS
participant cname as CNAME的权威DNS
participant cdn as CDN服务器
participant server as 源站服务器
    browser -&gt;&gt; local: 查询网站icyfenix.cn
    loop 递归查询
        local -&gt;&gt; authority: 查询网站icyfenix.cn
    end
    authority --&gt;&gt; local: 返回 CNAME 记录
    local --&gt;&gt; cname: 查询 CNAME 记录
    loop 递归查询
        cname -&gt;&gt; cname: 经过递归查询和负载均衡，确定合适的CDN
    end
    cname --&gt;&gt; local: 地址：xxx.xxx.xxx.xxx
    local --&gt;&gt; browser: 地址：xxx.xxx.xxx.xxx
    browser -&gt;&gt; cdn: 请求
    cdn -&gt;&gt; server: 请求
    server --&gt;&gt; cdn: 响应
    cdn --&gt;&gt; browser: 响应</code></pre>



<h4 id="内容分发"><a href="#内容分发" class="headerlink" title="内容分发"></a>内容分发</h4><p>内容分发就是 CDN 获取源站资源的过程，包括“如何获取源站资源”和“如何更新资源” 2 方面。</p>
<p>如何获取源站资源：</p>
<ol>
<li><p>主动分发 PUSH</p>
<p>由源站主动将资源推送到用户边缘的各个 CDN 缓存节点上。正因如此，它对源站并不是透明的，只对用户一侧单向透明。主动分发一般用于网站要预载大量资源的场景。</p>
</li>
<li><p>被动回源 PULL</p>
<p>由用户访问所触发全自动、双向透明的资源缓存过程。</p>
</li>
</ol>
<p>如何更新资源：</p>
<p>没有统一标准，取决于 CDN 服务商的实现策略。由于大多数网站的开发和运维人员并不十分了解 HTTP 缓存机制，导致如果 CDN 服务商完全照着 HTTP Headers 来控制缓存失效和更新，效果反而会相当的差，还可能引发其他问题。</p>
<p>现在，最常见的做法是超时被动失效与手工主动失效相结合。超时失效是指给予缓存资源一定的生存期，超过了生存期就在下次请求时重新被动回源一次。而手工失效是指 CDN 服务商一般会提供给程序调用来失效缓存的接口，在网站更新时，由持续集成的流水线自动调用该接口来实现缓存更新。</p>
<h4 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h4><p>调度后方的多台机器，以统一的接口对外提供服务，承担此职责的技术组件被称为“负载均衡”。真正大型系统的负载均衡往往是多级的。</p>
<ul>
<li>四层负载均衡的优势是性能高，七层负载均衡的优势是功能强；</li>
<li>做多级混合负载均衡，通常应是低层的负载均衡在前，高层的负载均衡在后；</li>
</ul>
<ol>
<li><p>数据链路层负载均衡</p>
<p>数据链路层负载均衡所做的工作，是修改请求的数据帧中的 MAC 目标地址，让用户原本是发送给负载均衡器的请求的数据帧，被二层交换机根据新的 MAC 目标地址转发到服务器集群中对应的服务器（后文称为“真实服务器”，Real Server）的网卡上，这样真实服务器就获得了一个原本目标并不是发送给它的数据帧。</p>
<p><img src="https://gitee.com/Jeremy454/pic-go-upload/raw/master/typora/image-20230621185013674.png" alt="image-20230621185013674"></p>
<p>数据链路层负载均衡器直接改写目标 MAC 地址的工作原理决定了它与真实的服务器的通信必须是二层可达的。通俗地说就是必须位于同一个子网当中，无法跨 VLAN。优势（效率高）和劣势（不能跨子网）共同决定了数据链路层负载均衡最适合用来做数据中心的第一级均衡设备，用来连接其他的下级负载均衡器。</p>
</li>
<li><p>网络层负载均衡</p>
<p>与链路层类似，网络层通过改变 IP 地址来实现数据包转发。</p>
<p>IP 隧道：新创建一个数据包，把原来数据包的 Headers 中目标 IP 修改后和 Payload 整体作为另一个新的数据包的 Payload 发送出去。一个缺点是服务器必须支持 IP 隧道协议，另一个是必须专门配置。</p>
<p><img src="https://gitee.com/Jeremy454/pic-go-upload/raw/master/typora/image-20230621185454338.png" alt="image-20230621185454338"></p>
<p>网络地址转换：直接修改源数据包的目标 IP 后发出去。</p>
<p><img src="https://gitee.com/Jeremy454/pic-go-upload/raw/master/typora/image-20230621185649892.png" alt="image-20230621185649892"></p>
<p>在流量压力比较大的时候，NAT 模式的负载均衡会带来较大的性能损失，比起直接路由和 IP 隧道模式，甚至会出现数量级上的下降。因为所有流量都在争抢均衡器出口带宽。</p>
</li>
<li><p>应用层负载均衡</p>
<p>链路层和网络层的负载均衡模式都属于转发，此时客户端到响应请求维持同一条 TCP 通道，但工作在应用层的负载均衡只能进行代理，此时真实服务器、负载均衡器、客户端三者之间由两条独立的 TCP 通道来维持通信。</p>
<p><img src="https://gitee.com/Jeremy454/pic-go-upload/raw/master/typora/image-20230622171828070.png" alt="image-20230622171828070"></p>
<p>“代理”这个词，根据“哪一方能感知到”的原则，可以分为“正向代理”、“反向代理”和“透明代理”三类。正向代理就是我们通常简称的代理，指在客户端设置的、代表客户端与服务器通信的代理服务，它是客户端可知，而对服务器透明的。反向代理是指在设置在服务器这一侧，代表真实服务器来与客户端通信的代理服务，此时它对客户端来说是透明的。至于透明代理是指对双方都透明的，配置在网络中间设备上的代理服务，譬如，架设在路由器上的透明翻墙代理。</p>
</li>
<li><p>总结</p>
<p>负载均衡的两大职责是“选择谁来处理用户请求”（均衡策略：轮询、权重轮询、随机、权重随机、一致性哈希、响应速度、最少连接数等）和“将用户请求转发过去”（转发和代理）。</p>
<p>负载均衡器从实现上又分为软件和硬件。硬件会直接采用应用专用集成电路 ASIC 来实现，如 F5 和 A10。软件分为 OS 层，如 LVS 和应用层，如 Nginx、HAProxy、KeepAlived。</p>
</li>
</ol>
<h4 id="CDN-应用"><a href="#CDN-应用" class="headerlink" title="CDN 应用"></a>CDN 应用</h4><ul>
<li>加速静态资源：本职工作；</li>
<li>安全防御：CDN 可以视为网站的堡垒机；</li>
<li>协议提升；</li>
<li>状态缓存；</li>
<li>修改资源；</li>
<li>访问控制；</li>
<li>注入功能；</li>
<li>等等</li>
</ul>
<h3 id="服务端缓存"><a href="#服务端缓存" class="headerlink" title="服务端缓存"></a>服务端缓存</h3><p>为系统引入缓存之前，第一件事情是确认你的系统是否真的需要缓存。软件开发中引入缓存的负面作用要明显大于硬件的缓存：1. 开发角度，引入缓存会提高系统复杂度（缓存失效、更新、一致性等问题）；2. 运维角度，缓存会掩盖掉一些缺陷，让问题在更久的时间以后，出现在距离发生现场更远的位置上；3. 安全角度，缓存可能泄漏某些保密数据，也是容易受到攻击的薄弱点。</p>
<p>冒着上述种种风险，仍能说服你引入缓存的理由，总结起来无外乎以下两种：</p>
<ol>
<li>为缓解 CPU 压力而做缓存，顺带提升响应性能。譬如把方法运行结果存储起来、把原本要实时计算的内容提前算好、把一些公用的数据进行复用；</li>
<li>为缓解 I&#x2F;O 压力而做缓存，顺带提升响应性能。譬如把原本对网络、磁盘等较慢介质的读写访问变为对内存等较快介质的访问；</li>
</ol>
<p>出发点是缓解压力，顺带提升性能。如果能通过增强 CPU、I&#x2F;O 本身性能来满足需求，升级硬件往往是更好的解决方案。</p>
<h4 id="缓存属性"><a href="#缓存属性" class="headerlink" title="缓存属性"></a>缓存属性</h4><ol>
<li><p>吞吐量：缓存的吞吐量使用 OPS 值，反映了缓存对并发读写操作的效率</p>
<p><img src="https://gitee.com/Jeremy454/pic-go-upload/raw/master/typora/image-20230625115703078.png" alt="image-20230625115703078"></p>
</li>
<li><p>命中率与淘汰策略</p>
<p>FIFO、LRU、LFU、TinyLFU等等</p>
</li>
<li><p>扩展功能：缓存提供的额外功能，如最大容量、失效时间、失效事件、命中率统计等等</p>
<p>加载器、淘汰策略、失效策略、事件通知、并发级别、容量控制、引用方式、统计信息、持久化等。</p>
</li>
<li><p>分布式支持</p>
<ul>
<li>访问角度：理论上，更新少、读取多更适合复制式缓存；更新多、读取多更适合集中式缓存。</li>
</ul>
</li>
</ol>
<h4 id="缓存风险"><a href="#缓存风险" class="headerlink" title="缓存风险"></a>缓存风险</h4><ol>
<li><p>缓存穿透</p>
<p>缓存每次都未命中，触及到末端数据库的现象。</p>
<p>措施：</p>
<ul>
<li>可以约定在一定时间内对返回为空的 Key 值依然进行缓存，使得在一段时间内缓存最多被穿透一次；</li>
<li>恶意攻击导致缓存穿透，通常会在缓存之前设置一个布隆过滤器；</li>
</ul>
</li>
<li><p>缓存击穿</p>
<p>缓存中某些热点数据突然失效，此时又有多条针对该数据的请求，导致请求穿透缓存，触及到末端数据库的现象。</p>
<p>措施：</p>
<ul>
<li>加锁同步，以请求该数据的 Key 值为锁，使得只有第一个请求可以流入到真实的数据源中，其他线程采取阻塞或重试策略；</li>
<li>热点数据由代码来手动管理；</li>
</ul>
</li>
<li><p>缓存雪崩</p>
<p>缓存击穿是针对单个热点数据失效，而大批不同的数据在短时间内一起失效，导致的缓存击穿的现象。</p>
<p>措施：</p>
<ul>
<li>提升缓存系统可用性，建设分布式缓存的集群；</li>
<li>启用透明多级缓存，各个服务节点一级缓存中的数据通常会具有不一样的加载时间；</li>
<li>将缓存的生存期从固定时间改为一个时间段内的随机时间；</li>
</ul>
</li>
<li><p>缓存污染</p>
<p>缓存中的数据和数据源中不一样的现象。</p>
</li>
</ol>
<h4 id="多级缓存"><a href="#多级缓存" class="headerlink" title="多级缓存"></a>多级缓存</h4><p><img src="https://gitee.com/Jeremy454/pic-go-upload/raw/master/typora/image-20230625120731535.png" alt="image-20230625120731535"></p>
<p>使用进程内缓存做一级缓存，分布式缓存做二级缓存，如果能在一级缓存中查询到结果就直接返回，否则便到二级缓存中去查询，再将二级缓存中的结果回填到一级缓存，以后再访问该数据就没有网络请求了。如果二级缓存也查询不到，就发起对最终数据源的查询，将结果回填到一、二级缓存中去。</p>
<p>当数据发生变动时，在集群内发送推送通知（简单点的话可采用 Redis 的 PUB&#x2F;SUB，求严谨的话引入 ZooKeeper 或 Etcd 来处理），让各个节点的一级缓存自动失效掉相应数据。当访问缓存时，提供统一封装好的一、二级缓存联合查询接口，接口外部是只查询一次，接口内部自动实现优先查询一级缓存，未获取到数据再自动查询二级缓存的逻辑。</p>
<h2 id="架构安全"><a href="#架构安全" class="headerlink" title="架构安全"></a>架构安全</h2><p>认证、授权和凭证是一个系统中最基础的安全设计，哪怕再简陋的信息系统，大概也不可能忽略掉“用户登录”功能。</p>
<h3 id="认证"><a href="#认证" class="headerlink" title="认证"></a>认证</h3><p>系统如何正确分辨出操作用户的真实身份？</p>
<p>Spring Security 和 Apache Shiro</p>
<h3 id="授权"><a href="#授权" class="headerlink" title="授权"></a>授权</h3><p>系统如何控制一个用户该看到哪些数据、能操作哪些功能？</p>
<h4 id="RBAC"><a href="#RBAC" class="headerlink" title="RBAC"></a>RBAC</h4><p>某用户隶属于什么角色拥有哪些许可可以操作多少资源。</p>
<h4 id="OAuth2"><a href="#OAuth2" class="headerlink" title="OAuth2"></a>OAuth2</h4><p>面向与解决第三方用户的认证授权问题。</p>
<h3 id="凭证"><a href="#凭证" class="headerlink" title="凭证"></a>凭证</h3><p>系统如何保证它与用户之间的承诺是双方当时真实意图的体现，是准确、完整且不可抵赖的？</p>
<h4 id="Cookie-Session"><a href="#Cookie-Session" class="headerlink" title="Cookie-Session"></a>Cookie-Session</h4><p>状态信息存储于服务端，在”安全性“有先天优势，但只是在单节点中是合适的。分布式环境中，由于 CAP 的缘故，状态管理受到局限。</p>
<h4 id="JWT"><a href="#JWT" class="headerlink" title="JWT"></a>JWT</h4><p>JWT 令牌是多方系统中一种优秀的凭证载体，它不需要任何一个服务节点保留任何一点状态信息，就能够保障认证服务与用户之间的承诺是双方当时真实意图的体现。同时，由于 JWT 本身可以携带少量信息，能够较容易地做成无状态服务，在做水平扩展时就不需要像前面 Cookie-Session 方案那样考虑如何部署的问题。</p>
<h3 id="保密"><a href="#保密" class="headerlink" title="保密"></a>保密</h3><p>系统如何保证敏感数据无法被包括系统管理员在内的内外部人员所窃取、滥用？</p>
<h4 id="保密的强度"><a href="#保密的强度" class="headerlink" title="保密的强度"></a>保密的强度</h4><p>更高安全强度意味着更多代价。</p>
<h4 id="客户端加密"><a href="#客户端加密" class="headerlink" title="客户端加密"></a>客户端加密</h4><p>这里的意思是客户端是否要对密码进行加密后，传输到服务端。</p>
<p>为了保证信息不被黑客窃取而做客户端加密没有太多意义，对绝大多数的信息系统来说，启用 HTTPS 可以说是唯一的实际可行的方案。</p>
<h4 id="密码存储和验证"><a href="#密码存储和验证" class="headerlink" title="密码存储和验证"></a>密码存储和验证</h4><p>只要配合一定的密码规则约束，譬如密码要求长度、特殊字符等，再配合 HTTPS 传输，已足防御大多数风险了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Encode the raw password. Generally, a good encoding algorithm applies a SHA-1 or</span></span><br><span class="line"><span class="comment"> * greater hash combined with an 8-byte or greater randomly generated salt.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">encrypt</span><span class="params">(CharSequence rawPassword)</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">BCryptPasswordEncoder</span>().encode(Optional.ofNullable(rawPassword).orElse(<span class="string">&quot;&quot;</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Verify the encoded password obtained from storage matches the submitted raw</span></span><br><span class="line"><span class="comment"> * password after it too is encoded. Returns true if the passwords match, false if</span></span><br><span class="line"><span class="comment"> * they do not. The stored password itself is never decoded.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> rawPassword the raw password to encode and match</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> encodedPassword the encoded password from storage to compare with</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> true if the raw password, after encoding, matches the encoded password from</span></span><br><span class="line"><span class="comment"> * storage</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">matches</span><span class="params">(CharSequence rawPassword, String encodedPassword)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">BCryptPasswordEncoder</span>().matches(rawPassword, encodedPassword);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="传输"><a href="#传输" class="headerlink" title="传输"></a>传输</h3><p>系统如何保证通过网络传输的信息无法被第三方窃听、篡改和冒充？</p>
<h4 id="摘要、加密与签名"><a href="#摘要、加密与签名" class="headerlink" title="摘要、加密与签名"></a>摘要、加密与签名</h4><p><a href="https://en.wikipedia.org/wiki/Cryptographic_hash_function">摘要</a>也称之为数字摘要（Digital Digest）或数字指纹（Digital Fingerprint），意义是在源信息不泄漏的前提下辨别其真伪，易变性保证了从公开的特征上可以甄别出是否来自于源信息，不可逆性保证了从公开的特征并不会暴露出源信息。</p>
<p>加密与摘要的本质区别在于加密是可逆的，逆过程就是解密。根据加密与解密是否采用同一个密钥，现代密码学算法可分为对称加密算法和非对称加密。对称加密的问题在于：1. 当通信的成员数量增加时，面临密钥管理的难题；2. 密钥如何安全传输。非对称加密将密钥分成公钥和私钥，公钥可以完全公开，无须安全传输的保证。私钥由用户自行保管，不参与任何通信传输。根据这两个密钥加解密方式的不同，使得算法可以提供两种不同的功能：<strong>称为加密的公钥加密，私钥解密</strong>和<strong>称为签名的私钥加密，公钥解密</strong>。</p>
<table>
<thead>
<tr>
<th align="center">类型</th>
<th align="center">特点</th>
<th align="center">常见实现</th>
<th align="center">主要用途</th>
<th align="center">主要局限</th>
</tr>
</thead>
<tbody><tr>
<td align="center">哈希摘要</td>
<td align="center">易变和不可逆</td>
<td align="center">MD2&#x2F;4&#x2F;5&#x2F;6、SHA0&#x2F;1&#x2F;256&#x2F;512</td>
<td align="center">摘要</td>
<td align="center">无法解密</td>
</tr>
<tr>
<td align="center">对称加密</td>
<td align="center">密钥相同速度快、设计难度小、明文长度不受限</td>
<td align="center">DES、AES、RC4、IDEA</td>
<td align="center">加密</td>
<td align="center">要解决如何把密钥安全地传递给解密者</td>
</tr>
<tr>
<td align="center">非对称加密</td>
<td align="center">加解密密钥不同<br/>明文长度不能超过公钥长度。</td>
<td align="center">RSA、BCDSA、ElGamal</td>
<td align="center">签名、传递密钥</td>
<td align="center">性能与加密明文长度受限</td>
</tr>
</tbody></table>
<h4 id="数字证书"><a href="#数字证书" class="headerlink" title="数字证书"></a>数字证书</h4><p>当我们无法以“签名”的手段来达成信任时，就只能求助于其他途径。1. <strong>基于共同私密信息的信任</strong>；2. <strong>基于权威公证人的信任</strong>。我们并不能假设授权服务器和资源服务器是互相认识的，所以通常不太会采用第一种方式，而第二种就是目前标准的保证公钥可信分发的标准，而数字证书认证中心（Certificate Authority，CA）就是权威公证人。</p>
<h4 id="传输安全层"><a href="#传输安全层" class="headerlink" title="传输安全层"></a>传输安全层</h4><p>以 TLS 1.2 为例。</p>
<ol>
<li><strong>客户端请求</strong>：Client Hello。客户端向服务器请求进行加密通信，在这个请求里面，它会以<strong>明文</strong>的形式，向服务端提供以下信息； </li>
<li><strong>服务器回应</strong>：Server Hello。服务器接收到客户端的通信请求后，如果客户端声明支持的协议版本和加密算法组合与服务端相匹配的话，就向客户端发出回应。如果不匹配，将会返回一个握手失败的警告提示；</li>
<li><strong>客户端确认</strong>：Client Handshake Finished。客户端收到服务器应答后，先要验证服务器的证书合法性。如果证书没有问题，客户端就会从证书中取出服务器的公钥，并向服务器发送以下信息若干信息；</li>
<li><strong>服务端确认</strong>：Server Handshake Finished。服务端向客户端回应最后的确认通知，包括以下信息；</li>
</ol>
<p>至此，整个 TLS 握手阶段宣告完成，一个安全的连接就已成功建立。每一个连接建立时，客户端和服务端均通过上面的握手过程协商出了许多信息，此后该连接的通信将使用此密钥和加密算法进行加密、解密和压缩。这种处理方式对上层协议的功能上完全透明的，在传输性能上会有下降，建立在这层安全传输层之上的 HTTP 协议，就被称为“HTTP over SSL&#x2F;TLS”，也即是大家所熟知的 HTTPS。</p>
<h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h3><p>系统如何确保提交到每项服务中的数据是合乎规则的，不会对系统稳定性、数据一致性、正确性产生风险？</p>
]]></content>
      <tags>
        <tag>reading notes</tag>
      </tags>
  </entry>
  <entry>
    <title>奔跑吧，程序员</title>
    <url>/2023/05/26/reading-note-hello-startup/</url>
    <content><![CDATA[<h1 id="⭐⭐⭐⭐"><a href="#⭐⭐⭐⭐" class="headerlink" title="⭐⭐⭐⭐"></a>⭐⭐⭐⭐</h1><p>如果你打算技术创业，那应该全书阅读；如果你没有这样的打算，推荐针对性阅读。作者由于身处外国，很难针对国内读者提供实质帮助，更多是思路上的。</p>
<p>产品部分，打开了技术开发者的视野；技术部分，特别是代码整洁部分，主要是思路，更细致的落地还需要看别的参考书。例如，《代码大全》、《重构》等；团队部分，求职、招聘对招聘者和应聘者都有值得思考的地方。</p>
<p>总体来说，还是推荐阅读的。</p>
<span id="more"></span>

<h1 id="产品"><a href="#产品" class="headerlink" title="产品"></a>产品</h1><h2 id="何为创业"><a href="#何为创业" class="headerlink" title="何为创业"></a>何为创业</h2><p>创立公司最合适的原因就是你对某个想法充满热情，非要把它带给全世界。</p>
<h3 id="何为科技创业公司"><a href="#何为科技创业公司" class="headerlink" title="何为科技创业公司"></a>何为科技创业公司</h3><p>从事技术研发、环境总在变化、目标为了增长、商业模式还在探索的公司。</p>
<h3 id="入职创业公司"><a href="#入职创业公司" class="headerlink" title="入职创业公司"></a>入职创业公司</h3><ol>
<li><p>更多机会</p>
<p>在创业公司中编写代码，有更多机会影响别人。</p>
</li>
<li><p>高灵活度</p>
<p>自主权、掌控力和使命感。</p>
</li>
<li><p>更多乐趣</p>
<p>痛并快乐着。</p>
</li>
</ol>
<h3 id="创业公司真相"><a href="#创业公司真相" class="headerlink" title="创业公司真相"></a>创业公司真相</h3><ol>
<li><p>并不光鲜亮丽</p>
<p>创办公司和解决有趣的技术问题之间存在巨大的差异。</p>
</li>
<li><p>做出牺牲</p>
<p>只有你愿意把生命的下一个十年都花在开创一家公司上，你才能去做这件事。</p>
</li>
<li><p>不一定发家致富</p>
<p>1&#x2F;4 的概率才能成功</p>
</li>
</ol>
<h2 id="创业点子"><a href="#创业点子" class="headerlink" title="创业点子"></a>创业点子</h2><p>混搭和重新组合是产生电子的常见方法。创新的最佳方式是研究、注明出处、重新合成、聚合和转换。</p>
<h3 id="积累知识"><a href="#积累知识" class="headerlink" title="积累知识"></a>积累知识</h3><p>专注于自己领域的同时，扩展到其他领域。让自己感兴趣的内容和其他领域进行结合。</p>
<h3 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h3><ol>
<li><p>充足的思考时间；</p>
</li>
<li><p>记录点子；</p>
<p>不做任何评判的记录，包括问题、想到的解决方案、当时的环境，并定期回顾。</p>
</li>
<li><p>定期放空自己；</p>
</li>
<li><p>与信赖的朋友交谈；</p>
<p>业务 &#x3D; 点子 + 执行力。持续的好点子和高效的执行力，二者缺一不可。</p>
</li>
</ol>
<h3 id="验证点子"><a href="#验证点子" class="headerlink" title="验证点子"></a>验证点子</h3><p>验证点子是否大到有必要建立一家创业公司去解决。</p>
<ul>
<li>频率：你所解决的问题经常发生吗？</li>
<li>密度：有很多人都会面临这个问题吗？</li>
<li>痛苦程度：该问题只是让人讨厌，还是绝对必须解决？</li>
</ul>
<h4 id="估算市场规模"><a href="#估算市场规模" class="headerlink" title="估算市场规模"></a>估算市场规模</h4><p>广告、竞争、社区、市场研究报告、产品数据；</p>
<h4 id="进一步与客户交谈"><a href="#进一步与客户交谈" class="headerlink" title="进一步与客户交谈"></a>进一步与客户交谈</h4><ul>
<li>对该客户而言，那是一个真正的问题吗？</li>
<li>针对该问题，有什么可能的解决方案？</li>
<li>该客户愿意支付多少钱去解决这个问题？</li>
</ul>
<h4 id="设计产品"><a href="#设计产品" class="headerlink" title="设计产品"></a>设计产品</h4><ol>
<li>MVP 产品</li>
<li>客户参与；</li>
</ol>
<h2 id="产品设计"><a href="#产品设计" class="headerlink" title="产品设计"></a>产品设计</h2><p>界面就是产品，设计不仅仅是看上去的样子，还关乎它如何使用。</p>
<h3 id="设计"><a href="#设计" class="headerlink" title="设计"></a>设计</h3><p>设计就是如何去呈现信息，让他人可以理解并使用这些信息。</p>
<ol>
<li>设计是迭代的；</li>
<li>用户为中心；<ul>
<li>用户故事：从用户角度简短描述你所做的东西。1. 用户是谁？2. 要实现什么；3. 为什么需要？</li>
<li>人物角色：模拟出使用产品的虚构角色。1. 特定目标；2. 性格；3. 真正用户；</li>
<li>情感设计：把产品当作人来对待。1. 考虑周到；2. 积极响应；3. 宽容；</li>
<li>简单：精简而没有多余的东西。</li>
<li>可用性测试：1. 记录用户使用过程；2. 团队分析；3. 每月重复；</li>
</ul>
</li>
<li>视觉设计<ul>
<li>文案：产品设计的核心；</li>
<li>重用：模仿他人的产品后，进行修正；</li>
<li>布局：留白和对齐；</li>
<li>排版：行宽、行距、字型；</li>
<li>对比：突出差别；</li>
<li>强调：突出重点；</li>
<li>颜色：只有在布局和字体都决定后，颜色方案才有意义；</li>
</ul>
</li>
</ol>
<h3 id="MVP"><a href="#MVP" class="headerlink" title="MVP"></a>MVP</h3><p>Minimum:“最简”意味着所有对当前假设的验证没有直接帮助的东西都应该被排除。</p>
<p>Viable:“可行”意味着 MVP 能够让客户接受它。</p>
<p>（1）找出风险最大、最重要的设想；（2）把这种设想以一种可测试的假设描述出来；（3）构建一个最小的实验（一个MVP）去测试你的假设；（4）分析结果；（5）用新发现去重复第一个步骤。</p>
<h4 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h4><ul>
<li>页面展示：容易实现、成本低、效果出众；</li>
<li>介绍视频；</li>
<li>众筹；</li>
<li>绿野仙踪：模拟真实产品；</li>
<li>拼凑；</li>
</ul>
<h4 id="差异"><a href="#差异" class="headerlink" title="差异"></a>差异</h4><p>MVP 中要突出差异性。</p>
<h2 id="数据营销"><a href="#数据营销" class="headerlink" title="数据营销"></a>数据营销</h2><h3 id="数据"><a href="#数据" class="headerlink" title="数据"></a>数据</h3><p>数据就是如何把一些假设和猜测转变为具体、可操作的行为。</p>
<p>数据测量的回报符合长尾。最初几次的回报最可观，后续越来越小。</p>
<h4 id="选择指标标准"><a href="#选择指标标准" class="headerlink" title="选择指标标准"></a>选择指标标准</h4><ul>
<li>如果我可以测量X，它至少会影响一个具体的决定吗？</li>
<li>该决定的价值超过测量X的成本吗？</li>
</ul>
<h4 id="必备指标"><a href="#必备指标" class="headerlink" title="必备指标"></a>必备指标</h4><ul>
<li>获取：用户如何找到你的产品;</li>
<li>激活：测量有多少用户被你的产品所吸引，进行了账号注册、邀请朋友、执行搜索或者支付等动作；</li>
<li>留存：让激活的用户回来并再次使用你的产品；</li>
<li>推荐：不仅仅在于它是我们获得用户的一个来源，也是衡量产品质量的一个指标；</li>
<li>收益：赚了多少钱，这些钱是通过什么渠道获得的；</li>
</ul>
<h4 id="数据引入开发"><a href="#数据引入开发" class="headerlink" title="数据引入开发"></a>数据引入开发</h4><ul>
<li>开发过程：发布前，增加 A&#x2F;B 测试；</li>
<li>完善 MVP：A&#x2F;B 测试后，完善开发 MVP；</li>
</ul>
<p>（1）做一个MVP。（2）对其进行A&#x2F;B测试。（3）分析结果并做出下面三个决定中的一个。a．改善：测试得出的数字不错，足以证明我们能够进一步完善MVP，回到步骤1。b．发布：测试得出的数字非常好，并且产品已经完成，可以向所有人发布。c．放弃：测试得出的数字并不好，不足以证明应该继续工作，可以转到下一个点子上。</p>
<h3 id="营销"><a href="#营销" class="headerlink" title="营销"></a>营销</h3><p>营销就是如何让用户找到你的产品，并且影响他们对产品的感知。</p>
<h4 id="口口相传"><a href="#口口相传" class="headerlink" title="口口相传"></a>口口相传</h4><ul>
<li>更好的产品；</li>
<li>出色的客户服务；</li>
<li>病毒式循环；</li>
</ul>
<h4 id="市场推广"><a href="#市场推广" class="headerlink" title="市场推广"></a>市场推广</h4><ul>
<li>广告：严格跟踪用户获取渠道，这样才能判断广告是否有效；</li>
<li>公共关系与媒体；</li>
<li>email：根据用户所关心的活动或事件相应地发送个性化的邮件；</li>
<li>SEO：对网站进行优化，让网站在搜索结果中有较高的排名；</li>
<li>社交媒体；</li>
<li>集客式营销：利用客户觉得有价值的内容去引起关注，而不是像广告那样去购买客户的关注。</li>
</ul>
<h4 id="销售"><a href="#销售" class="headerlink" title="销售"></a>销售</h4><ul>
<li>自动化销售：无须交谈就可以完成购买；</li>
<li>内部销售：工作场所完成；</li>
<li>外部销售：需要去客户现场演示；</li>
</ul>
<h4 id="品牌化"><a href="#品牌化" class="headerlink" title="品牌化"></a>品牌化</h4><p>不是最出色的产品胜出，而是客户认为最出色的产品胜出，这就是品牌的力量。品牌的建立与具体的产品关系不大，它关乎的是情感和信念，关乎公司为何存在而不是公司是做什么的。</p>
<h1 id="技术"><a href="#技术" class="headerlink" title="技术"></a>技术</h1><h2 id="技术栈"><a href="#技术栈" class="headerlink" title="技术栈"></a>技术栈</h2><p>熟悉什么就用什么。不要因为某项技术听起来很酷 &#x2F; 有趣就选择它，而是因为它易于扩展，便于维护，以达到支持更多用户、更多流量、更多数据和更多代码。</p>
<p>要关注用户需要什么，其他任何花时间的事情都是浪费。初期，产品的用户和代码都不多，所以可扩展性并不是太大的挑战，要做的就是尽可能快地进行迭代。</p>
<h3 id="自研、商业产品还是开源"><a href="#自研、商业产品还是开源" class="headerlink" title="自研、商业产品还是开源"></a>自研、商业产品还是开源</h3><pre><code class="highlight mermaid">flowchart TB

Start[需要满足业务\n需要新技术]
r1&#123;是否是商业上的\n竞争优势或秘密武器&#125;
	Start --&gt; r1
n1[内部实现]
	r1 --&gt; |是|n1
r2&#123;是否有开源项目\n可以实现大部分需求&#125;
	r1 --&gt; |否|r2
r3&#123;是否有开源项目\n可以实现部分需求&#125;
	r2 --&gt; |否|r3
r4&#123;是否有商业产品\n可以实现满足需求&#125;
	r3 --&gt; |否|r4
n2[购买]
	r4 --&gt; |是|n2
n3[使用开源产品]
	r2 --&gt; |是|n3
n4&#123;&#123;贡献补丁或插件&#125;&#125;
	r3 --&gt; |是|n4
	n4 --&gt; n3
n5&#123;&#123;实现并将其开源&#125;&#125;
	r4 --&gt; |否|n5
	n5 --&gt; n3</code></pre>

<h3 id="编程语言"><a href="#编程语言" class="headerlink" title="编程语言"></a>编程语言</h3><p>走起来的公司，可能需要从熟悉的技术栈切换到更适合的编程语言中。</p>
<ul>
<li>适用问题；</li>
<li>编程范式；</li>
<li>性能需求；</li>
</ul>
<h2 id="代码整洁"><a href="#代码整洁" class="headerlink" title="代码整洁"></a>代码整洁</h2><p>编程是让他人了解你想让计算机做什么的艺术。</p>
<pre><code class="highlight mermaid">pie title 开发人员时间分布
	&quot;阅读代码&quot; : 455
    &quot;编写新代码&quot; : 9
    &quot;非编码任务&quot; : 500
    &quot;更新现有代码&quot; : 36</code></pre>

<p>技术债务的真正成本不在于它会导致更多的 bug 和错过最后期限，而是会让人痛苦。优雅的解决方案会让人愉悦，丑陋的拼凑则会让人悲伤不已。而悲伤的人生产效率更低、表现欠佳，最终将会离开公司。</p>
<p>破窗理论在代码上的应用和在建筑上的应用一样。如果代码库到处都是丑陋的修改和乱七八糟的代码，每一个新到的开发人员都在添乱而不是将它理顺。随着难看的代码越来越多，把代码理顺就会变得越来越难，问题只会加速发展。</p>
<p>要尽快地把坏掉的窗子修好，坚持编写整洁的代码，并重写得更整洁。</p>
<h2 id="扩展性"><a href="#扩展性" class="headerlink" title="扩展性"></a>扩展性</h2><p>扩展性有 2 种，第一种是对编码实践过程进行扩展，以应对更多的开发人员、代码和复杂性的需求；第二种是扩展代码的性能，以应对更多的用户、流量和数据的需求。</p>
<p>可扩展性不是一个布尔属性。</p>
<h3 id="编码实践的扩展"><a href="#编码实践的扩展" class="headerlink" title="编码实践的扩展"></a>编码实践的扩展</h3><h4 id="自动化测试"><a href="#自动化测试" class="headerlink" title="自动化测试"></a>自动化测试</h4><p>自动化测试会给你做出修改的自信。</p>
<h5 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h5><ul>
<li>单元测试：对一个单独函数 | 类进行测试；</li>
<li>集成测试：从测试若干个类或模块的交互，到测试整个子系统如何一起工作；</li>
<li>验收测试：单元测试和集成测试侧重从开发人员的角度去验证代码的行为，验收测试则是从客户的角度验证产品的行为，回答“代码是否正确解决问题”的问题。验收测试则是一种端到端的测试，验证技术栈的每一部分是否正确地结合在一起，形成可用的产品；</li>
<li>性能测试：顾名思义；</li>
</ul>
<h5 id="mock"><a href="#mock" class="headerlink" title="mock"></a>mock</h5><p>mock 的存在确认该错误是由单元或组件内部引起的，而非存在于它的依赖项中。</p>
<h5 id="TDD"><a href="#TDD" class="headerlink" title="TDD"></a>TDD</h5><ol>
<li>为新的功能添加测试；</li>
<li>运行所有测试，新的测试应该会失败，但其他所有测试应该通过；</li>
<li>实现这个新功能；</li>
<li>运行测试，现在所有测试均应该通过；</li>
<li>重构代码，直至拥有整洁的设计。</li>
</ol>
<p>此时编写完毕后应立即检查是否失败。</p>
<p>TDD 可以迫使我们关注自己正在做什么，而不是怎么去做。从最终结果考虑问题，帮助我们确认自己正在编写正确的代码，而不是直接跳入编码工作中，迷失在实现的细节里。</p>
<h5 id="时机"><a href="#时机" class="headerlink" title="时机"></a>时机</h5><p>当我们不再有足够的自信可以快速改变代码的时候，就是需要自动化测试的时候了。</p>
<h4 id="代码分离"><a href="#代码分离" class="headerlink" title="代码分离"></a>代码分离</h4><ol>
<li>面向接口开发；</li>
<li>模块化代码部件；</li>
<li>提供 RPC 服务；</li>
</ol>
<h4 id="代码评审"><a href="#代码评审" class="headerlink" title="代码评审"></a>代码评审</h4><p>代码评审可以提前暴漏 BUG，高级工程师可以利用代码评审去指导初级工程师，初级工程师可以通过参与代码评审去学习代码并贡献一些重要的问题。</p>
<ol>
<li>为每部分代码指定评审者，评审者有责任知道这段代码如何工作，并且要保持它运行；</li>
<li>编写评审指南：评审者期望掌握的事项、定义什么代码必须被评审、什么时候代码必须被评审、谁的代码必须被评审、谁负责给出评审意见、好与坏都应该评审；</li>
<li>保持小规模评审。鼓励开发人员进行小修改，增量式地提交；</li>
</ol>
<h4 id="文档"><a href="#文档" class="headerlink" title="文档"></a>文档</h4><h5 id="书面文档"><a href="#书面文档" class="headerlink" title="书面文档"></a>书面文档</h5><p>Readme文件：概括项目的任务、描述项目的作用、展示例子并解释如何开始使用、如何为项目做贡献，以及从哪里获取更多的信息。</p>
<p>教程：带着用户，一步一步经历各种典型的开发流，强调项目的一些惯用开发模式、最佳实践和特性；</p>
<p>参考手册：作用就是回答问题，所以要确保以一种容易搜索和导航的方式去组织信息</p>
<p>项目网站：GitHub <a href="">Pages</a></p>
<h5 id="代码文档"><a href="#代码文档" class="headerlink" title="代码文档"></a>代码文档</h5><p>注释是存在于代码中的书面文档，整洁的代码不需要很多注释。</p>
<p>每个项目都应该包含清晰、惯用的示例代码，而自动化测试也是一种特殊的示例代码。</p>
<h3 id="代码性能的扩展"><a href="#代码性能的扩展" class="headerlink" title="代码性能的扩展"></a>代码性能的扩展</h3><p>我们的时间更应该花在能提高开发团队效率的工具和实践上，而不是让服务器跑得更快。</p>
<p>只有在产品已经有了一定规模，性能可能成为瓶颈之后，这才是个需要考虑的问题。</p>
<p>考虑性能或软件开发的基本过程就是让它工作，让它正确、让它快速。</p>
<p>性能调优的第一个步骤永远都是测量。</p>
<p>优化方式：分治、缓存、懒加载、近似正确、异步、限流、冗余、抖动与随机化、更快的硬件和算法</p>
<h2 id="软件交付"><a href="#软件交付" class="headerlink" title="软件交付"></a>软件交付</h2><p>如果你觉得痛苦，就多去做。</p>
<h3 id="构建"><a href="#构建" class="headerlink" title="构建"></a>构建</h3><h4 id="版本控制"><a href="#版本控制" class="headerlink" title="版本控制"></a>版本控制</h4><p>编写良好的提交信息：<a href="https://www.conventionalcommits.org/en/v1.0.0/#summary">Commit Message Specification</a></p>
<p>经常小步的提交：每一次提交都是完全实现了某一个单一目的、大小合理的单元。完全实现意味着不应该提交会给构建过程带来问题的代码，或者让用户看到未完成功能的代码。大小合理的单元意味着我们应该把工作分解成较小的、增量式的步骤。</p>
<h4 id="持续集成"><a href="#持续集成" class="headerlink" title="持续集成"></a>持续集成</h4><h3 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h3><h4 id="托管"><a href="#托管" class="headerlink" title="托管"></a>托管</h4><p>部署在哪里？</p>
<p>使用云托管而不是搭建自己的数据中心。</p>
<h4 id="配置管理"><a href="#配置管理" class="headerlink" title="配置管理"></a>配置管理</h4><p>部署什么？</p>
<p>docker</p>
<h4 id="自动化部署"><a href="#自动化部署" class="headerlink" title="自动化部署"></a>自动化部署</h4><p>如何部署？</p>
<p>流水线</p>
<h4 id="持续交付"><a href="#持续交付" class="headerlink" title="持续交付"></a>持续交付</h4><p>何时部署？</p>
<p>持续集成让开发人员编写可以频繁合并的代码，相互之间保持同步；持续交付让开发人员编写可以频繁部署的代码，保持和生产环境的同步。</p>
<p>金丝雀发布</p>
<h3 id="监控"><a href="#监控" class="headerlink" title="监控"></a>监控</h3><p>监控和单元测试是一体两面。测试是对少数情况下正确性的强假设进行检验，而监控则是对实际生产负载下正确性的弱假设进行检验。引入监控是为了代码在部署后能持续工作。</p>
<h4 id="日志记录"><a href="#日志记录" class="headerlink" title="日志记录"></a>日志记录</h4><p>格式化和日志聚合。</p>
<h4 id="指标"><a href="#指标" class="headerlink" title="指标"></a>指标</h4><p>可用性：最基本的指标，服务时候可用；</p>
<p>业务：</p>
<p>应用程序、进程、代码和服务器。</p>
<h4 id="报警"><a href="#报警" class="headerlink" title="报警"></a>报警</h4><p>报警的关键点是要能够识别出问题产生的原因。</p>
<h1 id="团队"><a href="#团队" class="headerlink" title="团队"></a>团队</h1><h2 id="创业文化"><a href="#创业文化" class="headerlink" title="创业文化"></a>创业文化</h2><p>文化是行动，而非口号，文化胜过战略。由员工分享并通过他们的举止和行动表达出来的信念、设想和原则，构成了创业文化。创业是与人密不可分的，公司中没有什么东西比文化对人的影响更大。</p>
<h3 id="核心理念"><a href="#核心理念" class="headerlink" title="核心理念"></a>核心理念</h3><p>使命：简洁、清晰、永恒、鼓舞人心；</p>
<p>核心价值：组织中用来做出每一个决定的信条。</p>
<h3 id="组织设计"><a href="#组织设计" class="headerlink" title="组织设计"></a>组织设计</h3><p>分层组织：经理负责协调和决策。设定目标、组织分工、激励和沟通、评估、助人成长。责任清晰带来的沟通困难降低效率。</p>
<p>扁平组织：让员工针对每个任务自我组织，形成最有效率的结构，在任务完成或改变之后再重新组织。员工有自主权和责任心，上述 5 点困难。</p>
<h3 id="招聘与晋升"><a href="#招聘与晋升" class="headerlink" title="招聘与晋升"></a>招聘与晋升</h3><p>招聘到文化契合，价值匹配的人。多样性能使团队更愿意做出新的尝试，更有创造性，更可能去分享知识并帮助公司触及更多的客户，吸引更多的人才，做出更加创新的产品。</p>
<p>通过代码贡献在公司中赢得影响力，而不是依赖对人的管理。</p>
<h3 id="激励"><a href="#激励" class="headerlink" title="激励"></a>激励</h3><p>员工和公司之间是联盟。</p>
<p>最好的奖励通常是更多的自主权（在一些特定的日子让员工可以做他们想做的任何事情）、更多的专业能力（业务能力的提高）和目标（从事一些有较大意义的事情的内在驱动力）。</p>
<h3 id="办公室"><a href="#办公室" class="headerlink" title="办公室"></a>办公室</h3><ol>
<li><p>一个可以和他人一起工作的地方：方便同事之间的交互；</p>
</li>
<li><p>一个可以独处专注工作的地方：心无旁骛地编写代码的场所；</p>
</li>
<li><p>一个可以放下工作的地方：休息应该成为工作文化中的一个固定部分；</p>
</li>
<li><p>一种可以根据个人需要定制办公室的方法：让开发人员购买想要的硬件和软件，并给他们报销；</p>
<p>适合编程的桌子（又平又大，能够调整高度）；</p>
<p>舒适的椅子；</p>
<p>运行速度快的笔记本电脑或台式机（最大的内存、CPU和硬盘）；</p>
<p>一两个大显示器；</p>
<p>好用的鼠标和键盘；</p>
<p>办公室任何区域都有高速的互联网；</p>
<p>很多电源插座；</p>
</li>
</ol>
<h3 id="远程办公"><a href="#远程办公" class="headerlink" title="远程办公"></a>远程办公</h3><p>大多数分布式公司开始时都是本地的公司，因为那时候仍然要尝试确定公司的文化，并寻找产品的市场地位。只有在清楚公司是什么并且把关注点转移到想出如何做之后，我们才应该考虑通过招聘远程员工的方式去扩大团队规模，成为一家分布式的公司。</p>
<h3 id="沟通"><a href="#沟通" class="headerlink" title="沟通"></a>沟通</h3><h4 id="内部沟通"><a href="#内部沟通" class="headerlink" title="内部沟通"></a>内部沟通</h4><p>员工彼此之间进行沟通的方式。让员工了解公司优先考虑的事情、了解公司正从事什么项目去实现这些优先考虑的事情、过去有什么项目成功了或者失败了、了解公司的财务表现。</p>
<p>员工大会或者公司宴会。</p>
<h4 id="外部沟通"><a href="#外部沟通" class="headerlink" title="外部沟通"></a>外部沟通</h4><p>员工与外部世界进行沟通的方式。</p>
<p>第一是如何设计、营销和推广你的产品；第二是如何通过博客、开源软件和展示去宣传自己的公司；第三是如何和客户沟通。</p>
<h3 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h3><p>有些类型的 bug 不常出现或者解决成本非常低，所以在这些 bug 出现的时候再做反应会比试图防止它们出现效率更高。</p>
<p>项目成功重要的是人，而不是挑选的方法论。</p>
<h2 id="求职之路"><a href="#求职之路" class="headerlink" title="求职之路"></a>求职之路</h2><p>找到好工作的第一个步骤就是让自己变得出色。</p>
<h3 id="寻找机会"><a href="#寻找机会" class="headerlink" title="寻找机会"></a>寻找机会</h3><p>利用人脉</p>
<p>聚会小组与会议</p>
<p>黑客马拉松和比赛</p>
<p>演讲、博客和开源</p>
<p>创建个人 IP</p>
<p>关注 VC 和程序员网站</p>
<h3 id="面试"><a href="#面试" class="headerlink" title="面试"></a>面试</h3><p>面对面编程、讲述思考过程、</p>
<p>了解自己：</p>
<p>·谈谈你自己。·你以前做过什么项目？·你为什么要找一份新的工作？·你为什么想来这里工作？·你理想的工作是什么样的？·你想在5年内做什么，10年内呢？·你最大的优势是什么，最大的劣势呢？·你最大的成就是什么？·你曾经解决的最难处理的bug是什么？·我应该再问些别的什么问题吗？</p>
<p>了解公司：</p>
<p>·该角色的期望是什么？·该职位能够取得什么样的成功？·谁是我的经理？·我将从事什么项目？·技术栈是什么？·工作时间怎么样？他们花多少时间在编程上，又花多少时间来开会？·如何构建和发布代码？·公司的使命和价值是什么？·办公室怎么样？·在这里工作，你最喜欢和最不喜欢什么？</p>
<p>《程序员面试金典》和《程序员面试攻略》。</p>
<h3 id="评估机会"><a href="#评估机会" class="headerlink" title="评估机会"></a>评估机会</h3><p>工作机会最重要的就是其背后的人，这件事只能靠直觉。</p>
<p>薪水、股权、福利、谈判</p>
<h2 id="招兵买马"><a href="#招兵买马" class="headerlink" title="招兵买马"></a>招兵买马</h2><p>选择正确的人比选择正确的产品、市场推广策略、技术栈或者编程方法论更加重要。招聘更多的人意味着资金消耗更快，企业经营更复杂，决策更缓慢，要花更多的时间去搜索、面试和培训。最好的创业公司就是用较少的资源做较多的事。</p>
<h3 id="何时招人"><a href="#何时招人" class="headerlink" title="何时招人"></a>何时招人</h3><p>招人的关键问题不是“如果我们招了人可以做什么”，而是“我们不招人的话无法做什么”。</p>
<p>要么写代码，要么找用户。尽量发股权，而不是薪水。</p>
<p>如果对业务至关重要的事在没有新员工的情况下无法完成，不管你们多么有创造性，都是时候开始招聘了。</p>
<h3 id="招什么人"><a href="#招什么人" class="headerlink" title="招什么人"></a>招什么人</h3><p>要评估某人是否聪明，你需要知道他们是如何执行现实中的任务的；</p>
<p>要评估某人是否能够把事情做好，你需要了解他们在过去完成了哪些工作；</p>
<p>要评估某人是否能够很好地适应文化，你需要知道他是否与你们有共同的价值；</p>
<h4 id="合伙人"><a href="#合伙人" class="headerlink" title="合伙人"></a>合伙人</h4><p>两个创始人通常是通往成功的最好途径。你可以平均分配工作和股权，也没有政治操作的空间。三个创始人也没有问题：只是在职责划分上会更困难一些，但总可以通过投票决定，超过 3 个人就够呛。</p>
<p>信任的人远好于完全陌生的人。</p>
<ol>
<li>“敏思笃行”的人，要寻找你认识的那些不管有什么障碍都能克服的人；</li>
<li>要寻找具有互补技能的人，例如，如果你是程序员并善于开发产品，就要寻找能够处理好销售和市场推广，并善于发现客户的创业伙伴；</li>
<li>创业伙伴通常在年龄、经济状况和动机上应该是类似的。如果一个创始人寄希望于赚快钱，而另一个则对改变世界有长期的愿景，这是很难成功的；</li>
<li>能够信任的人。要建立信任，你必须了解合伙人的经历，所以也再次说明了为什么同事、同学和朋友是最合适的创业伙伴；</li>
</ol>
<h4 id="早期员工"><a href="#早期员工" class="headerlink" title="早期员工"></a>早期员工</h4><p>做了错误的产品或使用了错误的技术，可以从头再来，但如果没有招对最开始的 5～10 个员工，却可能将公司置于死地。</p>
<p>多面手，态度胜过才能。</p>
<h4 id="后期员工"><a href="#后期员工" class="headerlink" title="后期员工"></a>后期员工</h4><p>开发人员对手艺的热情是最重要的；招聘到 T 型人才，举办技术访谈、报销课程和会议费用、鼓励撰写博客和开发开源软件、组织黑客马拉松、建立导师制，培养 10x 工程师，而不是招聘 10x。</p>
<p>不要关注是否能招聘到一个超级明星，而是要关注如何形成起一种可持续的招聘策略，如何形成一种组织结构，让每一个人都能高效地在一起工作。</p>
<h4 id="品质"><a href="#品质" class="headerlink" title="品质"></a>品质</h4><ul>
<li><p>聪明并能把事情做好</p>
<p>对于背景，了解的是一个人完成了什么，无论是工作内还是外，而不是参与了什么；关注深入了解的领域，如果解释不清楚，要么非主要贡献者（没做好事），要么没有足够理解（不聪明）；要引导他们进入未知领域。</p>
</li>
<li><p>文化契合</p>
<p>核心价值观契合。</p>
</li>
<li><p>出色的沟通技能</p>
</li>
<li><p>相信直觉</p>
</li>
</ul>
<h3 id="如何寻找"><a href="#如何寻找" class="headerlink" title="如何寻找"></a>如何寻找</h3><p>推荐、公司品牌化、在线搜索、HR</p>
<h3 id="面试-1"><a href="#面试-1" class="headerlink" title="面试"></a>面试</h3><ol>
<li>让面试者教你东西；</li>
<li>面试者能学习到什么东西；</li>
<li>让应聘者展示他们的技术能力</li>
</ol>
<h2 id="学习"><a href="#学习" class="headerlink" title="学习"></a>学习</h2><h3 id="原则"><a href="#原则" class="headerlink" title="原则"></a>原则</h3><ol>
<li>聪明的选择学习内容；</li>
<li>投入时间；</li>
<li>成为习惯；</li>
</ol>
<h3 id="技巧"><a href="#技巧" class="headerlink" title="技巧"></a>技巧</h3><h4 id="途径"><a href="#途径" class="headerlink" title="途径"></a>途径</h4><ol>
<li>读书看报；</li>
<li>读论文；</li>
<li>参加课程；</li>
<li>演讲、小组和会议；</li>
<li>阅读代码</li>
</ol>
<p>目标 + 笔记 + 探讨。</p>
<h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><p>发展 side project、贡献开源、参加竞赛。</p>
<h4 id="分享"><a href="#分享" class="headerlink" title="分享"></a>分享</h4><p>分享所得到的东西要超过你所投入的。</p>
<p>专业性：具有“资深”标记的工程师都是那些使周围的人更加出色的人，要达到这一目的唯一的方法就是教；</p>
<p>质量高</p>
<p>共同维护</p>
<p>个人IP</p>
]]></content>
      <tags>
        <tag>reading notes</tag>
      </tags>
  </entry>
  <entry>
    <title>单体架构的目录设计</title>
    <url>/2023/05/24/best-practice-dir/</url>
    <content><![CDATA[<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">├─api							# 前后端交互</span><br><span class="line">│  ├─advice							# 全局异常处理</span><br><span class="line">│  ├─controller						# 控制器</span><br><span class="line">│  ├─handler						# 自定义返回值处理</span><br><span class="line">│  └─rest							# 请求与响应</span><br><span class="line">│      ├─group							# 分组验证</span><br><span class="line">│      ├─req							# 请求</span><br><span class="line">│      └─vo								# 响应</span><br><span class="line">│          └─convert						# vo 转换器</span><br><span class="line">├─config						# 配置</span><br><span class="line">├─enums							# 枚举</span><br><span class="line">├─exception						# 异常</span><br><span class="line">├─model							# 数据模型</span><br><span class="line">│  └─handler						# 与 db 有关的处理器</span><br><span class="line">├─repository					# 存储接口</span><br><span class="line">│  ├─impl							# 存储实现</span><br><span class="line">│  └─mapper							# 存储 mapper</span><br><span class="line">├─service						# 实现接口</span><br><span class="line">│  ├─helper							# 实现 helper</span><br><span class="line">│  └─impl							# 具体实现</span><br><span class="line">└─util							# 工具类</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>best practice</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringMVC 接口设计</title>
    <url>/2023/05/24/best-practice-mvc/</url>
    <content><![CDATA[<p>请求方式和参数注解可以自由组合。</p>
<h1 id="RequestParam"><a href="#RequestParam" class="headerlink" title="@RequestParam"></a>@RequestParam</h1><p>获取 query 参数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// name 参数需要和 GET 请求中 query 参数的 key 匹配</span></span><br><span class="line"><span class="meta">@GetMapping(&quot;/get&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">queryParam</span><span class="params">(<span class="meta">@RequestParam(&quot;name&quot;)</span> String name)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="PathVariable"><a href="#PathVariable" class="headerlink" title="@PathVariable"></a>@PathVariable</h1><p>获取 path 参数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// name 参数需要和 GET 请求中 path 匹配</span></span><br><span class="line"><span class="meta">@GetMapping(&quot;/path/&#123;name&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">pathParam</span><span class="params">(<span class="meta">@PathVariable(&quot;name&quot;)</span> String name)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="RequestBody"><a href="#RequestBody" class="headerlink" title="@RequestBody"></a>@RequestBody</h1><p>获取 body 参数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 请求体携带的参数和 req 属性匹配</span></span><br><span class="line"><span class="meta">@PostMapping(&quot;/body&quot;)</span></span><br><span class="line"><span class="keyword">public</span> UserReq <span class="title function_">body</span><span class="params">(<span class="meta">@RequestBody</span> UserReq req)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> req;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h1><ol>
<li>不要使用 @RequestBody 来接收 String 类型的参数；</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@PostMapping(&quot;/wrong&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">wrong</span><span class="params">(<span class="meta">@RequestBody</span> String name)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>不要使用 Get 方式来接收 @RequestBody 请求；</li>
</ol>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><p><a href="https://github.com/hanzhang2566/best-practice/blob/main/springboot/src/main/java/boot/api/controller/MvcController.java">here</a></p>
]]></content>
      <tags>
        <tag>best practice</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringMVC 参数校验</title>
    <url>/2023/05/24/best-practice-validation/</url>
    <content><![CDATA[<h1 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h1><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-validation<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h1 id="RequestParam"><a href="#RequestParam" class="headerlink" title="@RequestParam"></a>@RequestParam</h1><p>Controller 类上添加 @Validate 注解。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/param_notnull&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">notnull</span><span class="params">(<span class="meta">@RequestParam(&quot;username&quot;)</span> <span class="meta">@NotEmpty</span> String username)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> username;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="RequestBody"><a href="#RequestBody" class="headerlink" title="@RequestBody"></a>@RequestBody</h1><p>Java Bean 中添加校验，配合方法中的 @Validated 注解。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@PostMapping(&quot;/pojo_notnull&quot;)</span></span><br><span class="line"><span class="keyword">public</span> UserReq <span class="title function_">notnull</span><span class="params">(<span class="meta">@RequestBody</span> <span class="meta">@Validated</span> UserReq req)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> req;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserReq</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用户名&lt;br&gt;</span></span><br><span class="line"><span class="comment">     * username != null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@NotNull</span></span><br><span class="line">    <span class="meta">@NotEmpty</span></span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="分组校验"><a href="#分组校验" class="headerlink" title="分组校验"></a>分组校验</h1><h2 id="group"><a href="#group" class="headerlink" title="group"></a>group</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Usage: &#123;<span class="doctag">@link</span> ValidationController#email(UserReq)&#125; &lt;br/&gt;</span></span><br><span class="line"><span class="comment"> * Date: 2023/5/24 16:14 &lt;br/&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> &lt;a href=&quot;mailto:hanzhang2566@foxmail.com&quot;&gt;hanzhang&lt;/a&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">EmailGroup</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Usage: &#123;<span class="doctag">@link</span> ValidationController#login(UserReq)&#125; &lt;br/&gt;</span></span><br><span class="line"><span class="comment"> * Date: 2023/5/24 16:18 &lt;br/&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> &lt;a href=&quot;mailto:hanzhang2566@foxmail.com&quot;&gt;hanzhang&lt;/a&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">LoginGroup</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="controller"><a href="#controller" class="headerlink" title="controller"></a>controller</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@PostMapping(&quot;/pojo_email&quot;)</span></span><br><span class="line"><span class="keyword">public</span> UserReq <span class="title function_">email</span><span class="params">(<span class="meta">@RequestBody</span> <span class="meta">@Validated(value = &#123;EmailGroup.class&#125;)</span> UserReq req)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> req;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@PostMapping(&quot;/pojo_login&quot;)</span></span><br><span class="line"><span class="keyword">public</span> UserReq <span class="title function_">login</span><span class="params">(<span class="meta">@RequestBody</span> <span class="meta">@Validated(value = &#123;LoginGroup.class&#125;)</span> UserReq req)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> req;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="POJO"><a href="#POJO" class="headerlink" title="POJO"></a>POJO</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserReq</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用户名</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@NotNull(groups = &#123;LoginGroup.class&#125;)</span></span><br><span class="line">    <span class="meta">@NotEmpty(groups = &#123;LoginGroup.class&#125;)</span></span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 密码</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@NotNull(groups = &#123;LoginGroup.class&#125;)</span></span><br><span class="line">    <span class="meta">@NotEmpty(groups = &#123;LoginGroup.class&#125;)</span></span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 邮箱</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Email(groups = &#123;EmailGroup.class&#125;)</span></span><br><span class="line">    <span class="meta">@NotEmpty(groups = &#123;EmailGroup.class&#125;)</span></span><br><span class="line">    <span class="keyword">private</span> String email;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><p><a href="https://github.com/hanzhang2566/best-practice/blob/main/springboot/src/main/java/boot/api/controller/ValidationController.java">here</a></p>
]]></content>
      <tags>
        <tag>best practice</tag>
      </tags>
  </entry>
  <entry>
    <title>REST API 响应设计</title>
    <url>/2023/05/22/best-practice-resp/</url>
    <content><![CDATA[<h1 id="模型设计"><a href="#模型设计" class="headerlink" title="模型设计"></a>模型设计</h1><p>使用统一的 REST 方式定义响应模型。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// code 后端状态码</span></span><br><span class="line"><span class="comment">// message 简短消息</span></span><br><span class="line"><span class="comment">// data 后端数据</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">R</span> <span class="keyword">extends</span> <span class="title class_">HashMap</span>&lt;String, Object&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">R</span><span class="params">(ErrorCode errorCode)</span> &#123;</span><br><span class="line">        put(<span class="string">&quot;code&quot;</span>, errorCode.getCode());</span><br><span class="line">        put(<span class="string">&quot;message&quot;</span>, errorCode.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> R <span class="title function_">ok</span><span class="params">(Object data)</span> &#123;</span><br><span class="line">        <span class="type">R</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">R</span>(OK);</span><br><span class="line">        r.put(<span class="string">&quot;data&quot;</span>, data);</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> R <span class="title function_">error</span><span class="params">(ErrorCode errorCode)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">R</span>(errorCode);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">R</span><span class="params">(String message)</span> &#123;</span><br><span class="line">        put(<span class="string">&quot;code&quot;</span>, HttpStatus.INTERNAL_SERVER_ERROR.value());</span><br><span class="line">        put(<span class="string">&quot;message&quot;</span>, message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> R <span class="title function_">error</span><span class="params">(String message)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">R</span>(message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="包装响应"><a href="#包装响应" class="headerlink" title="包装响应"></a>包装响应</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 隐式将返回值包装成 R 对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyHandlerMethodReturnValueHandler</span> <span class="keyword">implements</span> <span class="title class_">HandlerMethodReturnValueHandler</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> HandlerMethodReturnValueHandler handler;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyHandlerMethodReturnValueHandler</span><span class="params">(HandlerMethodReturnValueHandler handler)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.handler = handler;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回值不是 &#123;<span class="doctag">@link</span> R&#125;，并且使用 Rest 方式返回 true</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> returnType returnType</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> boolean ? 处理 : 不处理</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">supportsReturnType</span><span class="params">(MethodParameter returnType)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> handler.supportsReturnType(returnType) &amp;&amp; !returnType.getParameterType().equals(R.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleReturnValue</span><span class="params">(Object returnValue,</span></span><br><span class="line"><span class="params">                                  MethodParameter returnType,</span></span><br><span class="line"><span class="params">                                  ModelAndViewContainer mavContainer,</span></span><br><span class="line"><span class="params">                                  NativeWebRequest webRequest)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">R</span> <span class="variable">ok</span> <span class="operator">=</span> R.ok(returnValue);</span><br><span class="line">        handler.handleReturnValue(ok, returnType, mavContainer, webRequest);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebMvcConfiguration</span> &#123;</span><br><span class="line">    <span class="comment">// 调整 RequestMappingHandlerAdapter#getReturnValueHandlers</span></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">resetRequestMappingHandlerAdapter</span><span class="params">(RequestMappingHandlerAdapter adapter)</span> &#123;</span><br><span class="line">        List&lt;HandlerMethodReturnValueHandler&gt; originHandlers = adapter.getReturnValueHandlers();</span><br><span class="line">        <span class="keyword">if</span> (CollectionUtils.isEmpty(originHandlers)) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;HandlerMethodReturnValueHandler&gt; newHandlers = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(originHandlers.size());</span><br><span class="line">        <span class="keyword">for</span> (HandlerMethodReturnValueHandler originHandler : originHandlers) &#123;</span><br><span class="line">            <span class="keyword">if</span> (originHandler <span class="keyword">instanceof</span> RequestResponseBodyMethodProcessor) &#123;</span><br><span class="line">                <span class="comment">// 未使用 R 包装返回值，隐式包装</span></span><br><span class="line">                newHandlers.add(<span class="keyword">new</span> <span class="title class_">MyHandlerMethodReturnValueHandler</span>(originHandler));</span><br><span class="line">                <span class="comment">// 使用 R 包装返回值，跳过包装</span></span><br><span class="line">                newHandlers.add(originHandler);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                newHandlers.add(originHandler);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        adapter.setReturnValueHandlers(newHandlers);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="统一异常处理"><a href="#统一异常处理" class="headerlink" title="统一异常处理"></a>统一异常处理</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestControllerAdvice</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExceptionAdvice</span> &#123;</span><br><span class="line">    <span class="comment">// 业务定义的非运行时异常</span></span><br><span class="line">    <span class="meta">@ExceptionHandler(value = AppNonRuntimeException.class)</span></span><br><span class="line">    <span class="keyword">public</span> ResponseEntity&lt;R&gt; <span class="title function_">appException</span><span class="params">(AppNonRuntimeException e)</span> &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        <span class="type">R</span> <span class="variable">error</span> <span class="operator">=</span> R.error(e.getErrorCode());</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ResponseEntity</span>&lt;&gt;(error, HttpStatus.OK);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 业务定义的运行时异常</span></span><br><span class="line">    <span class="meta">@ExceptionHandler(value = AppRuntimeException.class)</span></span><br><span class="line">    <span class="keyword">public</span> ResponseEntity&lt;R&gt; <span class="title function_">appRuntimeException</span><span class="params">(AppRuntimeException e)</span> &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        <span class="type">R</span> <span class="variable">error</span> <span class="operator">=</span> R.error(e.getErrorCode());</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ResponseEntity</span>&lt;&gt;(error, HttpStatus.OK);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 非业务定义的异常</span></span><br><span class="line">    <span class="meta">@ExceptionHandler(value = Exception.class)</span></span><br><span class="line">    <span class="keyword">public</span> ResponseEntity&lt;R&gt; <span class="title function_">exception</span><span class="params">(Exception e)</span> &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        <span class="type">R</span> <span class="variable">error</span> <span class="operator">=</span> R.error(e.getMessage());</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ResponseEntity</span>&lt;&gt;(error, HttpStatus.INTERNAL_SERVER_ERROR);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><p><a href="https://github.com/hanzhang2566/best-practice/tree/main/java-resp">here</a></p>
]]></content>
      <tags>
        <tag>best practice</tag>
      </tags>
  </entry>
  <entry>
    <title>快速排序</title>
    <url>/2023/05/17/quick-sort/</url>
    <content><![CDATA[<h1 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h1><p>通过一趟排序将待排序的数据分割成独立的两部分，其中一部分的所有数据比另一部分的所有数据要小，再按这种方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，使整个数据变成有序序列。</p>
<h1 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h1><p>平均情况：O(nlogn)</p>
<p>最坏情况：O(n^2)</p>
<h1 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h1><p><a href="https://github.com/hanzhang2566/data-structures-and-algorithms-examples/blob/main/go-ds-and-algorithms/sort/quick_sort_test.go">golang</a></p>
<p><a href="https://github.com/hanzhang2566/data-structures-and-algorithms-examples/blob/main/java-ds-and-algorithms/src/test/java/sort/QuickSortTest.java">java</a></p>
]]></content>
      <tags>
        <tag>data structure and algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>快速查找</title>
    <url>/2023/05/17/quick-select/</url>
    <content><![CDATA[<h1 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h1><p>快速查找结合了二分查找和快速排序，在无序的数组中，每次都会去掉一般的元素进行选择。</p>
<h1 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h1><p>平均情况：O(n)</p>
<p>最坏情况：O(nlogn)</p>
<h1 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h1><p><a href="https://github.com/hanzhang2566/data-structures-and-algorithms-examples/blob/main/go-ds-and-algorithms/sort/quick_sort_test.go">golang</a></p>
<p><a href="https://github.com/hanzhang2566/data-structures-and-algorithms-examples/blob/main/java-ds-and-algorithms/src/test/java/sort/QuickSortTest.java">java</a></p>
]]></content>
      <tags>
        <tag>data structure and algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>20230515</title>
    <url>/2023/05/15/essay-20230515/</url>
    <content><![CDATA[<blockquote>
<p>R.I.P @haoel</p>
</blockquote>
<p>来到上海的第 1000 天，是我在这座城市最难过的一天。</p>
<p>如引言所见，”左耳朵耗子“陈皓老师突然去世，<a href="https://www.megaease.com/">MegaEase</a> 变成灰色，池大大也发微博确认，看来是真事，惊讶程度直逼科比。技术大佬不缺钱，当然要把革命的本钱照顾好，没想到是心梗，没认真对待身体实锤。</p>
<p>正经说话的人有，阴阳怪气的也大有人在。我一直不理解，为什么互联网总充斥着各色各样的人和各种各样的奇怪言论。逝者安息和死者为大是基本常识吧！还有人用这件事开玩笑，也不知道居心何在。Peace &amp; Love</p>
<p>16 年我在库尔勒，看了吴军老师的《AA 之 B》系列丛书，特别是《浪潮之巅》，下定决心今后投身互联网，遂回到石河子转入计科系。如果吴军老师是我的灯塔，那陈皓老师就是我的路标。《左耳听风之程序员练级攻略》是对我职业生涯影响最大的系列文章，我知道合格程序员要有自己的技术修养、技术积累到底到何种程度、软件设计究竟如何取舍等等。感谢他吧，我还是会加油的，同时要照顾好自己的身体。</p>
<p>组内今天有同事晋升，也让我非常苦恼。被晋升的同事比我优秀，也更值得被晋升。如果让我来想和他差在哪里？1. 为人和善，和每一位同事都能相处融洽；2. 处理问题能力强。针对与同事相处融洽这点，我好像只欣赏自己看上的人，对一些普通同事，太苛责。还有就是自己爱骂人，虽然不是恶意。针对处理问题能力强这点，倒不是说我不行，而是我能寻迅速解决一些完全是自己掌控下出现的问题，非自己掌握的情况下，就非常便秘。进一步来说，自己或许擅长从流程和软件完整生命周期内，思考和解决问题，而不擅长投入到细碎和具体的业务中。我总是希望用一些方式，预防问题发生，减少问题的发生，而不是修复问题。在我看来，这是“战术上的勤奋”掩盖“战略上的懒惰”。难道公司需要有战斗力的员工，而非我这种从研发效率方面解决问题的人？</p>
<p>刚和父亲打了电话，聊了我的想法。父亲说了一些不痛不痒的话后，转头又给生哥拨过去，他的事说完到我这儿，就要做饭了。匆匆挂了电话，我认真思考起来：商业才能让技术产生价值。我想用自己掌握的技术，为社会创造出一丁点儿的贡献也好。努力地成长为 T 型的人，学习软件工程，实践软件架构，接触 React、Vue 和 Flutter，都是为了让自己能一个人承担起完整商业产品。这都是沉没成本。</p>
<p>可惜，不能说给某人听了。</p>
]]></content>
      <tags>
        <tag>essay</tag>
      </tags>
  </entry>
  <entry>
    <title>递归</title>
    <url>/2023/05/15/recursion/</url>
    <content><![CDATA[<h1 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h1><p>调用自身就是递归。</p>
<h1 id="阅读顺序"><a href="#阅读顺序" class="headerlink" title="阅读顺序"></a>阅读顺序</h1><ol>
<li>找出跳出递归的条件；</li>
<li>查看跳出时，程序如何执行；</li>
<li>查看跳出程序的前一步，程序如何执行；</li>
<li>一直往前推；</li>
</ol>
<h1 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h1><p>递归不会改变算法的时间复杂度。但递归作为算法的核心组件，会影响算法的速度。</p>
<p>递归适用于无法估计计算深度的问题。</p>
<h1 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h1><p><a href="https://github.com/hanzhang2566/data-structures-and-algorithms-examples/blob/main/go-ds-and-algorithms/recursion/recursion_test.go">golang</a></p>
<p><a href="https://github.com/hanzhang2566/data-structures-and-algorithms-examples/blob/main/java-ds-and-algorithms/src/test/java/recursion/RecursionTest.java">java</a></p>
]]></content>
      <tags>
        <tag>data structure and algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>消息队列</title>
    <url>/2023/05/12/redis-stream/</url>
    <content><![CDATA[<p>Redis 中的流是包含零个或任意多个流元素的有序队列，队列中的每个元素都包含一个 id 和任意多个键值对，这些元素会根据 id 的大小在流中有序地进行排列。</p>
<p>流中元素 id</p>
<h1 id="基本命令"><a href="#基本命令" class="headerlink" title="基本命令"></a>基本命令</h1><h2 id="XADD"><a href="#XADD" class="headerlink" title="XADD"></a>XADD</h2><p>将一个带有指定 id 和键值对的元素追加到 stream 中，并返回插入的 id。</p>
<p>id 的限制：</p>
<ol>
<li><p>同一个流中的不同元素是不允许使用相同ID的;</p>
</li>
<li><p>新元素的ID必须比流中所有已有元素的ID都要大;</p>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 将 id = 1100000000000-12345，k1 v1 的键值对添加到 s1 中</span><br><span class="line">-- id 由毫秒事件 millisecond 和顺序编号 sequcen number 组成</span><br><span class="line">XADD s1 1100000000000-12345 k1 v1</span><br><span class="line"></span><br><span class="line">-- 1000000000000-0. 只包含毫秒时间，没有编号。将编号设置为 0</span><br><span class="line">XADD s1 1000000000000 k1 v1</span><br><span class="line"></span><br><span class="line">-- 使用 * 来自动生成元素 id</span><br><span class="line">XADD s1 * k2 v2</span><br><span class="line"></span><br><span class="line">-- 使用先进先出的方式限制 s1 的长度为 2</span><br><span class="line">XADD s1 MAXLEN 2 * k1 v1</span><br><span class="line">XADD s1 MAXLEN 2 * k2 v2</span><br><span class="line">-- 此时 s1 中保存 k2 和 k3</span><br><span class="line">XADD s1 MAXLEN 2 * k3 v3</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(logn)</p>
<h2 id="XTRIM"><a href="#XTRIM" class="headerlink" title="XTRIM"></a>XTRIM</h2><p>将 streamn 修剪为最大长度，也是采用先进先出的方式，返回移除的个数。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 1</span><br><span class="line">XTRIM s1 MAXLEN 1</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(logn + m)</p>
<h2 id="XDEL"><a href="#XDEL" class="headerlink" title="XDEL"></a>XDEL</h2><p>根据 id 删除一个或多个元素，返回删除元素数量。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">XDEL s1 1683948051401-0</span><br><span class="line"></span><br><span class="line">XDEL s1 1683948051401-1 1683948051401-2</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(logn * m)</p>
<h2 id="XLEN"><a href="#XLEN" class="headerlink" title="XLEN"></a>XLEN</h2><p>返回 stream 中元素个数，不合法就返回 0.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">XADD s1 * k1 v1</span><br><span class="line">XADD s1 * k2 v2</span><br><span class="line">XADD s1 * k3 v3</span><br><span class="line"></span><br><span class="line">-- 3. 返回 s1 中元素个数</span><br><span class="line">XLEN s1</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(1)</p>
<h2 id="XRANGE"><a href="#XRANGE" class="headerlink" title="XRANGE"></a>XRANGE</h2><p>提供获取 stream 中元素的各种方式，如果不合法返回 nil。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">XADD s1 * k1 v1</span><br><span class="line">XADD s1 * k2 v2</span><br><span class="line">XADD s1 * k3 v3</span><br><span class="line">XADD s1 * k4 v4</span><br><span class="line">XADD s1 * k5 v5</span><br><span class="line">XADD s1 * k6 v6</span><br><span class="line">XADD s1 * k7 v7</span><br><span class="line"></span><br><span class="line">-- 根据 id 获取指定元素</span><br><span class="line">XRANGE s1 1683948592439-0 1683948592439-0</span><br><span class="line">-- 获取 id 闭区间内的所有元素</span><br><span class="line">XRANGE s1 1683948592251-0 1683948592773-0</span><br><span class="line">-- 获取 stream 中所有元素</span><br><span class="line">XRANGE s1 - +</span><br><span class="line">-- 对返回元素数量做限制，根据 id 升序返回</span><br><span class="line">XRANGE s1 - + COUNT 2</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(logn + m)</p>
<h2 id="XREVRANGE"><a href="#XREVRANGE" class="headerlink" title="XREVRANGE"></a>XREVRANGE</h2><p>同 XRANGE，唯一不同的是 id 的逆序版本。</p>
<h2 id="XREAD"><a href="#XREAD" class="headerlink" title="XREAD"></a>XREAD</h2><p>提供获取 stream 中元素的各种方式，如果不合法返回 nil。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">XADD s1 * k1 v1</span><br><span class="line">XADD s1 * k2 v2</span><br><span class="line">XADD s1 * k3 v3</span><br><span class="line">XADD s1 * k4 v4</span><br><span class="line">XADD s1 * k5 v5</span><br><span class="line">XADD s1 * k6 v6</span><br><span class="line">XADD s1 * k7 v7</span><br><span class="line"></span><br><span class="line">XADD s2 * k1 v1</span><br><span class="line">XADD s2 * k2 v2</span><br><span class="line">XADD s2 * k3 v3</span><br><span class="line">XADD s2 * k4 v4</span><br><span class="line">XADD s2 * k5 v5</span><br><span class="line">XADD s2 * k6 v6</span><br><span class="line">XADD s2 * k7 v7</span><br><span class="line"></span><br><span class="line">-- 返回 s1 中 id &gt; 1683948592043-0 的前 3 个元素</span><br><span class="line">XREAD COUNT 3 STREAMS  s1 1683948592043-0</span><br><span class="line">-- 同时返回 s1 中 id &gt; 1683948592043-0 的前 3 个元素，s2 中 id &gt; 1683949330708-0 的前 3 个元素</span><br><span class="line">XREAD COUNT 3 STREAMS  s1 s2 1683948592043-0 1683949330708-0</span><br><span class="line">-- 阻塞式读取 s2 中 id &gt; 1683949809119-0 的前 2 个元素，时间单位 ms， 0 表示一直等待</span><br><span class="line">XREAD BLOCK 0 COUNT 2 STREAMS s2 1683949809119-0</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(logn + m)</p>
<h2 id="XGROUP"><a href="#XGROUP" class="headerlink" title="XGROUP"></a>XGROUP</h2><p>管理消费者组，增删改。</p>
<p>id 用来限定消费者能够接收到消息范围。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 在 s1 上创建一个名为 all-msg 的消费者组，可以接收 &gt; 0-0 的消费者 时间复杂度：O(1)</span><br><span class="line">XGROUP CREATE s1 all-msg 0-0</span><br><span class="line">-- 修改消费者组的 id 时间复杂度：O(1)</span><br><span class="line">XGROUP SETID s1 all-msg 10086</span><br><span class="line">-- 删除消费者组 时间复杂度：O(n + m)</span><br><span class="line">XGROUP DESTROY s1 all-msg</span><br></pre></td></tr></table></figure>



<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul>
<li>stream 用来支持消息队列；</li>
<li>stream 中包含零个到多个元素的有序队列；</li>
<li>stream 的 id 由“毫秒时间”和“顺序编号“组成；</li>
<li>消费者组允许将一个 stream 从逻辑上划分为多个不同的 stream，让 group 所属的 comsumer 消费；</li>
<li>消息的生命周期：不存在 -&gt; 未递送 -&gt; 待处理 -&gt; 已确认</li>
</ul>
]]></content>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>队列</title>
    <url>/2023/05/12/queue/</url>
    <content><![CDATA[<h1 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h1><ul>
<li>只能在末尾插入数据；</li>
<li>只能在开头读取数据；</li>
<li>只能移除开头的数据；</li>
</ul>
<p>总之，栈是一种先进先出的数据结构。</p>
<h1 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h1><p>队列可以保证请求的顺序，因此可以用来处理异步请求。此外，也能模拟有序事件的处理。</p>
<h1 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h1><p><a href="https://github.com/hanzhang2566/data-structures-and-algorithms-examples/blob/main/go-ds-and-algorithms/queue/queue_test.go">golang</a></p>
<p><a href="https://github.com/hanzhang2566/data-structures-and-algorithms-examples/blob/main/java-ds-and-algorithms/src/test/java/queue/PrinterTest.java">java</a></p>
]]></content>
      <tags>
        <tag>data structure and algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>栈</title>
    <url>/2023/05/12/stack/</url>
    <content><![CDATA[<h1 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h1><ul>
<li>只能在末尾插入数据；</li>
<li>只能在末尾读取数据；</li>
<li>只能移除末尾的数据；</li>
</ul>
<p>总之，栈是一种先进后出的数据结构。</p>
<h1 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h1><p>栈用于递归，递归是其他高级算法的基础。</p>
<h1 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h1><p><a href="https://github.com/hanzhang2566/data-structures-and-algorithms-examples/blob/main/go-ds-and-algorithms/stack/stack_test.go">golang</a></p>
<p><a href="https://github.com/hanzhang2566/data-structures-and-algorithms-examples/blob/main/java-ds-and-algorithms/src/test/java/stack/SyntaxValidatorTest.java">java</a></p>
]]></content>
      <tags>
        <tag>data structure and algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>地理坐标</title>
    <url>/2023/05/10/redis-geo/</url>
    <content><![CDATA[<p>Redis 地理坐标可以存储经纬度格式的地理坐标，并对这些坐标执行距离计算、范围查找等操作。</p>
<h1 id="基本命令"><a href="#基本命令" class="headerlink" title="基本命令"></a>基本命令</h1><h2 id="GEOADD"><a href="#GEOADD" class="headerlink" title="GEOADD"></a>GEOADD</h2><p>将一个或多个地理坐标添加或更新到有序集合中，返回插入元素个数。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 返回 1.添加 qingyuan 到 Guangdong-cities 中</span><br><span class="line">GEOADD Guangdong-cities 113.2099647 23.593675 Qingyuan</span><br><span class="line">-- 返回 4.添加 guangzhou fuoshan dongguan 和 shenzhen 到 Guangdong-cities 中</span><br><span class="line">GEOADD Guangdong-cities 113.2278442 23.1255978 Guangzhou 113.106308 23.0088312 Foshan 113.7943267 22.9761989 Dongguan 114.0538788 22.5551603 Shenzhen</span><br><span class="line"></span><br><span class="line">-- 返回 1.添加 Zhongshan 到 Guangdong-cities 中</span><br><span class="line">GEOADD Guangdong-cities 113 22 Zhongshan</span><br><span class="line">-- 返回 0. 由于 Guangdong-cities 已有 Zhongshan 所以更新 Zhongshan 信息</span><br><span class="line">GEOADD Guangdong-cities 113.4060288 22.5111574 Zhongshan</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(logn * m). n 为集合中已有元素的个数，m 是需要添加地理坐标的个数。</p>
<h2 id="GEOPOS"><a href="#GEOPOS" class="headerlink" title="GEOPOS"></a>GEOPOS</h2><p>获取给定位置的坐标，包含经度和纬度，集合中不存在返回 nil。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 113.40603142976761 22.511156445825442</span><br><span class="line">GEOPOS Guangdong-cities Zhongshan</span><br><span class="line">-- 按顺序返回</span><br><span class="line">-- 114.0538814663887 22.555159205151575  Shenzhen</span><br><span class="line">-- 113.22784155607224 23.125598202060807 Guangzhou</span><br><span class="line">GEOPOS Guangdong-cities Shenzhen Guangzhou</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(logn * m). n 为集合中已有元素的个数，m 是需要查询地理坐标的个数。</p>
<h2 id="GEODIST"><a href="#GEODIST" class="headerlink" title="GEODIST"></a>GEODIST</h2><p>计算两个位置之间的直线距离，单位默认是米，集合中元素不存在返回 nil。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 127364.5547 米</span><br><span class="line">GEODIST Guangdong-cities Zhongshan Guangzhou</span><br><span class="line"></span><br><span class="line">-- 使用指定单位。 M KM MI FT</span><br><span class="line">-- 127364.5547 米</span><br><span class="line">GEODIST Guangdong-cities Zhongshan Guangzhou M</span><br><span class="line">-- 127.3646 千米</span><br><span class="line">GEODIST Guangdong-cities Zhongshan Guangzhou KM</span><br><span class="line">-- 79.1409 英里</span><br><span class="line">GEODIST Guangdong-cities Zhongshan Guangzhou MI</span><br><span class="line">-- 417862.7122 英尺</span><br><span class="line">GEODIST Guangdong-cities Zhongshan Guangzhou FT</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(logn)</p>
<h2 id="GEORADIUS"><a href="#GEORADIUS" class="headerlink" title="GEORADIUS"></a>GEORADIUS</h2><p>返回以经纬度为中心，指定半径内的地理坐标。</p>
<p>默认情况下，返回结果是无序的，ASC 或 DESC 可以使结果有序返回。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 以 113.4060288 22.5111574 为中心，查询半径为 200km 的地理元素</span><br><span class="line">GEORADIUS Guangdong-cities 113.4060288 22.5111574 200 KM</span><br><span class="line"></span><br><span class="line">-- 以 113.4060288 22.5111574 为中心，查询半径为 200mi 的地理元素</span><br><span class="line">GEORADIUS Guangdong-cities 113.4060288 22.5111574 200 MI</span><br><span class="line"></span><br><span class="line">-- 以 113.4060288 22.5111574 为中心，查询半径为 200mi 的地理元素，同时返回距离</span><br><span class="line">GEORADIUS Guangdong-cities 113.4060288 22.5111574 200 KM WITHDIST</span><br><span class="line">-- 以 113.4060288 22.5111574 为中心，查询半径为 200mi 的地理元素，同时返回坐标</span><br><span class="line">GEORADIUS Guangdong-cities 113.4060288 22.5111574 200 KM WITHCOORD</span><br><span class="line">-- 以 113.4060288 22.5111574 为中心，查询半径为 200mi 的地理元素，同时返回 GEOHASH（数字 HASH）</span><br><span class="line">GEORADIUS Guangdong-cities 113.4060288 22.5111574 200 KM WITHHASH</span><br><span class="line">-- 以 113.4060288 22.5111574 为中心，查询半径为 200mi 的地理元素，同时升序返回距离</span><br><span class="line">GEORADIUS Guangdong-cities 113.4060288 22.5111574 200 KM WITHDIST ASC</span><br><span class="line">-- 以 113.4060288 22.5111574 为中心，查询半径为 200mi 的地理元素，返回 2 个的同时升序返回距离</span><br><span class="line">GEORADIUS Guangdong-cities 113.4060288 22.5111574 200 KM WITHDIST ASC COUNT 2</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(n)</p>
<h2 id="GEORADIUSBYMEMBER"><a href="#GEORADIUSBYMEMBER" class="headerlink" title="GEORADIUSBYMEMBER"></a>GEORADIUSBYMEMBER</h2><p>同 GEORADIUS，只是中心为地理坐标中的一个元素。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 以 Guangzhou 为中心，查询半径为 150km 的地理元素，返回 2 个的同时升序返回距离</span><br><span class="line">GEORADIUSBYMEMBER Guangdong-cities Guangzhou 150 KM WITHDIST ASC COUNT 2</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(n)</p>
<h2 id="GEOHASH"><a href="#GEOHASH" class="headerlink" title="GEOHASH"></a>GEOHASH</h2><p>传入一个或多个位置，返回这些位置的字符串 GEOHASH 值。</p>
<p>不存在则返回 nil。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- ws0w0phgp70</span><br><span class="line">GEOHASH Guangdong-cities Qingyuan</span><br><span class="line"></span><br><span class="line">-- ws0w0phgp70 ws0e89curg0</span><br><span class="line">GEOHASH Guangdong-cities Qingyuan Guangzhou</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(n)</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul>
<li>Redis的GEO特性允许用户将经纬度格式的地理位置存储到Redis中，并对这些位置执行距离计算、范围查找等操作；</li>
<li>GEORADIUSBYMEMBER 和 GEORADIUS 命令的作用一样，但前者使用位置，后者使用经纬度；</li>
<li>Geohash 将用户给经度和纬度转换成单个Geohash值；</li>
<li>可以使用有序集合来操作地理坐标；</li>
</ul>
]]></content>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>享元模式</title>
    <url>/2023/05/10/structural-flyweight/</url>
    <content><![CDATA[<h1 id="模式描述"><a href="#模式描述" class="headerlink" title="模式描述"></a>模式描述</h1><p>享元模式通过共享多个对象所共有的相同状态或是不可变对象，用来复用对象、节省内存。</p>
<h1 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h1><p>1. </p>
<h1 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h1><p>1. </p>
<h1 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h1><ol>
<li>仅在程序必须支持大量对象且没有足够的内存容量时使用享元模式;</li>
</ol>
<span id="more"></span>

<table>
<thead>
<tr>
<th align="center">DATE</th>
<th align="center">CHANGELOG</th>
</tr>
</thead>
</table>
<h1 id="UML-类图"><a href="#UML-类图" class="headerlink" title="UML 类图"></a>UML 类图</h1><pre><code class="highlight mermaid">classDiagram</code></pre>

<h1 id="参与者"><a href="#参与者" class="headerlink" title="参与者"></a>参与者</h1><h2 id="Client-类"><a href="#Client-类" class="headerlink" title="Client 类"></a>Client 类</h2><p>客户端。</p>
<h1 id="数据流"><a href="#数据流" class="headerlink" title="数据流"></a>数据流</h1><p>1. </p>
<h1 id="相关模式"><a href="#相关模式" class="headerlink" title="相关模式"></a>相关模式</h1><p>- </p>
<h1 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h1><ul>
<li>不可变对象只能由构造函数的参数进行一次性初始化， 它不能对其他对象公开其设置器或公有成员变量。</li>
</ul>
<h1 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h1><p><a href="https://github.com/hanzhang2566/design-patterns-examples/blob/main/go-patterns/structural/flyweight/flyweight_test.go">golang</a></p>
<p><a href="https://github.com/hanzhang2566/design-patterns-examples/blob/main/java-patterns/src/test/java/structural/flyweight/ClientTest.java">java</a></p>
]]></content>
      <tags>
        <tag>design pattern</tag>
      </tags>
  </entry>
  <entry>
    <title>插入排序</title>
    <url>/2023/05/09/insert-sort/</url>
    <content><![CDATA[<h1 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h1><p>将一个元素插入到已经有序的列表中，从而完成排序。</p>
<h1 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h1><p>对于平均情况（数组里的值随机分布），选择排序、冒泡排序和插入排序性能相近。</p>
<p>如果数组是大致有序的，那么插入排序比较好。如果是大致逆序，则选择排序更快。如果你无法确定数据是什么样，插入排序和选择排序都可以。</p>
<h1 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h1><p>O(n^2)</p>
<h1 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h1><p><a href="https://github.com/hanzhang2566/data-structures-and-algorithms-examples/blob/main/go-ds-and-algorithms/sort/insert_sort_test.go">golang</a></p>
<p><a href="https://github.com/hanzhang2566/data-structures-and-algorithms-examples/blob/main/java-ds-and-algorithms/src/test/java/sort/InsertSortTest.java">java</a></p>
]]></content>
      <tags>
        <tag>data structure and algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>产品第一课</title>
    <url>/2023/05/09/product-first/</url>
    <content><![CDATA[<h1 id="能力"><a href="#能力" class="headerlink" title="能力"></a>能力</h1><h2 id="产品本质"><a href="#产品本质" class="headerlink" title="产品本质"></a>产品本质</h2><p>产品本质（也说产品存在价值）是能够解决”目标用户”的”问题“。</p>
<p>To C 的产品解决自然人的需求，满足“人”欲，而 To B 的产品满足组织需求，自然人的间接需求，满足“组织”欲。</p>
<p>”人“欲：</p>
<p>”组织“欲：节省成本、提升效率、资源整合 </p>
<h2 id="To-C-和-To-B-的差异"><a href="#To-C-和-To-B-的差异" class="headerlink" title="To C 和 To B 的差异"></a>To C 和 To B 的差异</h2><h3 id="目标用户"><a href="#目标用户" class="headerlink" title="目标用户"></a>目标用户</h3><table>
<thead>
<tr>
<th align="center">To C</th>
<th align="center">To B</th>
</tr>
</thead>
<tbody><tr>
<td align="center">感性</td>
<td align="center">理性</td>
</tr>
<tr>
<td align="center">注重体验<br />简单易用，学习成本低</td>
<td align="center">注重效率<br />效率 &gt; 体验</td>
</tr>
<tr>
<td align="center">角色单一</td>
<td align="center">决策者：关注效率和成本<br />管理者：关注管理职责和工作产出<br />员工：关注能否减轻工作负担</td>
</tr>
</tbody></table>
<h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><table>
<thead>
<tr>
<th align="center">To C</th>
<th align="center">To B</th>
</tr>
</thead>
<tbody><tr>
<td align="center">碎片化<br />时间不固定、随机性强</td>
<td align="center">固定时间<br />根据工作流程、职责来使用</td>
</tr>
<tr>
<td align="center">生活使用</td>
<td align="center">工作使用</td>
</tr>
</tbody></table>
<h3 id="产品思维"><a href="#产品思维" class="headerlink" title="产品思维"></a>产品思维</h3><table>
<thead>
<tr>
<th align="center">To C</th>
<th align="center">To B</th>
</tr>
</thead>
<tbody><tr>
<td align="center">追求流量<br />流量优先，提供变现基础</td>
<td align="center">追求效率<br />目的是简化工作，提高效率</td>
</tr>
</tbody></table>
<h3 id="业务功能"><a href="#业务功能" class="headerlink" title="业务功能"></a>业务功能</h3><table>
<thead>
<tr>
<th align="center">To C</th>
<th align="center">To B</th>
</tr>
</thead>
<tbody><tr>
<td align="center">核心功能为主<br />围绕核心功能建立</td>
<td align="center">多功能同等重要<br />工作流程没有主次</td>
</tr>
</tbody></table>
<h3 id="使用复杂度"><a href="#使用复杂度" class="headerlink" title="使用复杂度"></a>使用复杂度</h3><table>
<thead>
<tr>
<th align="center">To C</th>
<th align="center">To B</th>
</tr>
</thead>
<tbody><tr>
<td align="center">业务简单</td>
<td align="center">业务复杂场景多</td>
</tr>
<tr>
<td align="center">简单易用</td>
<td align="center">需要学习</td>
</tr>
<tr>
<td align="center">生命周期短</td>
<td align="center">生命周期长</td>
</tr>
</tbody></table>
<h3 id="切换成本"><a href="#切换成本" class="headerlink" title="切换成本"></a>切换成本</h3><table>
<thead>
<tr>
<th align="center">To C</th>
<th align="center">To B</th>
</tr>
</thead>
<tbody><tr>
<td align="center">同质化、忠诚度低</td>
<td align="center">定制化、上手难度高</td>
</tr>
<tr>
<td align="center">切换成本低</td>
<td align="center">切换成本高</td>
</tr>
</tbody></table>
<h3 id="运营程度"><a href="#运营程度" class="headerlink" title="运营程度"></a>运营程度</h3><table>
<thead>
<tr>
<th align="center">To C</th>
<th align="center">To B</th>
</tr>
</thead>
<tbody><tr>
<td align="center">重运营</td>
<td align="center">重运维</td>
</tr>
<tr>
<td align="center">重视拉新、促活</td>
<td align="center">重视系统稳定、可靠</td>
</tr>
<tr>
<td align="center">用户体验</td>
<td align="center">功能全面</td>
</tr>
</tbody></table>
<h3 id="商业模式"><a href="#商业模式" class="headerlink" title="商业模式"></a>商业模式</h3><table>
<thead>
<tr>
<th align="center">To C</th>
<th align="center">To B</th>
</tr>
</thead>
<tbody><tr>
<td align="center">羊毛出在狗身上</td>
<td align="center">一手交钱一手交货</td>
</tr>
<tr>
<td align="center">内容付费<br />广告付费<br />平台抽佣<br />增值服务</td>
<td align="center">功能付费<br />人数付费<br />需求付费<br />维护付费</td>
</tr>
</tbody></table>
<h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><ol>
<li><p>企业内部协同（财务系统等）</p>
<p>内部专业人员使用；</p>
<p>定制功能多；</p>
<p>部署成本高；</p>
</li>
<li><p>对外标准产品（钉钉等）</p>
<p>行业使用广泛；</p>
<p>定制功能少；</p>
<p>类似于 C 端；</p>
</li>
<li><p>中后台产品（阿里云等）</p>
<p>没有真正意义的使用者；</p>
<p>业务 + 技术 + 现状 + 规划</p>
</li>
</ol>
<h1 id="依据"><a href="#依据" class="headerlink" title="依据"></a>依据</h1><h1 id="设计"><a href="#设计" class="headerlink" title="设计"></a>设计</h1><h1 id="提升"><a href="#提升" class="headerlink" title="提升"></a>提升</h1>]]></content>
      <tags>
        <tag>product</tag>
      </tags>
  </entry>
  <entry>
    <title>位图</title>
    <url>/2023/05/09/redis-bit/</url>
    <content><![CDATA[<p>位图是由多个二进制位组成的数组，数组中的每个二进制位都有与之对应的偏移量（也称索引），用户通过这些偏移量可以对位图中指定的一个或多个二进制位进行操作。</p>
<span id="more"></span>

<h1 id="基本命令"><a href="#基本命令" class="headerlink" title="基本命令"></a>基本命令</h1><h2 id="SETBIT"><a href="#SETBIT" class="headerlink" title="SETBIT"></a>SETBIT</h2><p>根据偏移值设置对应下标，返回修改前的值。</p>
<p>位图按照字节进行扩展，将未设置的二进制位设置为 0。</p>
<p>偏移量只能为正数，值只能是 [0 | 1]</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 设置 bitmap 中下标为 0、2、4、6 的值设置为 1</span><br><span class="line">-- 1010101</span><br><span class="line">SETBIT bitmap 0 1</span><br><span class="line">SETBIT bitmap 2 1</span><br><span class="line">SETBIT bitmap 4 1</span><br><span class="line">SETBIT bitmap 6 1</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(1)</p>
<h2 id="GETBIT"><a href="#GETBIT" class="headerlink" title="GETBIT"></a>GETBIT</h2><p>获取偏移的值，偏移在范围外返回 0.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 1</span><br><span class="line">GETBIT bitmap 6</span><br><span class="line">-- 0</span><br><span class="line">GETBIT bitmap 5</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(1)</p>
<h2 id="BITCOUNT"><a href="#BITCOUNT" class="headerlink" title="BITCOUNT"></a>BITCOUNT</h2><p>统计位图值为 1 的二进制数量。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 4</span><br><span class="line">BITCOUNT bitmap</span><br><span class="line">-- 返回第一字节-第二字节中值为 1 的元素个数</span><br><span class="line">BITCOUNT bitmap 0 1</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(n)</p>
<h2 id="BITPOS"><a href="#BITPOS" class="headerlink" title="BITPOS"></a>BITPOS</h2><p>查找位图中第一个指定值的元素下标</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SETBIT bitmap 0 0</span><br><span class="line">SETBIT bitmap 2 1</span><br><span class="line">SETBIT bitmap 4 1</span><br><span class="line">SETBIT bitmap 6 1</span><br><span class="line">BITCOUNT bitmap 0 0</span><br><span class="line">-- 0</span><br><span class="line">BITPOS bitmap 0</span><br><span class="line">-- 2</span><br><span class="line">BITPOS bitmap 1</span><br><span class="line">-- 返回第二字节中值为 1 的元素个数</span><br><span class="line">BITCOUNT bitmap 1 1</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(n)</p>
<h2 id="BITOP"><a href="#BITOP" class="headerlink" title="BITOP"></a>BITOP</h2><p>对位图进行与、或、非和异或的计算。</p>
<p>对于长度不同的位图，会用 0 补全。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- bm1 01</span><br><span class="line">SETBIT bm1 0 0</span><br><span class="line">SETBIT bm1 1 1</span><br><span class="line">-- bm2 10</span><br><span class="line">SETBIT bm2 0 1</span><br><span class="line">SETBIT bm2 1 0</span><br><span class="line"></span><br><span class="line">-- 00</span><br><span class="line">BITOP AND and bm1 bm2</span><br><span class="line">-- 0</span><br><span class="line">BITCOUNT and</span><br><span class="line">-- 00</span><br><span class="line">BITOP OR or bm1 bm2</span><br><span class="line">-- 2</span><br><span class="line">BITCOUNT or</span><br><span class="line">-- 10</span><br><span class="line">BITOP NOT not bm1</span><br><span class="line">-- 7。这里由于是对字节进行操作的</span><br><span class="line">BITCOUNT not</span><br><span class="line">-- 11</span><br><span class="line">BITOP XOR xor bm1 bm2</span><br><span class="line">-- 2</span><br><span class="line">BITCOUNT xor</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(n)</p>
<h2 id="BITFIELD"><a href="#BITFIELD" class="headerlink" title="BITFIELD"></a>BITFIELD</h2><p>用来对位图中的任意区域存储整数值，并进行计算。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 设置 uint8-bitmap 位图的第一个元素为 u8 类型值为 123</span><br><span class="line">BITFIELD uint8-bitmap SET u8 0 123</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(n)</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul>
<li>Redis 的位图是由多个二进制位组成的数组，通过偏移量对位图中一位或多位进行操作；</li>
<li>BITCOUNT 命令接受的是字节索引范围，而不是二进制位索引范围；</li>
<li>因为位图是使用字符串实现的，所以字符串命令也可以用于处理位图命令。但必须先转换；</li>
</ul>
]]></content>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>基数计数</title>
    <url>/2023/05/09/redis-hyperloglog/</url>
    <content><![CDATA[<p>HyperLogLog 用于估计候选集概率的数据结构。它使得用较小的空间获得近似的准确度。无论集合包含的多少个元素，HyperLogLog 总是使用非常少的内存。</p>
<span id="more"></span>

<h1 id="基本命令"><a href="#基本命令" class="headerlink" title="基本命令"></a>基本命令</h1><h2 id="PFADD"><a href="#PFADD" class="headerlink" title="PFADD"></a>PFADD</h2><p>对给定的元素进行计数，如果计数成功，返回 true；否则，返回 false。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- true</span><br><span class="line">PFADD alphabets &quot;a&quot; &quot;b&quot; &quot;c&quot; &quot;d&quot; &quot;e&quot;</span><br><span class="line">-- false</span><br><span class="line">PFADD alphabets &quot;a&quot;</span><br><span class="line">-- true</span><br><span class="line">PFADD alphabets &quot;f&quot;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(n)</p>
<h2 id="PFCOUNT"><a href="#PFCOUNT" class="headerlink" title="PFCOUNT"></a>PFCOUNT</h2><p>返回 hyper 中元素的近似个数。</p>
<p>hyper 不存在则返回 0.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 6</span><br><span class="line">PFCOUNT alphabets</span><br><span class="line">-- 0</span><br><span class="line">PFCOUNT alphabets1</span><br><span class="line"></span><br><span class="line">PFADD alphabets1 &quot;a&quot; &quot;b&quot; &quot;c&quot;</span><br><span class="line">PFADD alphabets2  &quot;c&quot; &quot;d&quot; &quot;e&quot; &quot;f&quot;</span><br><span class="line">-- 6 返回 alphabets1 和 alphabets2 并集的个数</span><br><span class="line">PFCOUNT alphabets1 alphabets2</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(n)</p>
<h2 id="PFMERGE"><a href="#PFMERGE" class="headerlink" title="PFMERGE"></a>PFMERGE</h2><p>将指定 hypers 计算出并集，并保存到 target hyper 中。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PFADD alphabets1 &quot;a&quot; &quot;b&quot; &quot;c&quot;</span><br><span class="line">PFADD alphabets2  &quot;c&quot; &quot;d&quot; &quot;e&quot; &quot;f&quot;</span><br><span class="line"></span><br><span class="line">-- 将 alphabets1 和 alphabets2 求并集，保存到 alphabets::merge 中</span><br><span class="line">PFMERGE alphabets::merge alphabets1 alphabets2</span><br><span class="line">- 6</span><br><span class="line">PFCOUNT alphabets::merge</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(n)</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul>
<li>HyperLogLog 是一个基于基数的近似计算；</li>
<li>HyperLogLog 无论保存多少个元素，只使用固定内存；</li>
<li>PFMERGE 代替 PFCOUNT，因为 PFCOUNT 内部调用 PFMERGE 命令；</li>
<li>HyperLogLog 用于计数和去重；</li>
</ul>
]]></content>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>桥接模式</title>
    <url>/2023/05/09/structural-bridge/</url>
    <content><![CDATA[<h1 id="模式描述"><a href="#模式描述" class="headerlink" title="模式描述"></a>模式描述</h1><p>将抽象部分与实现部分分离，使之可以独立变化。换句话说，当一个类存在两个（或多个）独立变化的维度，通过组合的方式让这两个（或多个）维度可以独立进行扩展。</p>
<h1 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h1><ol>
<li>分离抽象和实现；</li>
<li>提高扩展性；</li>
<li>实现细节对 Client 透明</li>
</ol>
<h1 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h1><h1 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h1><ol>
<li>不希望抽象和实现有绑定关系；</li>
<li>类的抽象以及实现可以通过生成子类的方式进行扩充；</li>
</ol>
<span id="more"></span>

<table>
<thead>
<tr>
<th align="center">DATE</th>
<th align="center">CHANGELOG</th>
</tr>
</thead>
<tbody><tr>
<td align="center">2023年5月9日</td>
<td align="center">初始化</td>
</tr>
</tbody></table>
<h1 id="UML-类图"><a href="#UML-类图" class="headerlink" title="UML 类图"></a>UML 类图</h1><pre><code class="highlight mermaid">classDiagram

class Abstraction &#123;
	&lt;&lt;interface&gt;&gt;
	operation()
&#125;

class RefinedAbstraction &#123;
	operation()
&#125;
Abstraction &lt;|.. RefinedAbstraction

class Implementor &#123;
	&lt;&lt;interface&gt;&gt;
	operationImp()
&#125;

class ConcreteImplementorA &#123;
	operationImp()
&#125;

class ConcreteImplementorA &#123;
	operationImp()
&#125;
Implementor &lt;|.. ConcreteImplementorA
Implementor &lt;|.. ConcreteImplementorB

Abstraction o.. Implementor
Abstraction &lt;-- Client</code></pre>



<h1 id="参与者"><a href="#参与者" class="headerlink" title="参与者"></a>参与者</h1><h2 id="Abstraction"><a href="#Abstraction" class="headerlink" title="Abstraction"></a>Abstraction</h2><ul>
<li>定义抽象类的接口；</li>
<li>维护一个指向 Implementor 的指针；</li>
</ul>
<h2 id="RefinedAbstraction"><a href="#RefinedAbstraction" class="headerlink" title="RefinedAbstraction"></a>RefinedAbstraction</h2><ul>
<li>扩展 Abstraction 的接口；</li>
</ul>
<h2 id="Implementor"><a href="#Implementor" class="headerlink" title="Implementor"></a>Implementor</h2><ul>
<li>定义实现类的接口。该接口不一定与 Abstraction 完全一致；</li>
<li>Implementor 接口仅提供基本操作，而 Abstraction 则定义了基于这些基本操作较高层次的操作；</li>
</ul>
<h2 id="ConcreteImplementor"><a href="#ConcreteImplementor" class="headerlink" title="ConcreteImplementor"></a>ConcreteImplementor</h2><ul>
<li>Implementor 的实现；</li>
</ul>
<h2 id="Client-类"><a href="#Client-类" class="headerlink" title="Client 类"></a>Client 类</h2><p>客户端。</p>
<h1 id="数据流"><a href="#数据流" class="headerlink" title="数据流"></a>数据流</h1><ol>
<li>Client 通过调用 Abstraction 中的接口来操作；</li>
<li>Abstraction 的实现委托给 ConcreteImplementor 来进行；</li>
</ol>
<h1 id="相关模式"><a href="#相关模式" class="headerlink" title="相关模式"></a>相关模式</h1><ul>
<li>抽象工厂：用来创建和配置一个特定的桥接模式；</li>
<li>适配器模式：通常在系统设计完成后使用，桥接模式则在系统开始时就被使用。</li>
</ul>
<h1 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h1><ul>
<li>”抽象“并非是抽象类或接口，而是一组行为，真正的业务实现委托给”实现“来完成；</li>
</ul>
<h1 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h1><p><a href="https://github.com/hanzhang2566/design-patterns-examples/blob/main/go-patterns/structural/bridge/bridge_test.go">golang</a></p>
<p><a href="https://github.com/hanzhang2566/design-patterns-examples/blob/main/java-patterns/src/test/java/structural/bridge/ClientTest.java">java</a></p>
]]></content>
      <tags>
        <tag>design pattern</tag>
      </tags>
  </entry>
  <entry>
    <title>有序集合</title>
    <url>/2023/05/08/redis-zset/</url>
    <content><![CDATA[<p>有序集合同时具有“有序”和“集合” 2 种性质。</p>
<span id="more"></span>

<h1 id="基本命令"><a href="#基本命令" class="headerlink" title="基本命令"></a>基本命令</h1><h2 id="ZADD"><a href="#ZADD" class="headerlink" title="ZADD"></a>ZADD</h2><p>添加一个或多个元素到有序集合，返回添加元素的数量。</p>
<p>NX 参数：只会操作不存在的元素；</p>
<p>XX 参数：只会操作存在的元素；</p>
<p>CH 参数：返回更新元素的个数；</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 4</span><br><span class="line">ZADD salary 3500 &quot;peter&quot; 4000 &quot;jack&quot; 2000 &quot;tom&quot; 5500 &quot;mary&quot;</span><br><span class="line"></span><br><span class="line">-- 更新 member 的 score，没有成员添加，返回 0</span><br><span class="line">ZADD salary 3501 &quot;peter&quot;</span><br><span class="line"></span><br><span class="line">-- 返回 1，增加 hanzhang，并且 peter 不会改变</span><br><span class="line">ZADD salary NX 6000 &quot;hanzhang&quot; 3500 &quot;peter&quot;</span><br><span class="line">-- 返回 0，将 hanzhang 更新为 6000，peter 更新为 3500</span><br><span class="line">ZADD salary XX 6000 &quot;hanzhang&quot; 3500 &quot;peter&quot;</span><br><span class="line">-- 返回 2，将 hanzhang 更新为 6001，peter 更新为 3501</span><br><span class="line">ZADD salary CH XX 6001 &quot;hanzhang&quot; 3501 &quot;peter&quot;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(m * logn)。m 为 member 的数量，n 为成员数量。</p>
<h2 id="ZREM"><a href="#ZREM" class="headerlink" title="ZREM"></a>ZREM</h2><p>从集合中删除一个或多个元素，返回移除元素的数量。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 返回 1</span><br><span class="line">ZREM salary &quot;peter&quot;</span><br><span class="line">-- 返回 2 </span><br><span class="line">ZREM salary &quot;hanzhang&quot; &quot;tom&quot;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(m * logn)。m 为 member 的数量，n 为成员数量。</p>
<h2 id="ZSCORE"><a href="#ZSCORE" class="headerlink" title="ZSCORE"></a>ZSCORE</h2><p>获取给定 member 的 score。</p>
<p>不存在的有序集合或 member 返回 nil。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 4000</span><br><span class="line">ZSCORE salary &quot;jack&quot;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(1)</p>
<h2 id="ZINCRBY"><a href="#ZINCRBY" class="headerlink" title="ZINCRBY"></a>ZINCRBY</h2><p>将给定 member 的 score 进行增加或减少，返回更新后的 score。</p>
<p>不存在的有序集合会进行创建。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 1000</span><br><span class="line">ZINCRBY salary 1000 &quot;jack&quot;</span><br><span class="line"></span><br><span class="line">-- 2000</span><br><span class="line">ZINCRBY salary 1000 &quot;jack&quot;</span><br><span class="line"></span><br><span class="line">-- 1000</span><br><span class="line">ZINCRBY salary -1000 &quot;jack&quot;</span><br><span class="line"></span><br><span class="line">-- 0</span><br><span class="line">ZINCRBY salary -1000 &quot;jack&quot;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(n)</p>
<h2 id="ZCARD"><a href="#ZCARD" class="headerlink" title="ZCARD"></a>ZCARD</h2><p>返回有序集合中元素个数，有序集合不存在则返回 0.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 返回元素个数</span><br><span class="line">ZCARD salary</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(1)</p>
<h2 id="ZRANK"><a href="#ZRANK" class="headerlink" title="ZRANK"></a>ZRANK</h2><p>返回元素在有序集合的升序下标，集合或元素不存在，返回 nil。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 1</span><br><span class="line">ZRANK salary &quot;peter&quot;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(logn)</p>
<h2 id="ZREVRANK"><a href="#ZREVRANK" class="headerlink" title="ZREVRANK"></a>ZREVRANK</h2><p>返回元素在有序集合的降序下标，集合或元素不存在，返回 nil。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 2</span><br><span class="line">ZREVRANK salary &quot;peter&quot;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(logn)</p>
<h2 id="ZRANGE"><a href="#ZRANGE" class="headerlink" title="ZRANGE"></a>ZRANGE</h2><p>获取升序中指定闭区间内的所有 member。</p>
<p>可以接受负索引，负索引从 -1 开始。</p>
<p>不存在时，返回空。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- tom peter jack mary</span><br><span class="line"></span><br><span class="line">-- tom peter jack</span><br><span class="line">ZRANGE salary 0 2</span><br><span class="line">-- jack mary</span><br><span class="line">ZRANGE salary  -2 -1</span><br><span class="line">-- tom peter jack</span><br><span class="line">ZRANGE salary  0 -2</span><br><span class="line">-- 以升序获取全部</span><br><span class="line">ZRANGE salary  0 -1</span><br><span class="line">-- 返回 member 的同时，返回 score</span><br><span class="line">ZRANGE salary  0 -1 WITHSCORES</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(logn + m)</p>
<h2 id="ZREVRANGE"><a href="#ZREVRANGE" class="headerlink" title="ZREVRANGE"></a>ZREVRANGE</h2><p>获取降序中指定闭区间内的所有 member。</p>
<p>可以接受负索引，负索引从 -1 开始。</p>
<p>不存在时，返回空。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- mary jack peter</span><br><span class="line">ZREVRANGE salary 0 2</span><br><span class="line">-- peter tom</span><br><span class="line">ZREVRANGE salary  -2 -1</span><br><span class="line">-- mary jack peter</span><br><span class="line">ZREVRANGE salary  0 -2</span><br><span class="line">-- 以降序获取全部</span><br><span class="line">ZREVRANGE salary  0 -1</span><br><span class="line">-- 返回 member 的同时，返回 score</span><br><span class="line">ZREVRANGE salary  0 -1 WITHSCORES</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(logn + m)</p>
<h2 id="ZCOUNT"><a href="#ZCOUNT" class="headerlink" title="ZCOUNT"></a>ZCOUNT</h2><p>返回指定闭区间内成员数量。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ZADD salary 3500 &quot;peter&quot; 4000 &quot;jack&quot; 2000 &quot;tom&quot; 5500 &quot;mary&quot;</span><br><span class="line"></span><br><span class="line">-- 3，[2000, 4000]</span><br><span class="line">ZCOUNT salary 2000 4000</span><br><span class="line">-- 2, (2000, 4000]</span><br><span class="line">ZCOUNT salary （2000 4000</span><br><span class="line">-- 2, [2000, 4000)</span><br><span class="line">ZCOUNT salary 2000 (4000</span><br><span class="line">-- 1, (2000, 4000)</span><br><span class="line">ZCOUNT salary (2000 (4000</span><br><span class="line">-- 3, [3500, +∞)</span><br><span class="line">ZCOUNT salary 3500 +inf</span><br><span class="line">-- 3, （-∞, 3500]</span><br><span class="line">ZCOUNT salary -inf 3500</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(logn)</p>
<h2 id="ZREMRANGEBYRANK"><a href="#ZREMRANGEBYRANK" class="headerlink" title="ZREMRANGEBYRANK"></a>ZREMRANGEBYRANK</h2><p>从升序排列中移除闭区间排名的元素，返回被移除元素的数量。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 2</span><br><span class="line">ZREMRANGEBYRANK salary 1 2</span><br><span class="line">-- 2 </span><br><span class="line">ZREMRANGEBYRANK salary -2 -1</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(logn + m)</p>
<h2 id="ZREMRANGEBYRANK-1"><a href="#ZREMRANGEBYRANK-1" class="headerlink" title="ZREMRANGEBYRANK"></a>ZREMRANGEBYRANK</h2><p>从升序排列中移除间分值的元素，返回被移除元素的数量。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 2</span><br><span class="line">ZREMRANGEBYSCORE salary 4000 5500</span><br><span class="line"></span><br><span class="line">-- 1</span><br><span class="line">ZREMRANGEBYSCORE salary （4000 5500</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(logn + m)</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul>
<li>有序集合同时拥有“有序”和“集合” 2 种性质；</li>
<li>一般情况下，有序集合的顺序由分值 score 决定，而分值相同的成员排序由 member 的字典序决定；</li>
<li>member 的分数除了可以是数字之外，还能为 -inf 和 +inf；</li>
</ul>
]]></content>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>单例模式</title>
    <url>/2023/05/08/creational-singleton/</url>
    <content><![CDATA[<h1 id="模式描述"><a href="#模式描述" class="headerlink" title="模式描述"></a>模式描述</h1><p>保证一个类仅有一个实例，并提供一个访问它的全局访问点。</p>
<h1 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h1><ol>
<li>对唯一实例的受控访问；</li>
<li>缩小名字空间；</li>
<li>允许对操作和表示的精华；</li>
<li>比类操作更灵活；</li>
</ol>
<h1 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h1><h1 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h1><ol>
<li>处理资源访问冲突；</li>
<li>表示全局唯一类；</li>
</ol>
<span id="more"></span>

<table>
<thead>
<tr>
<th align="center">DATE</th>
<th align="center">CHANGELOG</th>
</tr>
</thead>
<tbody><tr>
<td align="center">2023年5月8日</td>
<td align="center">初始化</td>
</tr>
</tbody></table>
<h1 id="UML-类图"><a href="#UML-类图" class="headerlink" title="UML 类图"></a>UML 类图</h1><pre><code class="highlight mermaid">classDiagram
class Singleton &#123;
	getInstance() Singleton
&#125;

Singleton &lt;-- Client</code></pre>

<h1 id="参与者"><a href="#参与者" class="headerlink" title="参与者"></a>参与者</h1><h2 id="Singleton"><a href="#Singleton" class="headerlink" title="Singleton"></a>Singleton</h2><ul>
<li>定义一个 getInstance 操作；</li>
</ul>
<h2 id="Client-类"><a href="#Client-类" class="headerlink" title="Client 类"></a>Client 类</h2><p>客户端。</p>
<h1 id="数据流"><a href="#数据流" class="headerlink" title="数据流"></a>数据流</h1><ol>
<li>Client 只能通过 getInstance 操作获取实例对象。</li>
</ol>
<h1 id="相关模式"><a href="#相关模式" class="headerlink" title="相关模式"></a>相关模式</h1><ul>
<li>很多模式可以用单例模式来实现；</li>
</ul>
<h1 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h1><ul>
<li>构造函数需要是 private 访问权限的，这样才能避免外部通过 new 创建实例；</li>
<li>考虑对象创建时的线程安全问题；</li>
<li>考虑是否支持延迟加载；</li>
<li>考虑 getInstance() 性能是否高（是否加锁）。</li>
</ul>
<h1 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h1><p><a href="https://github.com/hanzhang2566/design-patterns-examples/blob/main/go-patterns/creational/singleton/singleton_test.go">golang</a></p>
<p><a href="https://github.com/hanzhang2566/design-patterns-examples/blob/main/java-patterns/src/test/java/creational/singleton/ClientTest.java">java</a></p>
]]></content>
      <tags>
        <tag>design pattern</tag>
      </tags>
  </entry>
  <entry>
    <title>迭代器模式</title>
    <url>/2023/05/07/behavioral-iterator/</url>
    <content><![CDATA[<h1 id="模式描述"><a href="#模式描述" class="headerlink" title="模式描述"></a>模式描述</h1><p>提供一种方法顺序访问容器中的各个元素，又不需要暴漏对象的内部表示。</p>
<h1 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h1><ol>
<li>支持以不同方式遍历容器；</li>
<li>对一个容器可以创建多个迭代器，互不影响；</li>
</ol>
<h1 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h1><ol>
<li>遍历的同时，不能对容器进行 add 或者 remove；</li>
</ol>
<h1 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h1><ol>
<li>遍历</li>
</ol>
<span id="more"></span>

<table>
<thead>
<tr>
<th align="center">DATE</th>
<th align="center">CHANGELOG</th>
</tr>
</thead>
</table>
<h1 id="UML-类图"><a href="#UML-类图" class="headerlink" title="UML 类图"></a>UML 类图</h1><pre><code class="highlight mermaid">classDiagram

class Iterator &#123;
	hasNext() bool
	next() Object
&#125;

class ConcreteIterator &#123;
	hasNext() bool
	next() Object
&#125;
Iterator &lt;|.. ConcreteIterator

class Aggregate &#123;
	iterator() Iterator
&#125;

class ConcreteAggregate &#123;
	iterator() Iterator
&#125;
Aggregate &lt;|.. ConcreteAggregate

ConcreteAggregate o.. ConcreteIterator
ConcreteIterator &lt;-- ConcreteAggregate
Aggregate &lt;-- Client</code></pre>

<h1 id="参与者"><a href="#参与者" class="headerlink" title="参与者"></a>参与者</h1><h2 id="Iterator"><a href="#Iterator" class="headerlink" title="Iterator"></a>Iterator</h2><ul>
<li>定义迭代器访问和遍历的接口；</li>
</ul>
<h2 id="ConcreteIterator"><a href="#ConcreteIterator" class="headerlink" title="ConcreteIterator"></a>ConcreteIterator</h2><ul>
<li>Iterator 的实现；</li>
</ul>
<h2 id="Aggregate"><a href="#Aggregate" class="headerlink" title="Aggregate"></a>Aggregate</h2><ul>
<li>聚合相应迭代器的接口；</li>
</ul>
<h2 id="ConcreteAggregate"><a href="#ConcreteAggregate" class="headerlink" title="ConcreteAggregate"></a>ConcreteAggregate</h2><ul>
<li>Aggregate 的实现；</li>
<li>返回具体的 ConcreteAggregate 的实例；</li>
</ul>
<h2 id="Client-类"><a href="#Client-类" class="headerlink" title="Client 类"></a>Client 类</h2><p>客户端。</p>
<h1 id="数据流"><a href="#数据流" class="headerlink" title="数据流"></a>数据流</h1><ol>
<li>ConcreteIterator 跟踪容器对象，并能够算出遍历的后继对象；</li>
</ol>
<h1 id="相关模式"><a href="#相关模式" class="headerlink" title="相关模式"></a>相关模式</h1><ul>
<li>组合模式：迭代器常被应用到组合的递归结构上；</li>
<li>工厂方法：多迭代器使用工厂方法来实例化；</li>
<li>备忘录模式：迭代器可使用备忘录来捕获一个迭代的状态。</li>
</ul>
<h1 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h1><ul>
<li>在进行迭代器遍历时，如果容器进行了 add 或者 remove，则可以使用报错的方式；</li>
</ul>
<h1 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h1><p><a href="https://github.com/hanzhang2566/design-patterns-examples/blob/main/go-patterns/behavioral/iterator/iterator_test.go">golang</a></p>
<p><a href="https://github.com/hanzhang2566/design-patterns-examples/blob/main/java-patterns/src/test/java/behavioral/iterator/ClientTest.java">java</a></p>
]]></content>
      <tags>
        <tag>design pattern</tag>
      </tags>
  </entry>
  <entry>
    <title>组合模式</title>
    <url>/2023/05/07/structural-composite/</url>
    <content><![CDATA[<h1 id="模式描述"><a href="#模式描述" class="headerlink" title="模式描述"></a>模式描述</h1><p>将对象组合成树形结构，以表示成”部分-整体“的层次结构。</p>
<h1 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h1><ol>
<li>简化 Client 代码；</li>
<li>使得设计更一般化；</li>
</ol>
<h1 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h1><ol>
<li>使用比较局限；</li>
</ol>
<h1 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h1><ol>
<li>表示”部分-整体“的层次结构；</li>
<li>统一使用组合结构中的所有对象</li>
</ol>
<span id="more"></span>

<table>
<thead>
<tr>
<th align="center">DATE</th>
<th align="center">CHANGELOG</th>
</tr>
</thead>
<tbody><tr>
<td align="center">2023年5月7日</td>
<td align="center">初始化</td>
</tr>
</tbody></table>
<h1 id="UML-类图"><a href="#UML-类图" class="headerlink" title="UML 类图"></a>UML 类图</h1><pre><code class="highlight mermaid">classDiagram
class Component &#123;
	&lt;&lt;interface&gt;&gt;
	operation()
	add(Component c)
	remove(Component c)
	getChild(int)
&#125;

class Composite &#123;
    operation()
	add(Component c)
	remove(Component c)
	getChild(int)
&#125;
Component &lt;|.. Composite
Composite o.. Composite

class Leaf &#123;
    operation()
&#125;

Component &lt;|.. Leaf
Component &lt;-- Client</code></pre>

<h1 id="参与者"><a href="#参与者" class="headerlink" title="参与者"></a>参与者</h1><h2 id="Component"><a href="#Component" class="headerlink" title="Component"></a>Component</h2><ul>
<li>定义 Client 需要的方法；</li>
<li>适当情况下，提供默认实现；</li>
<li>声明访问和管理 Component 操作；</li>
</ul>
<h2 id="Composite"><a href="#Composite" class="headerlink" title="Composite"></a>Composite</h2><ul>
<li>Component 的实现；</li>
<li>存储子 Component；</li>
<li>实现 Component 中与子 Component 有关的操作；</li>
</ul>
<h2 id="Leaf"><a href="#Leaf" class="headerlink" title="Leaf"></a>Leaf</h2><ul>
<li>叶子节点，没有子 Component；</li>
</ul>
<h2 id="Client-类"><a href="#Client-类" class="headerlink" title="Client 类"></a>Client 类</h2><p>客户端。</p>
<h1 id="数据流"><a href="#数据流" class="headerlink" title="数据流"></a>数据流</h1><ol>
<li>Client 仅仅与 Component 进行交互；</li>
</ol>
<h1 id="相关模式"><a href="#相关模式" class="headerlink" title="相关模式"></a>相关模式</h1><ul>
<li>职责链模式：通常”部分-整体“的连接使用职责链模式；</li>
<li>装饰模式：通常与组合模式一起使用，它们有公共的父类。</li>
<li>享元模式：共享组件；</li>
<li>迭代器模式：通常用来遍历组合模式；</li>
<li>访问者模式：将分布在 Composite 和 Leaf 类中的操作和行为局部化；</li>
</ul>
<h1 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h1><ul>
<li>数据可以使用组合模式来表示，业务需求可以通过在树上的递归遍历算法来实现。</li>
</ul>
<h1 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h1><p><a href="https://github.com/hanzhang2566/design-patterns-examples/blob/main/go-patterns/structural/composite/composite_test.go">golang</a></p>
<p><a href="https://github.com/hanzhang2566/design-patterns-examples/blob/main/java-patterns/src/test/java/structural/composite/ClientTest.java">java</a></p>
]]></content>
      <tags>
        <tag>design pattern</tag>
      </tags>
  </entry>
  <entry>
    <title>集合</title>
    <url>/2023/05/07/redis-set/</url>
    <content><![CDATA[<p>Redis 集合允许用户将任意个不相同的元素存储到集合中，这些元素既可以是文本数据，也可以是二进制数据。</p>
<span id="more"></span>

<h1 id="基本命令"><a href="#基本命令" class="headerlink" title="基本命令"></a>基本命令</h1><h2 id="SADD"><a href="#SADD" class="headerlink" title="SADD"></a>SADD</h2><p>添加一个或多个元素到集合，返回添加元素的数量。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 1</span><br><span class="line">SADD databases &quot;redis&quot;</span><br><span class="line"></span><br><span class="line">-- 2</span><br><span class="line">SADD databases &quot;mongodb&quot; &quot;couchdb&quot;</span><br><span class="line"></span><br><span class="line">-- 3</span><br><span class="line">SADD databases &quot;mysql&quot; &quot;postgresql&quot; &quot;oracle&quot;</span><br><span class="line"></span><br><span class="line">-- 1，因为只有 influxdb 被插入了</span><br><span class="line">SADD databases &quot;influxdb&quot; &quot;mysql&quot;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(n)</p>
<h2 id="SREM"><a href="#SREM" class="headerlink" title="SREM"></a>SREM</h2><p>从集合中删除一个或多个元素，返回移除元素的数量。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 2</span><br><span class="line">SREM databases &quot;mysql&quot; &quot;redis&quot;</span><br><span class="line"></span><br><span class="line">-- 0</span><br><span class="line">SREM databases &quot;mysql&quot; &quot;redis&quot;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(n)</p>
<h2 id="SMOVE"><a href="#SMOVE" class="headerlink" title="SMOVE"></a>SMOVE</h2><p>将指定元素从 source 集合移动到 target 集合，返回操作结果 bool。</p>
<p>如果 source 或者指定元素不存在，返回 false。</p>
<p>如果 target 中已经有指定元素，则只会移除 source 中的元素，返回 true。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 将 mongodb 从 databases 移动到 doc::databases 集合中， true</span><br><span class="line">SMOVE databases doc::databases &quot;mongodb&quot;</span><br><span class="line"></span><br><span class="line">-- false</span><br><span class="line">SMOVE databases doc::databases &quot;mongodb&quot;</span><br><span class="line"></span><br><span class="line">SADD databases &quot;mongodb&quot;</span><br><span class="line">-- doc::databases 已经存在 mongodb，则会删除 databases 中的 mongodb，返回 true</span><br><span class="line">SMOVE databases doc::databases &quot;mongodb&quot;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(1)</p>
<h2 id="SMEMBERS"><a href="#SMEMBERS" class="headerlink" title="SMEMBERS"></a>SMEMBERS</h2><p>获取集合中所有元素。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- mysql postgresql oracle</span><br><span class="line">SMEMBERS databases</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(n)</p>
<h2 id="SCARD"><a href="#SCARD" class="headerlink" title="SCARD"></a>SCARD</h2><p>获取集合中元素的数量。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 3</span><br><span class="line">SCARD databases</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(1)</p>
<h2 id="SISMEMBER"><a href="#SISMEMBER" class="headerlink" title="SISMEMBER"></a>SISMEMBER</h2><p>检查指定元素是否在集合中，返回 bool。</p>
<p>如果集合不存在，返回 false。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- true</span><br><span class="line">SISMEMBER databases &quot;mysql&quot;</span><br><span class="line"></span><br><span class="line">-- false</span><br><span class="line">SISMEMBER databases &quot;mongodb&quot;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(1)</p>
<h2 id="SRANDMEMBER"><a href="#SRANDMEMBER" class="headerlink" title="SRANDMEMBER"></a>SRANDMEMBER</h2><p>随机获取集合中的指定个数元素，默认为 1。</p>
<p>当指定个数 &gt; SCARD 时，返回所有。</p>
<p>如果指定个数 &lt; 0 时，返回指定个数绝对值。</p>
<p>若集合不存在，返回 nil</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 随机返回 1 个</span><br><span class="line">SRANDMEMBER databases</span><br><span class="line"></span><br><span class="line">-- 随机返回 2 个</span><br><span class="line">SRANDMEMBER databases 2</span><br><span class="line">SRANDMEMBER databases -2</span><br><span class="line"></span><br><span class="line">-- 返回 3 个</span><br><span class="line">SCARD databases</span><br><span class="line">-- 5 &gt; 3，则返回所有</span><br><span class="line">SRANDMEMBER databases 5</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(n)</p>
<h2 id="SPOP"><a href="#SPOP" class="headerlink" title="SPOP"></a>SPOP</h2><p>同 SRANDMEMBER，区别在于：</p>
<ol>
<li>会将返回的元素从集合中移除；</li>
<li>指定元素不能为 &lt; 0;</li>
</ol>
<p>时间复杂度：O(n)</p>
<h2 id="SINSER"><a href="#SINSER" class="headerlink" title="SINSER"></a>SINSER</h2><p>返回指定集合的交集，若集合不存在，返回空。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SADD s1 &quot;a&quot; &quot;b&quot;</span><br><span class="line">SADD s2 &quot;b&quot; &quot;c&quot; &quot;d&quot;</span><br><span class="line"></span><br><span class="line">-- 返回 s1 和 s2 的交集</span><br><span class="line">SINTER s1 s2</span><br><span class="line">-- 返回 s1、s2 和 s3 的交集</span><br><span class="line">SINTER s1 s2 s3</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(n*m)</p>
<h2 id="SINTERSTORE"><a href="#SINTERSTORE" class="headerlink" title="SINTERSTORE"></a>SINTERSTORE</h2><p>同 SINTER，有以下区别：</p>
<ol>
<li>会将指定集合的交集插入到新的集合中；</li>
<li>指定集合不存在或没有交集，则返回空，否则返回集合中元素数量；</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SADD s1 &quot;a&quot; &quot;b&quot;</span><br><span class="line">SADD s2 &quot;b&quot; &quot;c&quot; &quot;d&quot;</span><br><span class="line">SADD s3 &quot;b&quot; &quot;c&quot; &quot;d&quot;</span><br><span class="line"></span><br><span class="line">-- 将 s1 s2 s3 的交集插入到 insert 集合中</span><br><span class="line">SINTERSTORE insert s1 s2 s3</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(n*m)</p>
<h2 id="SUNION"><a href="#SUNION" class="headerlink" title="SUNION"></a>SUNION</h2><p>返回指定集合的并集。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SADD s1 &quot;a&quot; &quot;b&quot;</span><br><span class="line">SADD s2 &quot;b&quot; &quot;c&quot; &quot;d&quot;</span><br><span class="line"></span><br><span class="line">-- 返回 s1 和 s2 的并集</span><br><span class="line">SUNION s1 s2</span><br><span class="line">-- 返回 s1 和 s22 的并集，s22 不存在，则返回 s1 的集合</span><br><span class="line">SUNION s1 s22</span><br><span class="line">-- 返回 s1、s2 和 s3 的并集</span><br><span class="line">SINTER s1 s2 s3</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(max(n, m))</p>
<h2 id="SUNIONSTORE"><a href="#SUNIONSTORE" class="headerlink" title="SUNIONSTORE"></a>SUNIONSTORE</h2><p>同 SUNION，有以下区别：</p>
<ol>
<li>会将指定集合的交集插入到新的集合中；</li>
<li>指定集合不存在或没有交集，则返回空，否则返回集合中元素数量；</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SADD s1 &quot;a&quot; &quot;b&quot;</span><br><span class="line">SADD s2 &quot;b&quot; &quot;c&quot; &quot;d&quot;</span><br><span class="line">SADD s3 &quot;b&quot; &quot;c&quot; &quot;d&quot;</span><br><span class="line"></span><br><span class="line">-- 将 s1 s2 s3 的并集插入到 union 集合中</span><br><span class="line">SUNIONSTORE union s1 s2 s3</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(max(n, m))</p>
<h1 id="对比列表"><a href="#对比列表" class="headerlink" title="对比列表"></a>对比列表</h1><ol start="2">
<li>列表是有序，集合无序；</li>
<li>列表可以存储重复元素，集合不行；</li>
</ol>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul>
<li>集合只允许添加任意个各不相同的元素；</li>
<li>所有针对单个元素的集合操作，复杂度都为O(1)；</li>
<li>集合的存储是无序的；</li>
<li>SRANDMEMBER 命令 peek 一个随机选中的元素，而 SPOP 命令 pop一个随机选中的元素；</li>
<li>应该使用集合的 store 操作；</li>
</ul>
]]></content>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>适配器模式</title>
    <url>/2023/05/06/structural-adapter/</url>
    <content><![CDATA[<h1 id="模式描述"><a href="#模式描述" class="headerlink" title="模式描述"></a>模式描述</h1><p>将一个类的接口转换为客户希望的另外一个接口。</p>
<h1 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h1><h1 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h1><h1 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h1><ol>
<li>封装有缺陷的接口设计；</li>
<li>统一多个类的接口设计；</li>
<li>替换依赖的外部系统；</li>
<li>兼容老版本接口；</li>
<li>适配不同格式的数据；</li>
</ol>
<span id="more"></span>

<table>
<thead>
<tr>
<th align="center">DATE</th>
<th align="center">CHANGELOG</th>
</tr>
</thead>
<tbody><tr>
<td align="center">2023年5月6日</td>
<td align="center">初始化</td>
</tr>
</tbody></table>
<h1 id="UML-类图"><a href="#UML-类图" class="headerlink" title="UML 类图"></a>UML 类图</h1><pre><code class="highlight mermaid">---
title: 继承实现
---
classDiagram
class Target &#123;
	request()
&#125;

class Adaptee &#123;
	specificReqest()
&#125;

class Adapter &#123;
	request()
&#125;

Target &lt;|.. Adapter
Adaptee &lt;|-- Adapter
Target &lt;-- Client</code></pre>

<pre><code class="highlight mermaid">---
title: 组合实现
---
classDiagram
class Target &#123;
	request()
&#125;

class Adaptee &#123;
	specificReqest()
&#125;

class Adapter &#123;
	request()
&#125;

Target &lt;|.. Adapter
Adaptee o-- Adapter
Target &lt;-- Client</code></pre>



<h1 id="参与者"><a href="#参与者" class="headerlink" title="参与者"></a>参与者</h1><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><ul>
<li>定义 Client 使用的接口；</li>
</ul>
<h2 id="Adaptee"><a href="#Adaptee" class="headerlink" title="Adaptee"></a>Adaptee</h2><ul>
<li>已经存在的接口；</li>
</ul>
<h2 id="Adapter"><a href="#Adapter" class="headerlink" title="Adapter"></a>Adapter</h2><ul>
<li>将 Adaptee 适配到 Target 的接口；</li>
</ul>
<h2 id="Client-类"><a href="#Client-类" class="headerlink" title="Client 类"></a>Client 类</h2><p>客户端。</p>
<h1 id="数据流"><a href="#数据流" class="headerlink" title="数据流"></a>数据流</h1><ol>
<li>Client 在 Adapter 实例上调用一些操作；</li>
<li>Adaptee 来实现 Adapter 的操作；</li>
</ol>
<h1 id="相关模式"><a href="#相关模式" class="headerlink" title="相关模式"></a>相关模式</h1><ul>
<li>桥接模式：桥接模式的出发点是将接口和实现分离，使两者可以独立地改变；而适配器模式需要改变一个已有对象的接口；</li>
<li>装饰器模式：装饰器模式在不改变接口的前提下，增强功能，它对应用程序的透明性比适配器好；</li>
<li>代理模式：代理模式不改变原有接口。主要目的是控制访问，而非加强功能；</li>
</ul>
<h1 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h1><ul>
<li>如果 Adaptee 接口并不多，组合和继承都可以选择；</li>
<li>如果 Adaptee 接口很多，而且 Adaptee 和 ITarget 接口定义大部分都相同，继承适配器的代码量少，推荐使用;</li>
<li>如果 Adaptee 接口很多，而且 Adaptee 和 ITarget 接口定义大部分都不相同，组合适配器更加灵活;</li>
<li>适配器模式是”补偿“模式，用来补救设计上的缺陷；</li>
</ul>
<h1 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h1><p><a href="https://github.com/hanzhang2566/design-patterns-examples/blob/main/go-patterns/structural/adapter/adapter_test.go">golang</a></p>
<p><a href="https://github.com/hanzhang2566/design-patterns-examples/blob/main/java-patterns/src/test/java/structural/adapter/ClientTest.java">java</a></p>
]]></content>
      <tags>
        <tag>design pattern</tag>
      </tags>
  </entry>
  <entry>
    <title>程序员必读之软件架构</title>
    <url>/2023/05/06/reading-note-software-architecture-for-developers/</url>
    <content><![CDATA[<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul>
<li><p>软件架构不是预先设计；</p>
</li>
<li><p>每个团队都需要考虑软件架构；</p>
</li>
<li><p>架构师参与编码；</p>
</li>
<li><p>UML 不是必须的；</p>
</li>
</ul>
<h1 id="软件架构的本质"><a href="#软件架构的本质" class="headerlink" title="软件架构的本质"></a>软件架构的本质</h1><p>包含一个软件产品从端到端的完整的、与之相关的、重要的完整元素的综合考虑。</p>
<h1 id="软件架构的好处"><a href="#软件架构的好处" class="headerlink" title="软件架构的好处"></a>软件架构的好处</h1><ol>
<li>让团队跟随一个清晰的愿景和路线图，无论这个愿景是一人所有还是整个团队共有；</li>
<li>形成技术领导力，能够更好的协调；</li>
<li>与人交流的刺激因素，以便回答与重要决策、非功能需求、限制和其他横切关注点相关的问题；</li>
<li>识别和减轻风险的框架；</li>
<li>方法和标准的一致性，随之而来的结构良好的代码库；</li>
<li>正在构建的产品的坚实基础；</li>
<li>对不同的听众，以不同层次的抽象来交流解决方案的结构</li>
</ol>
<h1 id="软件架构的职责"><a href="#软件架构的职责" class="headerlink" title="软件架构的职责"></a>软件架构的职责</h1><h2 id="理解业务目标"><a href="#理解业务目标" class="headerlink" title="理解业务目标"></a>理解业务目标</h2><ol>
<li>需求。包括功能性需求和非功能性需求等；</li>
<li>限制。包括环境、人员水平和预算等；</li>
</ol>
<h2 id="设计软件"><a href="#设计软件" class="headerlink" title="设计软件"></a>设计软件</h2><ol>
<li>技术选型；</li>
<li>架构设计；</li>
<li>模块拆分；</li>
</ol>
<h2 id="风险管理"><a href="#风险管理" class="headerlink" title="风险管理"></a>风险管理</h2><p>技术选择其实就是风险管理。</p>
<ol>
<li>当复杂度或不确定性高的时候降低风险，有利可图时再冒点险；</li>
<li>主动发现、减轻和承担高优先级的技术风险；</li>
</ol>
<h2 id="架构演化"><a href="#架构演化" class="headerlink" title="架构演化"></a>架构演化</h2><p>贯穿软件交付整个过程，持续关注架构演进。</p>
<h2 id="参与开发"><a href="#参与开发" class="headerlink" title="参与开发"></a>参与开发</h2><ol>
<li>从开发角度看架构；</li>
<li>不一定完成日常的编码任务，但要持续地参与到交付中;</li>
</ol>
<h2 id="保证软件质量"><a href="#保证软件质量" class="headerlink" title="保证软件质量"></a>保证软件质量</h2><p>保证一条基线，它可以是引入一些标准和工作实践，如编码标准、设计原则和工具。</p>
<h1 id="软技能"><a href="#软技能" class="headerlink" title="软技能"></a>软技能</h1><h2 id="领导力"><a href="#领导力" class="headerlink" title="领导力"></a>领导力</h2><p>创造共有愿景，并带领同事向其前进的能力。</p>
<h2 id="沟通"><a href="#沟通" class="headerlink" title="沟通"></a>沟通</h2><p>不解释。</p>
<h2 id="影响力"><a href="#影响力" class="headerlink" title="影响力"></a>影响力</h2><p>说服他人、倾听他人的能力。</p>
<h2 id="信心"><a href="#信心" class="headerlink" title="信心"></a>信心</h2><p>信心不是傲慢，是领导力、影响力和沟通的基础。</p>
<h2 id="合作"><a href="#合作" class="headerlink" title="合作"></a>合作</h2><p>倾听、谦虚和响应反馈。</p>
<h2 id="导师"><a href="#导师" class="headerlink" title="导师"></a>导师</h2><p>辅导、引导和指导下属。</p>
<h2 id="动力"><a href="#动力" class="headerlink" title="动力"></a>动力</h2><p>不解释。</p>
<h2 id="润滑剂"><a href="#润滑剂" class="headerlink" title="润滑剂"></a>润滑剂</h2><p>凝聚团队，达成共识。</p>
<h2 id="政治"><a href="#政治" class="headerlink" title="政治"></a>政治</h2><p>远离但要了解。</p>
<h2 id="责任感"><a href="#责任感" class="headerlink" title="责任感"></a>责任感</h2><p>不解释。</p>
<h2 id="授权"><a href="#授权" class="headerlink" title="授权"></a>授权</h2><p>适当授权。</p>
<h1 id="软件架构的经验"><a href="#软件架构的经验" class="headerlink" title="软件架构的经验"></a>软件架构的经验</h1><h2 id="引入约束"><a href="#引入约束" class="headerlink" title="引入约束"></a>引入约束</h2><p>先从部分控制开始，倾听反馈，以便随着项目的推进再微调。</p>
<h2 id="包容"><a href="#包容" class="headerlink" title="包容"></a>包容</h2><p>让组内成员参与到软件架构的过程中。</p>
<h2 id="参与编码"><a href="#参与编码" class="headerlink" title="参与编码"></a>参与编码</h2><p>不解释。</p>
<h1 id="软件架构的考虑"><a href="#软件架构的考虑" class="headerlink" title="软件架构的考虑"></a>软件架构的考虑</h1><h1 id="为什么软件架构角色应当包含编码、指导与合作"><a href="#为什么软件架构角色应当包含编码、指导与合作" class="headerlink" title="为什么软件架构角色应当包含编码、指导与合作"></a>为什么软件架构角色应当包含编码、指导与合作</h1><h1 id="为什么软件架构角色应当包含编码、指导与合作-1"><a href="#为什么软件架构角色应当包含编码、指导与合作-1" class="headerlink" title="为什么软件架构角色应当包含编码、指导与合作"></a>为什么软件架构角色应当包含编码、指导与合作</h1><h1 id="如何用简单的草图让你的软件架构可视化"><a href="#如何用简单的草图让你的软件架构可视化" class="headerlink" title="如何用简单的草图让你的软件架构可视化"></a>如何用简单的草图让你的软件架构可视化</h1><h1 id="为软件生成文档的轻量方法"><a href="#为软件生成文档的轻量方法" class="headerlink" title="为软件生成文档的轻量方法"></a>为软件生成文档的轻量方法</h1><h1 id="为什么敏捷和架构并不冲突"><a href="#为什么敏捷和架构并不冲突" class="headerlink" title="为什么敏捷和架构并不冲突"></a>为什么敏捷和架构并不冲突</h1><h1 id="“恰如其分”的预先设计是什么意思"><a href="#“恰如其分”的预先设计是什么意思" class="headerlink" title="“恰如其分”的预先设计是什么意思"></a>“恰如其分”的预先设计是什么意思</h1><h1 id="如何通过风险风暴来识别风险。"><a href="#如何通过风险风暴来识别风险。" class="headerlink" title="如何通过风险风暴来识别风险。"></a>如何通过风险风暴来识别风险。</h1><h1 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h1><p><a href="https://book.douban.com/subject/26248182/">程序员必读之软件架构</a></p>
]]></content>
      <tags>
        <tag>reading notes</tag>
      </tags>
  </entry>
  <entry>
    <title>列表</title>
    <url>/2023/05/06/redis-list/</url>
    <content><![CDATA[<p>Redis 的列表是一种线性的有序结构，可以按照元素被推入列表中的顺序来存储元素。这些元素既可以是文字数据，又可以是二进制数据，并且列表中的元素可以重复出现。</p>
<span id="more"></span>

<h1 id="基本命令"><a href="#基本命令" class="headerlink" title="基本命令"></a>基本命令</h1><h2 id="LPUSH"><a href="#LPUSH" class="headerlink" title="LPUSH"></a>LPUSH</h2><p>将一个或多个元素依次推入列表左端，返回当前列表包含的元素数量。</p>
<p>当列表不存在，会创建一个新列表。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 返回 1。hanzhang</span><br><span class="line">LPUSH name &quot;hanzhang&quot;</span><br><span class="line"></span><br><span class="line">-- 返回 3。hanhan hanzuo hanzhang</span><br><span class="line">LPUSH name &quot;hanzuo&quot; &quot;hanhan&quot;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(n)</p>
<h2 id="RPUSH"><a href="#RPUSH" class="headerlink" title="RPUSH"></a>RPUSH</h2><p>将一个或多个元素依次推入列表右端，返回当前列表包含的元素数量。</p>
<p>当列表不存在，会创建一个新列表。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 返回 4.hanhan hanzuo hanzhang hanyang</span><br><span class="line">RPUSH name &quot;hanyang&quot;</span><br><span class="line">-- 返回 6.hanhan hanzuo hanzhang hanyang hantang hanshen</span><br><span class="line">RPUSH name &quot;hantang&quot; &quot;hanshen&quot;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(n)</p>
<h2 id="LPUSHX"><a href="#LPUSHX" class="headerlink" title="LPUSHX"></a>LPUSHX</h2><p>当列表存在的情况下，将一个或多个元素依次推入列表左端，返回当前列表包含的元素数量。</p>
<p>当列表不存在的情况下，不会创建新列表，并返回 0.</p>
<p>时间复杂度：O(n)</p>
<h2 id="RPUSHX"><a href="#RPUSHX" class="headerlink" title="RPUSHX"></a>RPUSHX</h2><p>当列表存在的情况下，将一个或多个元素依次推入列表右端，返回当前列表包含的元素数量。</p>
<p>当列表不存在的情况下，不会创建新列表，并返回 0.</p>
<p>时间复杂度：O(n)</p>
<h2 id="LPOP"><a href="#LPOP" class="headerlink" title="LPOP"></a>LPOP</h2><p>移除左边第一个元素，并返回。</p>
<p>列表不存在，则返回 nil。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- hanhan</span><br><span class="line">LPOP name</span><br><span class="line"></span><br><span class="line">-- hanzuo</span><br><span class="line">LPOP name</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(1)</p>
<h2 id="RPOP"><a href="#RPOP" class="headerlink" title="RPOP"></a>RPOP</h2><p>移除右边第一个元素，并返回。</p>
<p>列表不存在，则返回 nil。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- hanshen</span><br><span class="line">RPOP name</span><br><span class="line"></span><br><span class="line">-- hantang</span><br><span class="line">RPOP name</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(1)</p>
<h2 id="RPOPLPUSH"><a href="#RPOPLPUSH" class="headerlink" title="RPOPLPUSH"></a>RPOPLPUSH</h2><p>移除右边第一个元素，并从左边推入 target 列表。</p>
<p>源列表不存在，则返回 nil。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 同源。hanyang hanzhang</span><br><span class="line">RPOPLPUSH name name</span><br><span class="line"></span><br><span class="line">-- 不同源</span><br><span class="line">-- name hanyang</span><br><span class="line">-- new::name hanzhang</span><br><span class="line">RPOPLPUSH name new::name</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(1)</p>
<h2 id="LLEN"><a href="#LLEN" class="headerlink" title="LLEN"></a>LLEN</h2><p>获取列表长度。</p>
<p>不存在则返回 0。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 返回 school 的长度</span><br><span class="line">LLEN school</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(1)</p>
<h2 id="LINDEX"><a href="#LINDEX" class="headerlink" title="LINDEX"></a>LINDEX</h2><p>返回列表指定下标的元素。</p>
<ul>
<li>正索引从左端 0 开始；</li>
<li>负索引从右端 -1 开始；</li>
</ul>
<p>列表不存在或下标不合法则返回 nil.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- hanzhang hantang hanshen</span><br><span class="line">RPUSH name &quot;hanzhang&quot; &quot;hantang&quot; &quot;hanshen&quot;</span><br><span class="line"></span><br><span class="line">-- nil</span><br><span class="line">LINDEX name 100</span><br><span class="line">-- nil</span><br><span class="line">LINDEX nama 0</span><br><span class="line"></span><br><span class="line">-- hantang</span><br><span class="line">LINDEX name 1</span><br><span class="line">-- hanzhang</span><br><span class="line">LINDEX name -3</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(n)</p>
<h2 id="LRANGE"><a href="#LRANGE" class="headerlink" title="LRANGE"></a>LRANGE</h2><p>获取列表指定闭区间范围的所有元素。</p>
<ol>
<li>起止索引都超过，返回 nil；</li>
<li>其中一个超过，则修正为实际范围（左端为 0，右端为 -1）；</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 列表的所有元素</span><br><span class="line">LRANGE name 0 -1</span><br><span class="line">-- 列表 0-1 之间的元素</span><br><span class="line">LRANGE name 0 1</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(n)</p>
<h2 id="LSET"><a href="#LSET" class="headerlink" title="LSET"></a>LSET</h2><p>设置列表指定下标的元素。</p>
<p>下标不合法会抛出错误。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 设置 ok</span><br><span class="line">LSET name 0 &quot;hanhan&quot;</span><br><span class="line">-- error</span><br><span class="line">LSET name 110 &quot;hanhan&quot;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(n)</p>
<h2 id="LINSERT"><a href="#LINSERT" class="headerlink" title="LINSERT"></a>LINSERT</h2><p>将新元素插入到指定列表元素的前或后。</p>
<p>指定元素不存在，返回 -1。</p>
<p>只操作满足条件的第一个指定元素。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 将 hanzhang 插入到 hanhan 前面</span><br><span class="line">LINSERT name BEFORE &quot;hanhan&quot; &quot;hanzhang&quot;</span><br><span class="line"></span><br><span class="line">-- 将 hanzhang 插入到 hanhan 后面</span><br><span class="line">LINSERT name AFTER &quot;hantang&quot; &quot;hanzhang&quot;</span><br><span class="line"></span><br><span class="line">-- hhah 不存在，返回 -1</span><br><span class="line">LINSERT name BEFORE &quot;hhah&quot; &quot;hanyang&quot;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(n)</p>
<h2 id="LTRIM"><a href="#LTRIM" class="headerlink" title="LTRIM"></a>LTRIM</h2><p>保留指定下标闭区间元素。</p>
<p>正负索引都可。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 保留 0-3 闭区间元素</span><br><span class="line">LTRIM name 0 3</span><br><span class="line"></span><br><span class="line">-- 保留 -3 - -1 闭区间元素</span><br><span class="line">LTRIM name -3 -1</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(n)</p>
<h2 id="LREM"><a href="#LREM" class="headerlink" title="LREM"></a>LREM</h2><p>移除列表元素，返回移除的个数。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">RPUSH name &quot;hanzhang&quot; &quot;hantang&quot; &quot;hanshen&quot; &quot;hanzhang&quot; &quot;hantang&quot; &quot;hanshen&quot;</span><br><span class="line"></span><br><span class="line">-- 从左边移除 2 个 hanzhang: hantang hanshen hantang hanshen</span><br><span class="line">LREM name 2 &quot;hanzhang&quot;</span><br><span class="line">-- 从右边移除 2 个 hantang: hanshen hanshen</span><br><span class="line">LREM name -2 &quot;hanzhang&quot;</span><br><span class="line">-- 移除所有 hanshen</span><br><span class="line">LREM name 0 &quot;hanshen&quot;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(n)</p>
<h2 id="BLPOP"><a href="#BLPOP" class="headerlink" title="BLPOP"></a>BLPOP</h2><p>带有阻塞的左端弹出操作，单位是 s。</p>
<p>timeout 为 0 时，表示一直等待，知道有消息。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 左端弹出 school 元素，阻塞最多 10s</span><br><span class="line">BLPOP school 10</span><br></pre></td></tr></table></figure>

<p>同时很多线程阻塞时，先阻塞，先服务。</p>
<p>时间复杂度：O(n)</p>
<h2 id="BRPOP"><a href="#BRPOP" class="headerlink" title="BRPOP"></a>BRPOP</h2><p>作用同 BLPOP，只是从右端弹出。</p>
<h2 id="BRPOPLPUSH"><a href="#BRPOPLPUSH" class="headerlink" title="BRPOPLPUSH"></a>BRPOPLPUSH</h2><p>作用同 RPOPLPUSH，只是带有阻塞功能。</p>
<p>时间复杂度：O(1)</p>
<h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><h2 id="使用-BLPOP-实现异步处理消息"><a href="#使用-BLPOP-实现异步处理消息" class="headerlink" title="使用 BLPOP 实现异步处理消息"></a>使用 BLPOP 实现异步处理消息</h2><p>Producer 只需要将消息 PUSH 到 redis 中，然后处理自己的业务。而 redis 中监听该消息的程序 Consumer 会后续处理，实现了消息生产者与消费者的解耦。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Producer</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">MsgProducer</span><span class="params">(key, value <span class="type">string</span>)</span></span> (<span class="type">int64</span>, <span class="type">error</span>) &#123;</span><br><span class="line">	rdb := redis.NewClient(&amp;redis.Options&#123;</span><br><span class="line">		Addr:     <span class="string">&quot;43.142.129.110:6379&quot;</span>,</span><br><span class="line">		Password: <span class="string">&quot;&quot;</span>, <span class="comment">// no password set</span></span><br><span class="line">		DB:       <span class="number">0</span>,  <span class="comment">// use default DB</span></span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> rdb.RPush(context.Background(), key, value).Result()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Consumer</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">MsgConsumer</span><span class="params">(key <span class="type">string</span>)</span></span> ([]<span class="type">string</span>, <span class="type">error</span>) &#123;</span><br><span class="line">	rdb := redis.NewClient(&amp;redis.Options&#123;</span><br><span class="line">		Addr:     <span class="string">&quot;43.142.129.110:6379&quot;</span>,</span><br><span class="line">		Password: <span class="string">&quot;&quot;</span>, <span class="comment">// no password set</span></span><br><span class="line">		DB:       <span class="number">0</span>,  <span class="comment">// use default DB</span></span><br><span class="line">	&#125;)</span><br><span class="line">	<span class="keyword">return</span> rdb.BLPop(context.Background(), <span class="number">0</span>, key).Result()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Test</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestMsgProducer</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">	result, err := MsgProducer(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;zhanghan&quot;</span>)</span><br><span class="line">	assert.Nil(t, err)</span><br><span class="line">	assert.Equal(t, <span class="number">1</span>, <span class="type">int</span>(result))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestMsgConsumer</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">	result, err := MsgConsumer(<span class="string">&quot;name&quot;</span>)</span><br><span class="line">	assert.Nil(t, err)</span><br><span class="line">	fmt.Println(result)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>异步阻塞方式，使得 Consumer 程序更为简单，不需要 while true 进行处理，减少了 CPU 消耗；</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul>
<li>列表是线性有序结构，元素可重复；</li>
<li>POP 和 PUSH 都可以进行双端操作，LINSERT 可以插入元素；</li>
<li>LREM 可以删除元素，LTRIM 对列表进行截取；</li>
<li>LRANGE 会对下标进行修正，左端为 0，右端为 -1；</li>
<li>BLPOP、BRPOP 和 BRPOPLPUSH 当列表为空时，带有阻塞；</li>
</ul>
]]></content>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>备忘录模式</title>
    <url>/2023/05/05/behavioral-memento/</url>
    <content><![CDATA[<h1 id="模式描述"><a href="#模式描述" class="headerlink" title="模式描述"></a>模式描述</h1><p>在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，以便于恢复到原先保存的状态。</p>
<h1 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h1><ol>
<li>备忘录只能由 Originator 来创建，保护封装边界；</li>
<li>简化了 Originator；</li>
</ol>
<h1 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h1><ol>
<li>使用备忘录代价可能很高；</li>
<li>一些语言难以保证只有 Originator 访问 Memento；</li>
<li>维护 Memento 有潜在代价；</li>
</ol>
<h1 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h1><ol>
<li>需要保存一个对象的状态，便于恢复到原先保存的状态；</li>
<li>放丢失、撤销和恢复；</li>
</ol>
<span id="more"></span>

<table>
<thead>
<tr>
<th align="center">DATE</th>
<th align="center">CHANGELOG</th>
</tr>
</thead>
<tbody><tr>
<td align="center">2023年5月7日</td>
<td align="center">初始化</td>
</tr>
</tbody></table>
<h1 id="UML-类图"><a href="#UML-类图" class="headerlink" title="UML 类图"></a>UML 类图</h1><pre><code class="highlight mermaid">classDiagram
class Originator &#123;
	State state
	setMemento(Memento memento)
	createMemento() Memento
&#125;

class Memento &#123;
	State state
	getState()
	setState()
&#125;

Originator &lt;-- Memento

class Caretaker &#123;
	
&#125;
Caretaker o-- Memento

Originator &lt;-- Client
Caretaker &lt;-- Client</code></pre>

<h1 id="参与者"><a href="#参与者" class="headerlink" title="参与者"></a>参与者</h1><h2 id="Memento"><a href="#Memento" class="headerlink" title="Memento"></a>Memento</h2><ul>
<li>保存 Originator 中的内部状态；</li>
<li>防止 Originator 意外的其他对象访问；</li>
</ul>
<h2 id="Originator"><a href="#Originator" class="headerlink" title="Originator"></a>Originator</h2><ul>
<li>用来创建一个 Memento；</li>
<li>用来恢复内部状态；</li>
</ul>
<h2 id="Caretaker"><a href="#Caretaker" class="headerlink" title="Caretaker"></a>Caretaker</h2><ul>
<li>负责保存 Memento；</li>
</ul>
<h2 id="Client-类"><a href="#Client-类" class="headerlink" title="Client 类"></a>Client 类</h2><p>客户端。</p>
<h1 id="数据流"><a href="#数据流" class="headerlink" title="数据流"></a>数据流</h1><ol>
<li>Client 创建一个 Memento，并使用 Originator 保存到 Caretaker 中；</li>
</ol>
<h1 id="相关模式"><a href="#相关模式" class="headerlink" title="相关模式"></a>相关模式</h1><ul>
<li>命令模式：可以使用备忘录来为可撤销的操作维护状态；</li>
<li>迭代模式：备忘录模式可用于迭代；</li>
</ul>
<h1 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h1><ul>
<li>备忘录模式更侧重于代码的设计和实现，备份更侧重架构设计或产品设计；</li>
<li>大对象的备份可能只备份必要的恢复信息，结合最新的数据来恢复；或者，使用全量备份和增量备份相结合，低频全量备份，高频增量备份，两者结合来做恢复；</li>
</ul>
<h1 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h1><p><a href="https://github.com/hanzhang2566/design-patterns-examples/blob/main/go-patterns/behavioral/memento/memento_test.go">golang</a></p>
<p><a href="https://github.com/hanzhang2566/design-patterns-examples/blob/main/java-patterns/src/main/java/behavioral/memento/Client.java">java</a></p>
]]></content>
      <tags>
        <tag>design pattern</tag>
      </tags>
  </entry>
  <entry>
    <title>散列表</title>
    <url>/2023/05/05/redis-hash/</url>
    <content><![CDATA[<p>Redis 散列键是将一个 k 与一个 map 在数据库关联起来，和 string 类型一样，k-v 可以是文本，也能是二进制。</p>
<span id="more"></span>

<h1 id="基本命令"><a href="#基本命令" class="headerlink" title="基本命令"></a>基本命令</h1><h2 id="HSET"><a href="#HSET" class="headerlink" title="HSET"></a>HSET</h2><p>设置 k-v 散列。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 设置 k-v，v 是一个 map</span><br><span class="line">HSET article::10086 title &quot;greeting&quot;</span><br><span class="line">HSET article::10086 content &quot;hello world&quot;</span><br><span class="line">HSET article::10086 author &quot;hanzhang&quot;</span><br><span class="line"></span><br><span class="line">-- 覆盖 title。如果不存在，则返回 1；存在就返回 0</span><br><span class="line">HSET article::10086 title &quot;good&quot;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(1)</p>
<h2 id="HSETNX"><a href="#HSETNX" class="headerlink" title="HSETNX"></a>HSETNX</h2><p>同 SETNX，只有在指定字段不存在时才会生效。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 不存在，设置成功，返回 true</span><br><span class="line">HSETNX hanzhang name &quot;hanzhang&quot;</span><br><span class="line">HSETNX hanzhang age 28</span><br><span class="line"></span><br><span class="line">-- 存在，设置失败，返回 false</span><br><span class="line">HSETNX hanzhang name &quot;zhanghan&quot;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(1)</p>
<h2 id="HGET"><a href="#HGET" class="headerlink" title="HGET"></a>HGET</h2><p>查询 k-v 字符串。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 查询 title</span><br><span class="line">HGET article::10086 &quot;title&quot;</span><br><span class="line"></span><br><span class="line">-- 不存在 map 或者 title，返回 nil</span><br><span class="line">HGET article::10086 &quot;titl&quot;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(1)</p>
<h2 id="HSTRLEN"><a href="#HSTRLEN" class="headerlink" title="HSTRLEN"></a>HSTRLEN</h2><p>同 STRLEN，查询 map 中对应字段的长度。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 返回 len(hanzhang.name)</span><br><span class="line">HSTRLEN hanzhang name</span><br><span class="line">-- 不存在，返回 0</span><br><span class="line">STRLEN gender</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(n)</p>
<h2 id="HEXISTS"><a href="#HEXISTS" class="headerlink" title="HEXISTS"></a>HEXISTS</h2><p>检查 map 中对应的字段是否存在。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- name 存在 -&gt; 返回 true</span><br><span class="line">HEXISTS hanzhang name</span><br><span class="line"></span><br><span class="line">-- gender 不存在 -&gt; 返回 false</span><br><span class="line">HEXISTS hanzhang gender</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(1)</p>
<h2 id="HDEL"><a href="#HDEL" class="headerlink" title="HDEL"></a>HDEL</h2><p>删除 map 中对应字段。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 获取 hanzhang 对应字段数量，不存在则返回 0</span><br><span class="line">HLEN hanzhang</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(1)</p>
<h2 id="HLEN"><a href="#HLEN" class="headerlink" title="HLEN"></a>HLEN</h2><p>获取 map 的字段数量。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SET message &quot;hello world&quot;</span><br><span class="line">-- 获取 message[0,4]闭区间内容</span><br><span class="line">GETRANGE message 0 4</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(n)</p>
<h2 id="HMSET"><a href="#HMSET" class="headerlink" title="HMSET"></a>HMSET</h2><p>同时一次为散列中设置多个字段。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 给 hanzhang 设置 name 和 age 字段</span><br><span class="line">HMSET hanzhang name &quot;hanzhang&quot; age 28</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(n)</p>
<h2 id="HMGET"><a href="#HMGET" class="headerlink" title="HMGET"></a>HMGET</h2><p>同时获取多个字段。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 获取 hanzhang 的 name、age 和 gender</span><br><span class="line">HMGET hanzhang name age gender</span><br><span class="line">-- 由于 address 不存在，只有它会返回 null</span><br><span class="line">HMGET hanzhang name age gender address</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(n)</p>
<h2 id="HKEYS"><a href="#HKEYS" class="headerlink" title="HKEYS"></a>HKEYS</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 获取 hanzhang 的所有 key</span><br><span class="line">HKEYS hanzhang</span><br></pre></td></tr></table></figure>

<h2 id="HVALS"><a href="#HVALS" class="headerlink" title="HVALS"></a>HVALS</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 获取 hanzhang 的所有 val</span><br><span class="line">HVALS hanzhang</span><br></pre></td></tr></table></figure>

<h2 id="HGETALL"><a href="#HGETALL" class="headerlink" title="HGETALL"></a>HGETALL</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 获取 hanzhang 的所有 k-v</span><br><span class="line">HGETALL hanzhang</span><br></pre></td></tr></table></figure>

<h1 id="对比字符串"><a href="#对比字符串" class="headerlink" title="对比字符串"></a>对比字符串</h1><h2 id="散列的优点"><a href="#散列的优点" class="headerlink" title="散列的优点"></a>散列的优点</h2><ol>
<li>只需要一个 key，就可以把人一多的字段存储到 key 中，减少资源消耗；</li>
<li>让数据更容易理解，方便操作；</li>
</ol>
<h2 id="字符串的优点"><a href="#字符串的优点" class="headerlink" title="字符串的优点"></a>字符串的优点</h2><ol>
<li>字符串的操作更丰富。例如，APPEND、SETRANGE 等；</li>
<li>过期时间设置比较灵活；</li>
</ol>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul>
<li>k 和 v 都是既可以存储二进制，又可以存储字符串；</li>
<li>v 对应的是一个 map；</li>
<li>map 中的字段在底层是无序的；</li>
</ul>
]]></content>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>状态模式</title>
    <url>/2023/05/04/behavioral-state/</url>
    <content><![CDATA[<h1 id="模式描述"><a href="#模式描述" class="headerlink" title="模式描述"></a>模式描述</h1><p>当一个对象的内在状态改变时，允许改变其行为。</p>
<h1 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h1><ol>
<li>状态转换是显示的；</li>
<li>特定状态的行为是耦合的；</li>
<li>State 变量可以被共享；</li>
</ol>
<h1 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h1><ol>
<li>会造成子类变多；</li>
</ol>
<h1 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h1><ol>
<li><p>状态不多，状态转移也简单，但触发状态后执行逻辑复杂；</p>
</li>
<li><p>一个对象的行为取决于它的状态，并且必须在运行时根据状态改变行为；</p>
</li>
</ol>
<span id="more"></span>

<table>
<thead>
<tr>
<th align="center">DATE</th>
<th align="center">CHANGELOG</th>
</tr>
</thead>
<tbody><tr>
<td align="center">2023年5月4日</td>
<td align="center">初始化</td>
</tr>
</tbody></table>
<h1 id="UML-类图"><a href="#UML-类图" class="headerlink" title="UML 类图"></a>UML 类图</h1><pre><code class="highlight mermaid">classDiagram
class Context &#123;
	request()
&#125;

class State &#123;
	&lt;&lt;interface&gt;&gt;
	handle()
&#125;

class ConcreteStateA &#123;
	handle()
&#125;

class ConcreteStateB &#123;
	handle()
&#125;

Context o.. State
State &lt;|.. ConcreteStateA
State &lt;|.. ConcreteStateB

Context &lt;-- Client</code></pre>

<h1 id="参与者"><a href="#参与者" class="headerlink" title="参与者"></a>参与者</h1><h2 id="Context"><a href="#Context" class="headerlink" title="Context"></a>Context</h2><ul>
<li>维护一个 ConcreteState 对象实例，定义为当前状态；</li>
<li>定义一个方法，用来对状态进行转移；</li>
</ul>
<h2 id="State"><a href="#State" class="headerlink" title="State"></a>State</h2><ul>
<li>定义封装一个与特定状态有关的行为；</li>
</ul>
<h2 id="ConcreteState"><a href="#ConcreteState" class="headerlink" title="ConcreteState"></a>ConcreteState</h2><ul>
<li>State 接口的实现；</li>
</ul>
<h2 id="Client"><a href="#Client" class="headerlink" title="Client"></a>Client</h2><p>客户端。</p>
<h1 id="数据流"><a href="#数据流" class="headerlink" title="数据流"></a>数据流</h1><ul>
<li>Client 只需要配置一个 Context，剩下的由 Context 中的方法驱动；</li>
<li>Context 和 ConcreteState 都可以决定状态的后继者，以及转换条件；</li>
</ul>
<h1 id="相关模式"><a href="#相关模式" class="headerlink" title="相关模式"></a>相关模式</h1><ul>
<li>享元模式：解释了何时以及怎样共享状态对象</li>
<li>单例模式：状态对象通常是单例的；</li>
</ul>
<h1 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h1><ul>
<li>分支逻辑法用于实现简单状态机；</li>
<li>查表法用于处理状态多，但业务简单的场景；通过二维数组来表示状态转移图，能极大地提高代码的可读性和可维护性；</li>
<li>像游戏这种比较复杂的状态机，包含的状态比较多，我优先推荐使用查表法，而状态模式会引入非常多的状态类，会导致代码比较难维护。相反，像电商下单、外卖下单这种类型的状态机，它们的状态并不多，状态转移也比较简单，但事件触发执行的动作包含的业务逻辑可能会比较复杂，所以，更加推荐使用状态模式来实现。</li>
</ul>
<h1 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h1><p><a href="https://github.com/hanzhang2566/design-patterns-examples/blob/main/go-patterns/behavioral/state/state_test.go">golang</a></p>
<p><a href="https://github.com/hanzhang2566/design-patterns-examples/blob/main/java-patterns/src/test/java/behavioral/state/ClientTest.java">java</a></p>
]]></content>
      <tags>
        <tag>design pattern</tag>
      </tags>
  </entry>
  <entry>
    <title>字符串</title>
    <url>/2023/05/04/redis-string/</url>
    <content><![CDATA[<p>字符串键是 Redis 中最基本的键值对类型，被关联的 k-v 既可以是普通文本数据，有可以是二进制数据。</p>
<span id="more"></span>

<h1 id="基本命令"><a href="#基本命令" class="headerlink" title="基本命令"></a>基本命令</h1><h2 id="SET"><a href="#SET" class="headerlink" title="SET"></a>SET</h2><p>设置 k-v 字符串。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 有引号</span><br><span class="line">SET message &quot;hello world&quot;</span><br><span class="line">SET homepage &quot;hanzhang2566.github.io&quot;</span><br><span class="line">SET price &quot;2.56&quot;</span><br><span class="line"></span><br><span class="line">-- 无引号</span><br><span class="line">SET name hanzhang</span><br><span class="line"></span><br><span class="line">-- 覆盖 name</span><br><span class="line">SET name Jeremy</span><br><span class="line"></span><br><span class="line">-- 参数</span><br><span class="line">-- 1. NX：当 key 不存在的情况下生效；否则返回 nil</span><br><span class="line">SET name hanzhang NX</span><br><span class="line">-- 2. XX：当 key 存在的情况下生效；否则返回 nil</span><br><span class="line">SET name hanzhang XX</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(1)</p>
<h2 id="MSET"><a href="#MSET" class="headerlink" title="MSET"></a>MSET</h2><p>设置多个 k-v 字符串。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 设置 name == hanzhang</span><br><span class="line">-- address == shanghai</span><br><span class="line">-- school == shzu</span><br><span class="line">MSET name hanzhang address shanghai school shzu</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(n)</p>
<ul>
<li>提高操作效率；</li>
<li>方便多个 k-v 操作；</li>
</ul>
<h2 id="MSETNX"><a href="#MSETNX" class="headerlink" title="MSETNX"></a>MSETNX</h2><p>&#x3D;&#x3D;所有&#x3D;&#x3D; k 不存在的情况下，设置多个 k-v 字符串</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- name 和 age 都不存在的情况下，设置成功，返回 true；否则，返回 false</span><br><span class="line">MSETNX  name zhanghan age 28</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(n)</p>
<h2 id="GET"><a href="#GET" class="headerlink" title="GET"></a>GET</h2><p>查询 k-v 字符串。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GET message</span><br><span class="line">GET homepage</span><br><span class="line">GET price</span><br><span class="line"></span><br><span class="line">-- 不存在 addres，返回 nil</span><br><span class="line">GET address</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(1)</p>
<h2 id="MGET"><a href="#MGET" class="headerlink" title="MGET"></a>MGET</h2><p>查询多个 k-v 字符串。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 同时查询 name address school</span><br><span class="line">MGET name address school</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(n)</p>
<ul>
<li>提高操作效率；</li>
<li>方便多个 k-v 操作；</li>
</ul>
<h2 id="GETSET"><a href="#GETSET" class="headerlink" title="GETSET"></a>GETSET</h2><p>返回 k 对应的字符串，并设置新值。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 设置 number == 1</span><br><span class="line">SET number 1</span><br><span class="line">-- 返回 number == 1，同时设置 number == 2</span><br><span class="line">GETSET number 2</span><br><span class="line"></span><br><span class="line">-- number == 2</span><br><span class="line">GET number</span><br><span class="line"></span><br><span class="line">-- counter 不存在，返回 nil，同时设置 counter == 20</span><br><span class="line">GETSET counter 20</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(1)</p>
<h2 id="STRLEN"><a href="#STRLEN" class="headerlink" title="STRLEN"></a>STRLEN</h2><p>获取字符串长度。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 返回 len(name)</span><br><span class="line">STRLEN name</span><br><span class="line">-- 不存在，返回 0</span><br><span class="line">STRLEN gender</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(n)</p>
<h2 id="GETRANGE"><a href="#GETRANGE" class="headerlink" title="GETRANGE"></a>GETRANGE</h2><p>获取字符串索引指定闭区间的内容。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SET message &quot;hello world&quot;</span><br><span class="line">-- 获取 message[0,4]闭区间内容</span><br><span class="line">GETRANGE message 0 4</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(n)</p>
<h2 id="SETRANGE"><a href="#SETRANGE" class="headerlink" title="SETRANGE"></a>SETRANGE</h2><p>设置字符串指定索引开始的字符串。</p>
<p>当设置字符串 &gt; 当前字符串长度时，会自动扩容。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SET message &quot;hello world&quot;</span><br><span class="line"></span><br><span class="line">-- greet world</span><br><span class="line">SETRANGE message 0 &quot;greet&quot;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(n)</p>
<h2 id="APPEND"><a href="#APPEND" class="headerlink" title="APPEND"></a>APPEND</h2><p>k 存在时，就添加；不存在时，就执行 SET 操作。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SET message &quot;Redis&quot;</span><br><span class="line">-- APPEND</span><br><span class="line">APPEND message &quot; is a database&quot;</span><br><span class="line">GET message</span><br><span class="line"></span><br><span class="line">-- 类似于 SET</span><br><span class="line">APPEND name &quot;hanzhang&quot;</span><br><span class="line">GET name</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(n)</p>
<h1 id="存储方式"><a href="#存储方式" class="headerlink" title="存储方式"></a>存储方式</h1><p>如果 k-v 字符串中，v 能够使用 C 语言中 long long int 或者 long double 时，redis 可以把 v 当作数字来处理；否则都是字符串存储。</p>
<h2 id="INCR"><a href="#INCR" class="headerlink" title="INCR"></a>INCR</h2><p>自增 + 1。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SET num 100</span><br><span class="line">-- 101</span><br><span class="line">INCR num</span><br><span class="line"></span><br><span class="line">-- 不存在，会先初始化为 0，计算后返回</span><br><span class="line">-- 1</span><br><span class="line">INCR i</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(1)</p>
<h2 id="INCRBY"><a href="#INCRBY" class="headerlink" title="INCRBY"></a>INCRBY</h2><p>增加指定数字。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SET num 100</span><br><span class="line">-- 200</span><br><span class="line">INCRBY num 100</span><br><span class="line"></span><br><span class="line">-- 不存在，会先初始化为 0，计算后返回</span><br><span class="line">-- 10</span><br><span class="line">INCRBY i 10</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(1)</p>
<h2 id="INCRBYFLOAT"><a href="#INCRBYFLOAT" class="headerlink" title="INCRBYFLOAT"></a>INCRBYFLOAT</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SET num 100</span><br><span class="line">-- 103.14</span><br><span class="line">INCRBYFLOAT num 3.14</span><br><span class="line"></span><br><span class="line">-- 不存在，会先初始化为 0，计算后返回</span><br><span class="line">-- 3.14</span><br><span class="line">INCRBYFLOAT i 3.14</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(1)</p>
<h2 id="DECR"><a href="#DECR" class="headerlink" title="DECR"></a>DECR</h2><p>对应 INCR，只是减少。</p>
<h2 id="DECRBY"><a href="#DECRBY" class="headerlink" title="DECRBY"></a>DECRBY</h2><p>对应 INCRBY，只是减少。</p>
<h2 id="DECRBYFLOAT"><a href="#DECRBYFLOAT" class="headerlink" title="DECRBYFLOAT"></a>DECRBYFLOAT</h2><p>对应 INCRBYFLOAT，只是减少。</p>
<h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><h2 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h2><p>将数据存储再内存 Redis，而不是硬盘 MySQL。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">put</span><span class="params">(key, value <span class="type">string</span>, expiration <span class="type">int</span>)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">	rdb := redis.NewClient(&amp;redis.Options&#123;</span><br><span class="line">		Addr:     <span class="string">&quot;43.142.129.110:6379&quot;</span>,</span><br><span class="line">		Password: <span class="string">&quot;&quot;</span>, <span class="comment">// no password set</span></span><br><span class="line">		DB:       <span class="number">0</span>,  <span class="comment">// use default DB</span></span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> rdb.Set(context.Background(), key, value, <span class="number">0</span>).Err()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">get</span><span class="params">(key <span class="type">string</span>)</span></span> (<span class="type">string</span>, <span class="type">error</span>) &#123;</span><br><span class="line">	rdb := redis.NewClient(&amp;redis.Options&#123;</span><br><span class="line">		Addr:     <span class="string">&quot;43.142.129.110:6379&quot;</span>,</span><br><span class="line">		Password: <span class="string">&quot;&quot;</span>, <span class="comment">// no password set</span></span><br><span class="line">		DB:       <span class="number">0</span>,  <span class="comment">// use default DB</span></span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> rdb.Get(context.Background(), key).Result()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Test</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestPut</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">	err := put(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;hanzhang&quot;</span>, <span class="number">0</span>)</span><br><span class="line">	assert.Equal(t, <span class="literal">nil</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestGet</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">	value, err := get(<span class="string">&quot;name&quot;</span>)</span><br><span class="line">	assert.Equal(t, <span class="literal">nil</span>, err)</span><br><span class="line">	assert.Equal(t, <span class="string">&quot;hanzhang&quot;</span>, value)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h2><p>不同进程通过设置字符串键和删除字符串键来模拟获取锁和释放锁。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">acquire</span><span class="params">(key <span class="type">string</span>)</span></span> (<span class="type">bool</span>, <span class="type">error</span>) &#123;</span><br><span class="line">	rdb := redis.NewClient(&amp;redis.Options&#123;</span><br><span class="line">		Addr:     <span class="string">&quot;43.142.129.110:6379&quot;</span>,</span><br><span class="line">		Password: <span class="string">&quot;&quot;</span>, <span class="comment">// no password set</span></span><br><span class="line">		DB:       <span class="number">0</span>,  <span class="comment">// use default DB</span></span><br><span class="line">	&#125;)</span><br><span class="line">    <span class="comment">// NX 参数确保了代表锁的字符串键只有在没有值的情况下被设置</span></span><br><span class="line">	<span class="keyword">return</span> rdb.SetNX(context.Background(), key, <span class="string">&quot;locked&quot;</span>, <span class="number">0</span>).Result()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">release</span><span class="params">(key <span class="type">string</span>)</span></span> (<span class="type">int64</span>, <span class="type">error</span>) &#123;</span><br><span class="line">	rdb := redis.NewClient(&amp;redis.Options&#123;</span><br><span class="line">		Addr:     <span class="string">&quot;43.142.129.110:6379&quot;</span>,</span><br><span class="line">		Password: <span class="string">&quot;&quot;</span>, <span class="comment">// no password set</span></span><br><span class="line">		DB:       <span class="number">0</span>,  <span class="comment">// use default DB</span></span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> rdb.Del(context.Background(), key).Result()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Test</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestAcquire</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">	b, err := acquire(<span class="string">&quot;lock&quot;</span>)</span><br><span class="line">	assert.Nil(t, err)</span><br><span class="line">	assert.True(t, b)</span><br><span class="line">	b, err = acquire(<span class="string">&quot;lock&quot;</span>)</span><br><span class="line">	assert.Nil(t, err)</span><br><span class="line">	assert.False(t, b)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestRelease</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">	i, err := release(<span class="string">&quot;lock&quot;</span>)</span><br><span class="line">	assert.Nil(t, err)</span><br><span class="line">	assert.NotEqual(t, <span class="number">0</span>, i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>无法保证该锁只能是锁的持有者才能释放；</li>
<li>无法设置锁超时时间；</li>
</ul>
<h2 id="保存-Blog"><a href="#保存-Blog" class="headerlink" title="保存 Blog"></a>保存 Blog</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SaveBlog</span><span class="params">(title, author <span class="type">string</span>, id <span class="type">int</span>)</span></span> (<span class="type">bool</span>, <span class="type">error</span>) &#123;</span><br><span class="line">   rdb := redis.NewClient(&amp;redis.Options&#123;</span><br><span class="line">      Addr:     <span class="string">&quot;43.142.129.110:6379&quot;</span>,</span><br><span class="line">      Password: <span class="string">&quot;&quot;</span>, <span class="comment">// no password set</span></span><br><span class="line">      DB:       <span class="number">0</span>,  <span class="comment">// use default DB</span></span><br><span class="line">   &#125;)</span><br><span class="line"></span><br><span class="line">   values := <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>&#123;</span><br><span class="line">      <span class="string">&quot;blog::&quot;</span> + strconv.Itoa(id) + <span class="string">&quot;::id&quot;</span>:     strconv.Itoa(id),</span><br><span class="line">      <span class="string">&quot;blog::&quot;</span> + strconv.Itoa(id) + <span class="string">&quot;::title&quot;</span>:  title,</span><br><span class="line">      <span class="string">&quot;blog::&quot;</span> + strconv.Itoa(id) + <span class="string">&quot;::author&quot;</span>: author,</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> rdb.MSetNX(context.Background(), values).Result()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetBlog</span><span class="params">(id <span class="type">int</span>)</span></span> ([]<span class="keyword">interface</span>&#123;&#125;, <span class="type">error</span>) &#123;</span><br><span class="line">   rdb := redis.NewClient(&amp;redis.Options&#123;</span><br><span class="line">      Addr:     <span class="string">&quot;43.142.129.110:6379&quot;</span>,</span><br><span class="line">      Password: <span class="string">&quot;&quot;</span>, <span class="comment">// no password set</span></span><br><span class="line">      DB:       <span class="number">0</span>,  <span class="comment">// use default DB</span></span><br><span class="line">   &#125;)</span><br><span class="line">   <span class="keyword">return</span> rdb.MGet(context.Background(),</span><br><span class="line">      <span class="string">&quot;blog::&quot;</span>+strconv.Itoa(id)+<span class="string">&quot;::id&quot;</span>,</span><br><span class="line">      <span class="string">&quot;blog::&quot;</span>+strconv.Itoa(id)+<span class="string">&quot;::title&quot;</span>,</span><br><span class="line">      <span class="string">&quot;blog::&quot;</span>+strconv.Itoa(id)+<span class="string">&quot;::author&quot;</span>).Result()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Test</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestSaveBlog</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">	b, err := SaveBlog(<span class="string">&quot;redis-string&quot;</span>, <span class="string">&quot;hanzhang&quot;</span>, <span class="number">1</span>)</span><br><span class="line">	assert.Nil(t, err)</span><br><span class="line">	assert.True(t, b)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestGetBlog</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">	blog, err := GetBlog(<span class="number">1</span>)</span><br><span class="line">	assert.Nil(t, err)</span><br><span class="line">	fmt.Println(blog)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul>
<li>k 和 v 都是既可以存储二进制，又可以存储字符串；</li>
<li>SET、SETNX 和 SETXX；</li>
<li>MSET、MSETNX 和 MGET 可以减少网络请求，提升程序效率；</li>
<li>字符串值中正数索引 0 开始，负数索引 -1 开始；</li>
<li>GETRANGE 是返回索引闭区间；</li>
<li>SETRANGE 当长度不够时，会自动扩展；</li>
<li>APPEND 处理键不存在时执行 SET；键存在时，执行 APPEND；</li>
<li>字符串值满足 C 语言中 long long int 或者 long double 时，当作数字来处理；</li>
</ul>
]]></content>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>冒泡排序</title>
    <url>/2023/05/03/bubble-sort/</url>
    <content><![CDATA[<h1 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h1><p>冒泡排序会从头开始依次比较 2 个相邻元素的大小，如果顺序错误就交换，直到没有相邻元素需要交换，即排序完成。每进行一次循环，就会有固定一个排序元素到末尾。</p>
<h1 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h1><ul>
<li>由于末尾是目标位置，所以不用放在循环中；</li>
<li>使用 flag 来描述一次循环是否有需要交换的元素，如果没交换，说明已经有序，则不用接下来的循环。</li>
</ul>
<h1 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h1><p>O(n^2)</p>
<h1 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h1><p><a href="https://github.com/hanzhang2566/data-structures-and-algorithms-examples/blob/main/go-ds-and-algorithms/sort/bubble_sort_test.go">golang</a></p>
<p><a href="https://github.com/hanzhang2566/data-structures-and-algorithms-examples/blob/main/java-ds-and-algorithms/src/main/java/sort/BubbleSort.java">java</a></p>
]]></content>
      <tags>
        <tag>data structure and algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>选择排序</title>
    <url>/2023/05/03/selection-sort/</url>
    <content><![CDATA[<h1 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h1><p>选择排序首先会找到数组中最小的元素；其次，交换它和第一个元素；再其次，在剩下的元素中找到最小的元素，将它与数组的第二个元素交换。</p>
<p>如此往复，直到将整个数组排序。</p>
<h1 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h1><ul>
<li>由于需要寻找最小的，所以每个元素都需要比较；</li>
<li>冒泡排序是比较后，满足要求就交换；而选择排序是先比较一轮，最后只交换一次。所以选择排序的步数大概只有冒泡排序的一般，即选择排序比冒泡排序快一倍。</li>
</ul>
<h1 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h1><p>O(n^2)</p>
<h1 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h1><p><a href="https://github.com/hanzhang2566/data-structures-and-algorithms-examples/blob/main/go-ds-and-algorithms/sort/selection_sort_test.go">golang</a></p>
<p><a href="https://github.com/hanzhang2566/data-structures-and-algorithms-examples/blob/main/java-ds-and-algorithms/src/test/java/sort/SelectionSortTest.java">java</a></p>
]]></content>
      <tags>
        <tag>data structure and algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>抽象工厂模式</title>
    <url>/2023/05/03/creational-factory-abstract/</url>
    <content><![CDATA[<h1 id="模式描述"><a href="#模式描述" class="headerlink" title="模式描述"></a>模式描述</h1><p>提供一个创建一系列相关或相互依赖对象的接口，无需指定他们具体的类。</p>
<h1 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h1><ol>
<li>分离了具体的产品类；</li>
<li>有利于产品一致性；</li>
</ol>
<h1 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h1><ol>
<li>难以扩展抽象工厂</li>
</ol>
<h1 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h1><ol>
<li>一个系统要独立产品的创建、组合和表示；</li>
<li>一个系统要由多个产品系列中的一个来配置；</li>
<li>提供一个产品库，只显示接口而非实现；</li>
</ol>
<span id="more"></span>

<table>
<thead>
<tr>
<th align="center">DATE</th>
<th align="center">CHANGELOG</th>
</tr>
</thead>
</table>
<h1 id="UML-类图"><a href="#UML-类图" class="headerlink" title="UML 类图"></a>UML 类图</h1><pre><code class="highlight mermaid">classDiagram

class AbstractFactory &#123;
	&lt;&lt;interface&gt;&gt;
	createProductA()
	createProductB()
&#125;

class ConcreteFactoryA &#123;
	createProductA()
	createProductB()
&#125;

class ConcreteFactoryB &#123;
	createProductA()
	createProductB()
&#125;
AbstractFactory &lt;|.. ConcreteFactoryA
AbstractFactory &lt;|.. ConcreteFactoryB

class AbstractProduct &#123;
	&lt;&lt;interface&gt;&gt;
	operator()
&#125;

class ConcreteProductA &#123;
	operator()
&#125;

class ConcreteProductB &#123;
	operator()
&#125;
AbstractProduct &lt;|.. ConcreteProductA
AbstractProduct &lt;|.. ConcreteProductB

ConcreteFactoryA &lt;-- ConcreteProductA
ConcreteFactoryB &lt;-- ConcreteProductB

AbstractFactory &lt;-- Client
AbstractProduct &lt;-- Client</code></pre>

<h1 id="参与者"><a href="#参与者" class="headerlink" title="参与者"></a>参与者</h1><h2 id="AbstractFactory"><a href="#AbstractFactory" class="headerlink" title="AbstractFactory"></a>AbstractFactory</h2><ul>
<li>声明创建抽象产品的方法</li>
</ul>
<h2 id="ConcreteFactoryX"><a href="#ConcreteFactoryX" class="headerlink" title="ConcreteFactoryX"></a>ConcreteFactoryX</h2><ul>
<li>AbstractFactory 的实现;</li>
</ul>
<h2 id="AbstractProduct"><a href="#AbstractProduct" class="headerlink" title="AbstractProduct"></a>AbstractProduct</h2><ul>
<li>为一类产品对象声明方法；</li>
</ul>
<h2 id="ConcreteProductX"><a href="#ConcreteProductX" class="headerlink" title="ConcreteProductX"></a>ConcreteProductX</h2><ul>
<li>AbstractProduct 的实现；</li>
</ul>
<h2 id="Client-类"><a href="#Client-类" class="headerlink" title="Client 类"></a>Client 类</h2><p>客户端。</p>
<h1 id="数据流"><a href="#数据流" class="headerlink" title="数据流"></a>数据流</h1><ol>
<li>客户端通常创建一个 ConcreteFactory 对象，用来创建对应的 Product；</li>
<li>AbstractFactory 将对象创建延迟到 ConcreteFactory 中；</li>
</ol>
<h1 id="相关模式"><a href="#相关模式" class="headerlink" title="相关模式"></a>相关模式</h1><ul>
<li>工厂方法模式：抽象工厂常用工厂方法实现；</li>
<li>原型模式：抽象工厂也能用原型模式实现；</li>
<li>单例模式：一个具体的工厂是单例的；</li>
</ul>
<h1 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h1><h1 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h1><p><a href="https://github.com/hanzhang2566/design-patterns-examples/blob/main/go-patterns/creational/factory/abs/repository_factory_test.go">golang</a></p>
<p><a href="https://github.com/hanzhang2566/design-patterns-examples/blob/main/java-patterns/src/test/java/creational/factory/abs/ClientTest.java">java</a></p>
]]></content>
      <tags>
        <tag>design pattern</tag>
      </tags>
  </entry>
  <entry>
    <title>观察者模式</title>
    <url>/2023/05/02/behavioral-observer/</url>
    <content><![CDATA[<h1 id="模式描述"><a href="#模式描述" class="headerlink" title="模式描述"></a>模式描述</h1><p>定义对象间的一对多关系，当一个对象的状态发生改变时，所有依赖与它的对象都得到通知并自动被更新。</p>
<h1 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h1><ol>
<li>目标和观察者解耦；</li>
<li>支持对观察者的广播通讯；</li>
</ol>
<h1 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h1><ol>
<li>依赖准则的定义和维护不当，会引起错误更新，而且很难排查；</li>
</ol>
<h1 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h1><ol>
<li>一个对象改变，其他待定的对象同时需要改变；</li>
<li>解耦 1 个模型中，相互依赖的 2 个方面；</li>
<li></li>
</ol>
<span id="more"></span>

<table>
<thead>
<tr>
<th align="center">DATE</th>
<th align="center">CHANGELOG</th>
</tr>
</thead>
<tbody><tr>
<td align="center">2023年5月2日</td>
<td align="center">代码完成</td>
</tr>
<tr>
<td align="center">2023年5月3日</td>
<td align="center">补充文档</td>
</tr>
</tbody></table>
<h1 id="UML-类图"><a href="#UML-类图" class="headerlink" title="UML 类图"></a>UML 类图</h1><pre><code class="highlight mermaid">classDiagram

class Subject &#123;
	&lt;&lt;interface&gt;&gt;
	attach(Observer observer)
	detach(Observer observer)
	notify()
	getState() String
	setState(String state)
&#125;

class ConcreteSubjectA &#123;
	attach(Observer observer)
	detach(Observer observer)
	notify()
    getState() String
	setState(String state)
&#125;

class ConcreteSubjectB &#123;
	attach(Observer observer)
	detach(Observer observer)
	notify()
    getState() String
	setState(String state)
&#125;
Subject &lt;|.. ConcreteSubjectA
Subject &lt;|.. ConcreteSubjectB

class Observer &#123;
	&lt;&lt;interface&gt;&gt;
	update()
&#125;

class ConcreteObserverA &#123;
    update()
&#125;

class ConcreteObserverB &#123;
    update()
&#125;
Observer &lt;|.. ConcreteObserverA
Observer &lt;|.. ConcreteObserverB

Subject o.. Observer
Observer o.. Subject

Subject &lt;-- Client
Observer &lt;-- Client</code></pre>

<h1 id="参与者"><a href="#参与者" class="headerlink" title="参与者"></a>参与者</h1><h2 id="Subject"><a href="#Subject" class="headerlink" title="Subject"></a>Subject</h2><ul>
<li>提供注册和删除观察者的方法；</li>
</ul>
<h2 id="Observer"><a href="#Observer" class="headerlink" title="Observer"></a>Observer</h2><ul>
<li>定义 Subject 发生改变时，更新 Observer 的方法；</li>
</ul>
<h2 id="ConcreteSubject"><a href="#ConcreteSubject" class="headerlink" title="ConcreteSubject"></a>ConcreteSubject</h2><ul>
<li>Subject 的实现；</li>
<li>持有 Observer 对象的集合，当 Subject 改变时，向每个对象发出通知；</li>
</ul>
<h2 id="ConcreteObserver"><a href="#ConcreteObserver" class="headerlink" title="ConcreteObserver"></a>ConcreteObserver</h2><ul>
<li>Observer 的实现；</li>
<li>持有 Subject 对象，使得自身状态和 Subject 状态保持一致；</li>
</ul>
<h2 id="Client"><a href="#Client" class="headerlink" title="Client"></a>Client</h2><p>客户端。</p>
<h1 id="数据流"><a href="#数据流" class="headerlink" title="数据流"></a>数据流</h1><pre><code class="highlight mermaid">sequenceDiagram
    aConcreteSubject -&gt;&gt; concreteObserverA: setState()
    activate concreteObserverA
    deactivate concreteObserverA
    aConcreteSubject -&gt;&gt; aConcreteSubject: notify()
    
    aConcreteSubject -&gt;&gt; concreteObserverA:update()
    activate concreteObserverA
    concreteObserverA -&gt;&gt; aConcreteSubject:getState()
    deactivate concreteObserverA
    
    aConcreteSubject -&gt;&gt; concreteObserverB:update()
    activate concreteObserverB
    concreteObserverB -&gt;&gt; aConcreteSubject:getState()
    deactivate concreteObserverB</code></pre>



<h1 id="相关模式"><a href="#相关模式" class="headerlink" title="相关模式"></a>相关模式</h1><ul>
<li>中介者模式：通过封装复杂的更新语义，ChangeManager 充当目标和观察者之间的中介者；</li>
<li>单例模式：ChangeManager 可使用 Singleton 模式来保证它是唯一的并且可是全局访问；</li>
</ul>
<h1 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h1><ul>
<li>这只是最简单的模型；</li>
</ul>
<h1 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h1><p><a href="https://github.com/hanzhang2566/design-patterns-examples/blob/main/go-patterns/behavioral/observer/observer_test.go">golang</a></p>
<p><a href="https://github.com/hanzhang2566/design-patterns-examples/blob/main/java-patterns/src/test/java/behavioral/observer/ClientTest.java">java</a></p>
]]></content>
      <tags>
        <tag>design pattern</tag>
      </tags>
  </entry>
  <entry>
    <title>我的 Intellij IDEA 设置</title>
    <url>/2023/05/02/idea/</url>
    <content><![CDATA[<p>IDEA 是 jetbrains 为 Javaer 打造的 IDE，我基本上 Java、Golang、Python 和 JS 等都用它来编写。</p>
<p>我使用 <a href="https://www.jetbrains.com.cn/toolbox-app/">Toolbox</a> 来管理 jetbrains 的所有产品。</p>
<h1 id="版本"><a href="#版本" class="headerlink" title="版本"></a>版本</h1><p>IntelliJ IDEA 2022.3.3</p>
<span id="more"></span>

<table>
<thead>
<tr>
<th align="center">DATE</th>
<th align="center">CHANGELOG</th>
</tr>
</thead>
<tbody><tr>
<td align="center">2023年5月2日</td>
<td align="center">初始化</td>
</tr>
<tr>
<td align="center">2023年5月13日</td>
<td align="center">添加 File Structure 快捷键</td>
</tr>
</tbody></table>
<h1 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h1><h2 id="强烈推荐"><a href="#强烈推荐" class="headerlink" title="强烈推荐"></a>强烈推荐</h2><p><a href="https://plugins.jetbrains.com/plugin/18824-codeglance-pro">CodeGlance Pro</a>：代码小地图；</p>
<p><a href="https://plugins.jetbrains.com/plugin/9861-git-commit-template">Git Commit Template</a>：提供 git commit message 的模板，该模板是符合 angular commit msg 提交规范（被很多项目采用）；</p>
<p><a href="https://plugins.jetbrains.com/plugin/7499-gittoolbox">GitToolBox</a>：扩展了 idea 继承 git 的功能；</p>
<p><a href="https://plugins.jetbrains.com/plugin/9568-go">Go</a>：编写 Go 语言的扩展；</p>
<p><a href="https://plugins.jetbrains.com/plugin/7179-maven-helper">Maven Helper</a>：用来查看 maven 中依赖的插件；</p>
<p><a href="https://plugins.jetbrains.com/plugin/10119-mybatisx">MyBatisX</a>：提供 mabatis 的支持；</p>
<p><a href="https://plugins.jetbrains.com/plugin/631-python">Python</a>：编写 Python 语言的扩展；</p>
<p><a href="https://plugins.jetbrains.com/plugin/10080-rainbow-brackets">Rainbow Barckets</a>：彩虹括号；</p>
<p><a href="https://plugins.jetbrains.com/plugin/10837-requirements">Requirements</a>：Python 中 pip 依赖的支持；</p>
<p><a href="https://plugins.jetbrains.com/plugin/14280-restfultool">RestfulTool</a>：快速查看 Spring 中 Restful 接口；</p>
<p><a href="https://plugins.jetbrains.com/plugin/7973-sonarlint">SonarLint</a>：静态代码检查；</p>
<p><a href="https://plugins.jetbrains.com/plugin/12798-tabnine-ai-code-completion-js-java-python-ts-rust-go-php--more">Tabnine </a>：Copilot 的替代；</p>
<h2 id="推荐使用"><a href="#推荐使用" class="headerlink" title="推荐使用"></a>推荐使用</h2><p><a href="https://plugins.jetbrains.com/plugin/17718-github-copilot">GitHub Copilot</a>：我登录不上去，能登录上的推荐；</p>
<p><a href="https://plugins.jetbrains.com/plugin/7177-file-watchers">File Watchers</a>：文件修改后触发操作；</p>
<p><a href="https://plugins.jetbrains.com/plugin/7125-grep-console">Grep Console</a>：高亮标准输出；</p>
<p><a href="https://plugins.jetbrains.com/plugin/13873-json-helper">Json Helper</a>：JSON 类型转换；</p>
<p><a href="https://plugins.jetbrains.com/plugin/12132-leetcode-editor">LeetCode Editor</a>：一直供着不敢删除；</p>
<h1 id="高频快捷键"><a href="#高频快捷键" class="headerlink" title="高频快捷键"></a>高频快捷键</h1><table>
<thead>
<tr>
<th align="center">action</th>
<th align="center">shortcut</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Settings</td>
<td align="center">Ctrl + Alt + S</td>
<td align="center">打开设置</td>
</tr>
<tr>
<td align="center">Project Structure</td>
<td align="center">Ctrl + Shift + Alt + S</td>
<td align="center">打开项目结构</td>
</tr>
<tr>
<td align="center">Project</td>
<td align="center">Alt + 1</td>
<td align="center">查看项目</td>
</tr>
<tr>
<td align="center">Database</td>
<td align="center">Alt + 2</td>
<td align="center">查看数据库</td>
</tr>
<tr>
<td align="center">Structure</td>
<td align="center">Alt + 7</td>
<td align="center">查看文件结构</td>
</tr>
<tr>
<td align="center">Parameter Info</td>
<td align="center">Alt + P</td>
<td align="center">查看方法参数信息</td>
</tr>
<tr>
<td align="center">Terminal</td>
<td align="center">Alt + F12</td>
<td align="center">打开终端</td>
</tr>
<tr>
<td align="center">Move Caret to Line Start</td>
<td align="center">Alt + 向左箭头</td>
<td align="center">光标到行头</td>
</tr>
<tr>
<td align="center">Move Caret to Line End</td>
<td align="center">Alt + 向右箭头</td>
<td align="center">光标到行尾</td>
</tr>
<tr>
<td align="center">Delete Line</td>
<td align="center">Alt + Backspace</td>
<td align="center">删除一行</td>
</tr>
<tr>
<td align="center">Split Line</td>
<td align="center">Ctrl + Enter</td>
<td align="center">光标到下一行</td>
</tr>
<tr>
<td align="center">Select Tab #1-6</td>
<td align="center">Ctrl + 1-6</td>
<td align="center">选择 1-6 编号的 Tab</td>
</tr>
<tr>
<td align="center">Up</td>
<td align="center">Ctrl + P</td>
<td align="center">光标向上一行</td>
</tr>
<tr>
<td align="center">Commit</td>
<td align="center">Ctrl + K</td>
<td align="center">提交</td>
</tr>
<tr>
<td align="center">Down</td>
<td align="center">Ctrl + N</td>
<td align="center">光标向下一行</td>
</tr>
<tr>
<td align="center">Duplicate Line or Selection</td>
<td align="center">Ctrl + D</td>
<td align="center">复制一行</td>
</tr>
<tr>
<td align="center">Close Tab</td>
<td align="center">Ctrl + W</td>
<td align="center">关闭 Tab</td>
</tr>
<tr>
<td align="center">Split and Move Right</td>
<td align="center">Ctrl + \</td>
<td align="center">右分割</td>
</tr>
<tr>
<td align="center">Undo</td>
<td align="center">Ctrl + Z</td>
<td align="center">撤销</td>
</tr>
<tr>
<td align="center">File Structure</td>
<td align="center">Ctrl + F12</td>
<td align="center">查看文件结构</td>
</tr>
<tr>
<td align="center">Redo</td>
<td align="center">Ctrl + Shift + Z</td>
<td align="center">反撤销</td>
</tr>
<tr>
<td align="center">Rollback</td>
<td align="center">Ctrl + Alt + Z</td>
<td align="center">回滚改动</td>
</tr>
</tbody></table>
<h1 id="Live-Templates"><a href="#Live-Templates" class="headerlink" title="Live Templates"></a>Live Templates</h1><h2 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h2><table>
<thead>
<tr>
<th align="center">shortcut</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">fori</td>
<td align="center">for (int i &#x3D; 0; i &lt; param; i++) {}</td>
</tr>
<tr>
<td align="center">iter</td>
<td align="center">for range loop</td>
</tr>
<tr>
<td align="center">souf</td>
<td align="center">System.out.printf();</td>
</tr>
<tr>
<td align="center">sout</td>
<td align="center">System.out.println();</td>
</tr>
<tr>
<td align="center">souc</td>
<td align="center">System.out::println</td>
</tr>
<tr>
<td align="center">soutm</td>
<td align="center">System.out.println(“$CLASS_NAME$.$METHOD_NAME$”);</td>
</tr>
<tr>
<td align="center">soutv</td>
<td align="center">System.out.println(“$EXPR_COPY$ &#x3D; “ + $EXPR$);</td>
</tr>
<tr>
<td align="center">thr</td>
<td align="center">throw new</td>
</tr>
</tbody></table>
<h2 id="Go"><a href="#Go" class="headerlink" title="Go"></a>Go</h2><table>
<thead>
<tr>
<th align="center">shortcut</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">fori</td>
<td align="center">for i:&#x3D;0; i &lt; param; i++ {}</td>
</tr>
<tr>
<td align="center">iter</td>
<td align="center">for range loop</td>
</tr>
<tr>
<td align="center">err</td>
<td align="center">if err !&#x3D; nil {}</td>
</tr>
</tbody></table>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>Help - Keyboard Shortcuts PDF</p>
<p><a href="https://www.jetbrains.com/idea/">下载</a></p>
]]></content>
      <tags>
        <tag>tool</tag>
      </tags>
  </entry>
  <entry>
    <title>Typora 中 Mermaid 的使用</title>
    <url>/2023/05/01/mermaid/</url>
    <content><![CDATA[<p>Mermaid 可以在 Markdown 中用文本和代码的方式创建可视化图表。包括但不限于：流程图（Flowchart）、时序图（Sequence Diagram）、类图（Class Diagram）、ER 图（Entity-Relationship Diagram）等。</p>
<h1 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h1><ul>
<li>使用文本和代码的方式绘图，无需关心元素排布，JS 引擎会自动渲染；</li>
<li>极客属性；</li>
<li>广泛。有 md 文件就可以绘图；</li>
</ul>
<h1 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h1><ul>
<li>写图需要配合文档，曲线高；</li>
<li>不能自定义元素排布；</li>
</ul>
<h1 id="如何开始"><a href="#如何开始" class="headerlink" title="如何开始"></a>如何开始</h1><ol>
<li>明确是否使用 mermaid 写图；</li>
<li>决定图表类型，打开 <a href="https://mermaid.js.org/config/Tutorials.html">mermaid tutorials</a> 对应图表文档；</li>
<li>复制一份官方图表模板；</li>
<li>查看官网的语法样式，选择自己需要的进行绘制；</li>
</ol>
<span id="more"></span>

<table>
<thead>
<tr>
<th align="center">DATE</th>
<th align="center">CHANGELOG</th>
</tr>
</thead>
<tbody><tr>
<td align="center">2023年5月1日</td>
<td align="center">初始化</td>
</tr>
<tr>
<td align="center">2023年5月16日</td>
<td align="center">修改标题</td>
</tr>
</tbody></table>
<h1 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h1><h2 id="文档"><a href="#文档" class="headerlink" title="文档"></a>文档</h2><p><a href="https://mermaid.js.org/syntax/flowchart.html">here</a></p>
<h2 id="声明和方向"><a href="#声明和方向" class="headerlink" title="声明和方向"></a>声明和方向</h2><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">flowchart LR</span><br></pre></td></tr></table></figure>

<h2 id="节点形状"><a href="#节点形状" class="headerlink" title="节点形状"></a>节点形状</h2><p><a href="https://mermaid.js.org/syntax/flowchart.html#node-shapes">here</a></p>
<h2 id="节点连接"><a href="#节点连接" class="headerlink" title="节点连接"></a>节点连接</h2><p><a href="https://mermaid.js.org/syntax/flowchart.html#links-between-nodes">here</a></p>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><pre><code class="highlight mermaid">flowchart TD
    A[Christmas] --&gt;|Get money| B(Go shopping)
    B --&gt; C&#123;Let me think&#125;
    C --&gt;|One| D[Laptop]
    C --&gt;|Two| E[iPhone]
    C --&gt;|Three| F[fa:fa-car Car]</code></pre>

<h1 id="时序图"><a href="#时序图" class="headerlink" title="时序图"></a>时序图</h1><h2 id="文档-1"><a href="#文档-1" class="headerlink" title="文档"></a>文档</h2><p><a href="https://mermaid.js.org/syntax/sequenceDiagram.html">here</a></p>
<h2 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h2><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">sequenceDiagram</span><br></pre></td></tr></table></figure>

<h2 id="参与者"><a href="#参与者" class="headerlink" title="参与者"></a>参与者</h2><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">participant</span><br></pre></td></tr></table></figure>

<h2 id="消息连接"><a href="#消息连接" class="headerlink" title="消息连接"></a>消息连接</h2><p><a href="https://mermaid.js.org/syntax/sequenceDiagram.html#messages">here</a></p>
<h2 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h2><pre><code class="highlight mermaid">sequenceDiagram
    Alice-&gt;&gt;+John: Hello John, how are you?
    Alice-&gt;&gt;+John: John, can you hear me?
    John--&gt;&gt;-Alice: Hi Alice, I can hear you!
    John--&gt;&gt;-Alice: I feel great!</code></pre>





<h1 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h1><h2 id="文档-2"><a href="#文档-2" class="headerlink" title="文档"></a>文档</h2><p><a href="https://mermaid.js.org/syntax/classDiagram.html">here</a></p>
<h2 id="声明-1"><a href="#声明-1" class="headerlink" title="声明"></a>声明</h2><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">classDiagram</span><br></pre></td></tr></table></figure>

<h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">class Animal &#123;</span><br><span class="line">    +int age</span><br><span class="line">    +String gender</span><br><span class="line">    +isMammal()</span><br><span class="line">    +mate()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="接口和抽象类"><a href="#接口和抽象类" class="headerlink" title="接口和抽象类"></a>接口和抽象类</h2><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">class Runnable &#123;</span><br><span class="line">	&lt;&lt;interface&gt;&gt;</span><br><span class="line">	run() void</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class BaseEntity &#123;</span><br><span class="line">	&lt;&lt;abstract&gt;&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="关系"><a href="#关系" class="headerlink" title="关系"></a>关系</h2><p><a href="https://mermaid.js.org/syntax/classDiagram.html#defining-relationship">here</a></p>
<h2 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a>示例</h2><pre><code class="highlight mermaid">classDiagram
	class Animal &#123;
		+int age
		+String gender
		+isMammal()
		+mate()
	&#125;
    class Duck&#123;
      +String beakColor
      +swim()
      +quack()
    &#125;
    class Fish&#123;
      -int sizeInFeet
      -canEat()
    &#125;
    class Zebra&#123;
      +bool is_wild
      +run()
    &#125;
    Animal &lt;|-- Duck
    Animal &lt;|-- Fish
    Animal &lt;|-- Zebra</code></pre>

<h1 id="ER-图"><a href="#ER-图" class="headerlink" title="ER 图"></a>ER 图</h1><h2 id="文档-3"><a href="#文档-3" class="headerlink" title="文档"></a>文档</h2><p><a href="https://mermaid.js.org/syntax/entityRelationshipDiagram.html">here</a></p>
<h2 id="示例-3"><a href="#示例-3" class="headerlink" title="示例"></a>示例</h2><pre><code class="highlight mermaid">erDiagram
    CUSTOMER &#125;|..|&#123; DELIVERY-ADDRESS : has
    CUSTOMER ||--o&#123; ORDER : places
    CUSTOMER ||--o&#123; INVOICE : &quot;liable for&quot;
    DELIVERY-ADDRESS ||--o&#123; ORDER : receives
    INVOICE ||--|&#123; ORDER : covers
    ORDER ||--|&#123; ORDER-ITEM : includes
    PRODUCT-CATEGORY ||--|&#123; PRODUCT : contains
    PRODUCT ||--o&#123; ORDER-ITEM : &quot;ordered in&quot;</code></pre>

<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://mermaid.js.org/">mermaid</a></p>
<p><a href="https://mermaid.js.org/config/Tutorials.html">tutorials</a></p>
<p><a href="https://mermaid.live/edit">live editor</a></p>
]]></content>
      <tags>
        <tag>tool</tag>
      </tags>
  </entry>
  <entry>
    <title>建造者模式</title>
    <url>/2023/05/01/creational-builder/</url>
    <content><![CDATA[<h1 id="模式描述"><a href="#模式描述" class="headerlink" title="模式描述"></a>模式描述</h1><p>将一个复杂对象的构建和表示分离，使得同样的构建过程可以创建出不同对象。</p>
<h1 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h1><ol>
<li>避免构造器参数太多，按需构造；</li>
<li>避免 setter 方法，使对象不可变；</li>
<li>构造和表示代码分开；</li>
<li>更精细控制构造过程；</li>
</ol>
<h1 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h1><h1 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h1><ol>
<li>复杂对象的创建独立于创建对象的组成部分时；</li>
<li>需要按需构造时；</li>
</ol>
<span id="more"></span>

<table>
<thead>
<tr>
<th align="center">DATE</th>
<th align="center">CHANGELOG</th>
</tr>
</thead>
<tbody><tr>
<td align="center">2023年5月1日</td>
<td align="center">初始化</td>
</tr>
</tbody></table>
<h1 id="UML-类图"><a href="#UML-类图" class="headerlink" title="UML 类图"></a>UML 类图</h1><pre><code class="highlight mermaid">classDiagram

class Builder &#123;
	&lt;&lt;static&gt;&gt;
	setXxx()
	build() Product
&#125;

class Product &#123;
	-Product()
&#125;

Builder &lt;-- Product
Builder &lt;-- Client</code></pre>

<h1 id="参与者"><a href="#参与者" class="headerlink" title="参与者"></a>参与者</h1><h2 id="Builder-类"><a href="#Builder-类" class="headerlink" title="Builder 类"></a>Builder 类</h2><ul>
<li>使用 builder 创建一个 Product</li>
</ul>
<h2 id="Product-类"><a href="#Product-类" class="headerlink" title="Product 类"></a>Product 类</h2><ul>
<li>产品类。</li>
</ul>
<h2 id="Client-类"><a href="#Client-类" class="headerlink" title="Client 类"></a>Client 类</h2><p>客户端。</p>
<h1 id="数据流"><a href="#数据流" class="headerlink" title="数据流"></a>数据流</h1><h1 id="相关模式"><a href="#相关模式" class="headerlink" title="相关模式"></a>相关模式</h1><ul>
<li>抽象工厂：建造者模式是一步一步建造，并通过 build 方法返回；而抽象工厂是立刻返回；</li>
<li>组合模式：组合模式通常是 Builder 模式生成的。</li>
</ul>
<h1 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h1><ul>
<li>Builder 往往是静态的，也可以是一个接口；</li>
</ul>
<h1 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h1><p><a href="https://github.com/hanzhang2566/design-patterns-examples/blob/main/go-patterns/creational/builder/builder_test.go">golang</a></p>
<p><a href="https://github.com/hanzhang2566/design-patterns-examples/blob/main/java-patterns/src/test/java/creational/builder/ClientTest.java">java</a></p>
]]></content>
      <tags>
        <tag>design pattern</tag>
      </tags>
  </entry>
  <entry>
    <title>门面模式</title>
    <url>/2023/04/30/structural-facade/</url>
    <content><![CDATA[<h1 id="模式描述"><a href="#模式描述" class="headerlink" title="模式描述"></a>模式描述</h1><p>门面模式(Facade)模式，为子系统提供一组统一的接口，定义一组高层接口让子系统更易用，这个接口使得子系统更容易使用。</p>
<h1 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h1><ol>
<li>屏蔽了子系统组件；</li>
<li>拆分用户和子系统；</li>
</ol>
<h1 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h1><h1 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h1><ol>
<li>解决易用性问题。例如 Linux 系统提供的系统调用函数等；</li>
<li>解决性能问题。</li>
<li>解决分布式事务问题。</li>
<li>拆分客户端和实现之间的依赖；</li>
</ol>
<span id="more"></span>

<table>
<thead>
<tr>
<th align="center">DATE</th>
<th align="center">CHANGELOG</th>
</tr>
</thead>
<tbody><tr>
<td align="center">2023年4月30日</td>
<td align="center">初始化</td>
</tr>
<tr>
<td align="center">2023年5月1日</td>
<td align="center">添加 Go 语言实现</td>
</tr>
</tbody></table>
<h1 id="UML-类图"><a href="#UML-类图" class="headerlink" title="UML 类图"></a>UML 类图</h1><pre><code class="highlight mermaid">classDiagram

class Facade &#123;
	&lt;&lt;interface&gt;&gt;
	operator()
&#125;

class ConcreteFacade &#123;
	operator()
&#125;

Facade &lt;|.. ConcreteFacade

ConcreteFacade o.. SubSystem1
ConcreteFacade o.. SubSystem2

Facade &lt;-- Client</code></pre>

<h1 id="参与者"><a href="#参与者" class="headerlink" title="参与者"></a>参与者</h1><h2 id="Facade-接口"><a href="#Facade-接口" class="headerlink" title="Facade 接口"></a>Facade 接口</h2><ul>
<li>向 Client 提供处理任务的接口；</li>
<li>组合 SubSystemX 功能；</li>
</ul>
<h2 id="ConcreteFacade-类"><a href="#ConcreteFacade-类" class="headerlink" title="ConcreteFacade 类"></a>ConcreteFacade 类</h2><ul>
<li>facade 接口的实现；</li>
</ul>
<h2 id="SubSystemX"><a href="#SubSystemX" class="headerlink" title="SubSystemX"></a>SubSystemX</h2><ul>
<li>子系统</li>
</ul>
<h2 id="Client-类"><a href="#Client-类" class="headerlink" title="Client 类"></a>Client 类</h2><ul>
<li>客户端</li>
</ul>
<h1 id="数据流"><a href="#数据流" class="headerlink" title="数据流"></a>数据流</h1><ol>
<li>Client 调用 Facade 时，Facade 将请求转发到 SubSystem 中；</li>
<li>Client 不需要访问 SubSystem；</li>
</ol>
<h1 id="相关模式"><a href="#相关模式" class="headerlink" title="相关模式"></a>相关模式</h1><ul>
<li>抽象工厂：抽象工厂也可以代替 Facade 来隐藏子系统；</li>
<li>中介者模式：相同点是都抽象了已有类功能。Facade 模式对接口进行抽象，让子系统提供出的接口更加易用，不定义新功能；后者暂不清楚。</li>
</ul>
<h1 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h1><ul>
<li>门面模式是通过门面接口提供了对封装底层组合功能的封装。</li>
</ul>
<h1 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h1><p><a href="https://github.com/hanzhang2566/design-patterns-examples/blob/main/go-patterns/structural/facade/facade_test.go">golang</a></p>
<p><a href="https://github.com/hanzhang2566/design-patterns-examples/blob/main/java-patterns/src/test/java/structural/facade/ClientTest.java">java</a></p>
]]></content>
      <tags>
        <tag>design pattern</tag>
      </tags>
  </entry>
  <entry>
    <title>UML 类图</title>
    <url>/2023/04/30/uml-class-diagram/</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th align="center">DATE</th>
<th align="center">CHANGELOG</th>
</tr>
</thead>
<tbody><tr>
<td align="center">2023年4月30日</td>
<td align="center">init</td>
</tr>
</tbody></table>
<p>在 UML 中，类图是静态的。通过展示类、类属性、类操作和类之间的关系，来描述系统结构。</p>
<h1 id="模型"><a href="#模型" class="headerlink" title="模型"></a>模型</h1><p>模型是类途中对现实世界的抽象。</p>
<h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><p>一组行为的抽象。</p>
<pre><code class="highlight mermaid">---
title: 接口示例
---
classDiagram
class Speaker &#123;
	&lt;&lt;interface&gt;&gt;
	speak(String statement) String 
&#125;</code></pre>

<h2 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h2><pre><code class="highlight mermaid">---
title: 类示例
---
classDiagram
class Abstract &#123;
	&lt;&lt;abstract&gt;&gt;
&#125;</code></pre>

<h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><p>具有属性和方法的对象。</p>
<pre><code class="highlight mermaid">---
title: 类示例
---
classDiagram
class Speakerman &#123;
	String name
    speak(String statement) String 
&#125;</code></pre>

<h2 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h2><p>#表示 public</p>
<p>-表示 private</p>
<p>#表示 protected</p>
<p>~表示 package 或者 internal</p>
<pre><code class="highlight mermaid">---
title: 可见性示例
---
classDiagram
class Visibility &#123;
	+int n1
	-int n2
	#int n3
	~int n4
	
	+m1()
	-m1()
	#m3()
	~m4()
&#125;</code></pre>

<h2 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h2><p>*表示 abstract，斜体</p>
<p>$表示 static，下划线</p>
<pre><code class="highlight mermaid">---
title: 修饰符示例
---
classDiagram
class Modifier &#123;
	int n1$
	
	+m1()*
    +m2()$
&#125;</code></pre>

<h1 id="关系"><a href="#关系" class="headerlink" title="关系"></a>关系</h1><p>关系是模型元素之间的连接。</p>
<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>空心三角 + 实线，男人属于人。</p>
<p>Man is a Person</p>
<pre><code class="highlight mermaid">---
title: 继承示例
---
classDiagram
class Person &#123;
	
&#125;

class Man &#123;
	
&#125;

Person &lt;|-- Man</code></pre>

<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>空心三角 + 虚线，鸟能飞。</p>
<p>Bird has Fly ability</p>
<pre><code class="highlight mermaid">---
title: 继承示例
---
classDiagram
class Fly &#123;
	&lt;&lt;interface&gt;&gt;
&#125;

class Bird &#123;
	
&#125;

Fly &lt;|.. Bird</code></pre>

<h2 id="聚合"><a href="#聚合" class="headerlink" title="聚合"></a>聚合</h2><p>空心菱形 + 实线，教室拥有黑板，但黑板不是教室的一部分。</p>
<p>Classroom possess Blaskboard, but Blackboard isn’t part of Classroom </p>
<pre><code class="highlight mermaid">---
title: 聚合示例
---
classDiagram
class Classroom &#123;
	Blackboard blackboard
&#125;

class Blackboard &#123;
	
&#125;

Classroom o-- Blackboard</code></pre>

<h2 id="组合"><a href="#组合" class="headerlink" title="组合"></a>组合</h2><p>实心菱形 + 实线，人有胳膊，同时胳膊不能独立存在。</p>
<p>Arm is part of Person </p>
<pre><code class="highlight mermaid">---
title: 组合示例
---
classDiagram
class Person &#123;
	Arm arm
&#125;

class Arm &#123;
	
&#125;

Person *-- Arm</code></pre>

<h2 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h2><p>箭头 + 虚线，人依赖水。</p>
<p>Person depand on Water</p>
<pre><code class="highlight mermaid">---
title: 依赖示例
---
classDiagram
class Person &#123;
	Water water
&#125;

class Water &#123;
	
&#125;

Water &lt;.. Person</code></pre>

<h2 id="关联"><a href="#关联" class="headerlink" title="关联"></a>关联</h2><p>箭头 + 实线，，人需要知道天气。</p>
<p>Person should know Climate</p>
<pre><code class="highlight mermaid">---
title: 关联示例
---
classDiagram
class Person &#123;
	Climate climate
&#125;

class Climate &#123;
	
&#125;

Climate &lt;-- Person</code></pre>

<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ol>
<li>继承和实现可以相互替代。使用接口使用实现关系，类之间选择继承关系；</li>
<li>依赖和关联不常用。因为依赖关系和关联关系可以进一步定义为聚合关系或者组合关系；</li>
<li>聚合适用范围比组合更广；</li>
</ol>
]]></content>
      <tags>
        <tag>tool</tag>
      </tags>
  </entry>
  <entry>
    <title>模板方法模式</title>
    <url>/2023/04/29/behavioral-template/</url>
    <content><![CDATA[<h1 id="模式描述"><a href="#模式描述" class="headerlink" title="模式描述"></a>模式描述</h1><p>模板方法(Template Method)模式，定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。模板方法使得子类可以不改变一个算法的结构即可重新定义该算法的某些特定步骤。</p>
<h1 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h1><ol>
<li>实现了反转控制；</li>
<li>给子类提供了扩展的钩子 hook；</li>
</ol>
<h1 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h1><h1 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h1><ol>
<li>实现算法不变的部分，将可变行为留给子类来实现；</li>
<li>子类中公共的行为被提取到父类，避免代码重复；</li>
<li>限制子类扩展</li>
</ol>
<span id="more"></span>

<table>
<thead>
<tr>
<th align="center">DATE</th>
<th align="center">CHANGELOG</th>
</tr>
</thead>
<tbody><tr>
<td align="center">2023年4月29日</td>
<td align="center">初始化</td>
</tr>
<tr>
<td align="center">2023年5月1日</td>
<td align="center">添加 Go 语言实现</td>
</tr>
</tbody></table>
<h1 id="UML-类图"><a href="#UML-类图" class="headerlink" title="UML 类图"></a>UML 类图</h1><pre><code class="highlight mermaid">classDiagram

class AbstractClass &#123;
	&lt;&lt;Abstract&gt;&gt;
	template()
	stepX()*
&#125;

class ConcreteClass &#123;
	stepX()
&#125;

AbstractClass &lt;|-- ConcreteClass
AbstractClass &lt;-- Client</code></pre>

<h1 id="参与者"><a href="#参与者" class="headerlink" title="参与者"></a>参与者</h1><h2 id="AbstractClass"><a href="#AbstractClass" class="headerlink" title="AbstractClass"></a>AbstractClass</h2><ul>
<li>定义算法骨架，将具体步骤留到子类；</li>
</ul>
<h2 id="ConcreteClass"><a href="#ConcreteClass" class="headerlink" title="ConcreteClass"></a>ConcreteClass</h2><ul>
<li>继承 AbstractClass，实现具体步骤；</li>
</ul>
<h2 id="Client-类"><a href="#Client-类" class="headerlink" title="Client 类"></a>Client 类</h2><p>客户端。</p>
<h1 id="数据流"><a href="#数据流" class="headerlink" title="数据流"></a>数据流</h1><ol>
<li>client 通常使用 AbstractClass 引用来创建一个 ConcreteClass 实例；</li>
<li>client 调用 AbstractClass 中的 template 方法；</li>
</ol>
<h1 id="相关模式"><a href="#相关模式" class="headerlink" title="相关模式"></a>相关模式</h1><ul>
<li>工厂方法：常被模板方法调用；</li>
<li>策略模式：模板方法使用继承来改变算法的一部分；但策略模式是使用委托来改变整个算法；</li>
</ul>
<h1 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h1><ul>
<li>模板方法模式通过把不变行为搬移到超类，子类只用实现自己的逻辑来达到代码复用。</li>
</ul>
<h1 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h1><p><a href="https://github.com/hanzhang2566/design-patterns-examples/blob/main/go-patterns/behavioral/template/template_test.go">golang</a></p>
<p><a href="https://github.com/hanzhang2566/design-patterns-examples/blob/main/java-patterns/src/test/java/behavioral/template/ClientTest.java">java</a></p>
]]></content>
      <tags>
        <tag>design pattern</tag>
      </tags>
  </entry>
  <entry>
    <title>Typora 和 Markdown</title>
    <url>/2023/04/29/typora-and-markdown/</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th align="center">DATE</th>
<th align="center">CHANGELOG</th>
</tr>
</thead>
<tbody><tr>
<td align="center">2023年4月29日</td>
<td align="center">初始化</td>
</tr>
<tr>
<td align="center">2023年5月7日</td>
<td align="center">增加换行快捷键</td>
</tr>
</tbody></table>
<h1 id="Markdown"><a href="#Markdown" class="headerlink" title="Markdown"></a>Markdown</h1><p>Markdown 和 HTML 类似，是一种标记语言。它使用少量的标签和语法来修饰纯文本内容，使得文本更具可读性。</p>
<h2 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h2><ol>
<li>平台独立。任何 os 都可以方便的创建和浏览；</li>
<li>适用一切。创建网站、书籍、email 和技术文档都可以使用 Marddown 编写；</li>
<li>广泛支持。大量论坛、网站、桌面程序和 Web 程序都支持；</li>
</ol>
<h2 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h2><ol>
<li>写文章；</li>
<li>项目的 README；</li>
</ol>
<h1 id="Typora"><a href="#Typora" class="headerlink" title="Typora"></a>Typora</h1><p>Typora 类似于 Windows 中的记事本，是一个专门用来创建和编写 Markdown 的软件。</p>
<h1 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h1><p>在 Typora 上写 Markdown 如虎添翼，下面会介绍自己在学习工作中使用 Typora 中快捷键编写 Markdown 的最佳实践，基本能够应对 90% 以上的情况。</p>
<h2 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h2><p>不建议使用 3 级以上的标题，这样会让文章编排很乱。</p>
<table>
<thead>
<tr>
<th align="center">操作</th>
<th align="center">windows</th>
<th align="center">macOS</th>
</tr>
</thead>
<tbody><tr>
<td align="center">一级标题</td>
<td align="center">Ctrl + 1</td>
<td align="center">Command + 1</td>
</tr>
<tr>
<td align="center">二级标题</td>
<td align="center">Ctrl + 2</td>
<td align="center">Command + 2</td>
</tr>
<tr>
<td align="center">三级标题</td>
<td align="center">Ctrl + 3</td>
<td align="center">Command + 3</td>
</tr>
<tr>
<td align="center">段落</td>
<td align="center">Ctrl + 0</td>
<td align="center">Command + 4</td>
</tr>
</tbody></table>
<h2 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h2><table>
<thead>
<tr>
<th align="center">操作</th>
<th align="center">windows</th>
<th align="center">macOS</th>
</tr>
</thead>
<tbody><tr>
<td align="center">插入表格</td>
<td align="center">Ctrl + T</td>
<td align="center">Command + T</td>
</tr>
<tr>
<td align="center">行上移</td>
<td align="center">Alt + 上箭头</td>
<td align="center">Command + 下箭头</td>
</tr>
<tr>
<td align="center">行下移</td>
<td align="center">Alt + 下箭头</td>
<td align="center">Command + 下箭头</td>
</tr>
<tr>
<td align="center">列左移</td>
<td align="center">Alt + 左箭头</td>
<td align="center">Command + 左箭头</td>
</tr>
<tr>
<td align="center">列右移</td>
<td align="center">Alt + 右箭头</td>
<td align="center">Command + 右箭头</td>
</tr>
<tr>
<td align="center">插入行</td>
<td align="center">Ctrl + Enter</td>
<td align="center">Command + Enter</td>
</tr>
<tr>
<td align="center">删除行</td>
<td align="center">Ctrl + Shift + Delete</td>
<td align="center">Command + Shift + Delete</td>
</tr>
</tbody></table>
<h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><table>
<thead>
<tr>
<th align="center">操作</th>
<th align="center">windows</th>
<th align="center">macOS</th>
</tr>
</thead>
<tbody><tr>
<td align="center">引用</td>
<td align="center">Ctrl + Shift + Q</td>
<td align="center">Command + Shift + Q</td>
</tr>
</tbody></table>
<h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><table>
<thead>
<tr>
<th align="center">操作</th>
<th align="center">windows</th>
<th align="center">macOS</th>
</tr>
</thead>
<tbody><tr>
<td align="center">有序列表</td>
<td align="center">Ctrl + Shift + [</td>
<td align="center">Command + Shift + [</td>
</tr>
<tr>
<td align="center">无序列表</td>
<td align="center">Ctrl + Shift + ]</td>
<td align="center">Command + Shift + ]</td>
</tr>
<tr>
<td align="center">任务列表</td>
<td align="center">Ctrl + Shift + X</td>
<td align="center">Command + Shift + X</td>
</tr>
<tr>
<td align="center">增加列表缩进</td>
<td align="center">Tab</td>
<td align="center">Tab</td>
</tr>
<tr>
<td align="center">减少列表缩进</td>
<td align="center">Shift + Tab</td>
<td align="center">Shift + Tab</td>
</tr>
</tbody></table>
<h2 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h2><table>
<thead>
<tr>
<th align="center">操作</th>
<th align="center">windows</th>
<th align="center">macOS</th>
</tr>
</thead>
<tbody><tr>
<td align="center">链接</td>
<td align="center">Ctrl + K</td>
<td align="center">Command + K</td>
</tr>
<tr>
<td align="center">加粗</td>
<td align="center">Ctrl + B</td>
<td align="center">Command + B</td>
</tr>
<tr>
<td align="center">斜体</td>
<td align="center">Ctrl + I</td>
<td align="center">Command + I</td>
</tr>
<tr>
<td align="center">下划线</td>
<td align="center">Ctrl + U</td>
<td align="center">Command + U</td>
</tr>
<tr>
<td align="center">删除线</td>
<td align="center">Shift + Alt + 5</td>
<td align="center">Shift + Alt + 5</td>
</tr>
</tbody></table>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><table>
<thead>
<tr>
<th align="center">操作</th>
<th align="center">windows</th>
<th align="center">macOS</th>
</tr>
</thead>
<tbody><tr>
<td align="center">代码</td>
<td align="center">Ctrl + Shift + &#96;</td>
<td align="center">Command + Shift + &#96;</td>
</tr>
<tr>
<td align="center">代码块</td>
<td align="center">Ctrl + Shift + K</td>
<td align="center">Command + Shift + K</td>
</tr>
</tbody></table>
<h2 id="常用操作"><a href="#常用操作" class="headerlink" title="常用操作"></a>常用操作</h2><table>
<thead>
<tr>
<th align="center">操作</th>
<th align="center">windows</th>
<th align="center">macOS</th>
</tr>
</thead>
<tbody><tr>
<td align="center">隐藏 &#x2F; 显示侧边栏</td>
<td align="center">Ctrl + Shift + L</td>
<td align="center">Command + Shift + L</td>
</tr>
<tr>
<td align="center">源代码</td>
<td align="center">Ctrl + &#x2F;</td>
<td align="center">Command + &#x2F;</td>
</tr>
<tr>
<td align="center">换行</td>
<td align="center">Ctrl + Shift + Enter</td>
<td align="center">Command + Shift + Enter</td>
</tr>
</tbody></table>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li><a href="https://www.markdownguide.org/">Markdown</a></li>
<li><a href="https://typora.io/">Typora</a></li>
<li><a href="https://typora.io/#download">Typora 下载</a></li>
<li><a href="https://typora.io/#purchase">Typora 购买</a></li>
<li>typora-段落</li>
<li>typora-格式</li>
</ul>
]]></content>
      <tags>
        <tag>tool</tag>
      </tags>
  </entry>
  <entry>
    <title>原型模式</title>
    <url>/2023/04/28/creational-prototype/</url>
    <content><![CDATA[<h1 id="模式描述"><a href="#模式描述" class="headerlink" title="模式描述"></a>模式描述</h1><p>原型模式是从一个原型实例中创建另外一个相同对象，而不用知道创建细节。。</p>
<h1 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h1><ol>
<li>运行时增加和删除对象；</li>
<li>通过极少改变，创建新对象；</li>
</ol>
<h1 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h1><ol>
<li>要使用深拷贝代替浅拷贝。循环依赖的问题可能使 clone 难以实现；</li>
<li>Prototype 的每个子类都要实现 clone；</li>
</ol>
<h1 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h1><ul>
<li>对象创建的数据需要从 RPC、网络、数据库、文件系统等非常慢速的 IO 中读取；</li>
<li>对象创建成本大、不同对象大部分字段都相同。</li>
</ul>
<span id="more"></span>

<table>
<thead>
<tr>
<th align="center">DATE</th>
<th align="center">CHANGELOG</th>
</tr>
</thead>
<tbody><tr>
<td align="center">2023年4月28日</td>
<td align="center">初始化</td>
</tr>
<tr>
<td align="center">2023年4月30日</td>
<td align="center">添加 Go 语言实现</td>
</tr>
</tbody></table>
<h1 id="UML-类图"><a href="#UML-类图" class="headerlink" title="UML 类图"></a>UML 类图</h1><pre><code class="highlight mermaid">classDiagram

class Prototype &#123;
	&lt;&lt;interface&gt;&gt;
	clone() Object
&#125;

class ConcretePrototype &#123;
    clone() ConcretePrototype
&#125;

Prototype &lt;|.. ConcretePrototype

Prototype &lt;-- Client</code></pre>

<h1 id="参与者"><a href="#参与者" class="headerlink" title="参与者"></a>参与者</h1><h2 id="Prototype-接口"><a href="#Prototype-接口" class="headerlink" title="Prototype 接口"></a>Prototype 接口</h2><ul>
<li>声明一个克隆自身的接口。</li>
</ul>
<h2 id="ConcretePrototype-类"><a href="#ConcretePrototype-类" class="headerlink" title="ConcretePrototype 类"></a>ConcretePrototype 类</h2><ul>
<li>Prototype 接口的实现。</li>
</ul>
<h2 id="Client-类"><a href="#Client-类" class="headerlink" title="Client 类"></a>Client 类</h2><ul>
<li>客户端用来克隆自身</li>
</ul>
<h1 id="相关模式"><a href="#相关模式" class="headerlink" title="相关模式"></a>相关模式</h1><ul>
<li>与抽象工厂（Abstract Factory）亦敌亦友；</li>
</ul>
<h1 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h1><ol>
<li>使用深拷贝，除非有足够的理由才能选择浅拷贝；</li>
</ol>
<h1 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h1><p><a href="https://github.com/hanzhang2566/design-patterns-examples/blob/main/go-patterns/creational/prototype/prototype_test.go">golang</a></p>
<p><a href="https://github.com/hanzhang2566/design-patterns-examples/blob/main/java-patterns/src/test/java/creational/prototype/ClientTest.java">java</a></p>
]]></content>
      <tags>
        <tag>design pattern</tag>
      </tags>
  </entry>
  <entry>
    <title>代理模式</title>
    <url>/2023/04/27/structural-proxy/</url>
    <content><![CDATA[<h1 id="模式描述"><a href="#模式描述" class="headerlink" title="模式描述"></a>模式描述</h1><p>不改变原始类（或叫被代理类）代码的情况下，通过引入代理类来控制这个对象的访问。</p>
<h1 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h1><ul>
<li>间接访问原始类；</li>
</ul>
<h1 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h1><ul>
<li>编写的目标代理类太多，当代理类接口改变，所有的代理类都需要进行更新。</li>
</ul>
<h1 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h1><ol>
<li><p>业务系统的非功能性需求开发。监控、统计、鉴权、限流、事务、幂等、日志。</p>
</li>
<li><p>RPC</p>
</li>
<li><p>缓存</p>
</li>
</ol>
<span id="more"></span>

<table>
<thead>
<tr>
<th align="center">DATE</th>
<th align="center">CHANGELOG</th>
</tr>
</thead>
<tbody><tr>
<td align="center">2023年4月27日</td>
<td align="center">初始化</td>
</tr>
<tr>
<td align="center">2023年5月1日</td>
<td align="center">添加 Go 语言实现</td>
</tr>
</tbody></table>
<h1 id="UML-类图"><a href="#UML-类图" class="headerlink" title="UML 类图"></a>UML 类图</h1><pre><code class="highlight mermaid">classDiagram
class Subject &#123;
	&lt;&lt;interface&gt;&gt;
	operator()
&#125;

class RealSubject &#123;
	operator()
&#125;

class Proxy &#123;
	operator()
&#125;

Subject &lt;|.. Proxy
Subject &lt;|.. RealSubject
Proxy o.. RealSubject

Subject &lt;-- Client</code></pre>

<h1 id="参与者"><a href="#参与者" class="headerlink" title="参与者"></a>参与者</h1><h2 id="Subject-接口"><a href="#Subject-接口" class="headerlink" title="Subject 接口"></a>Subject 接口</h2><ul>
<li>定义 Proxy 和 RealSubject 的方法，使得任何使用 RealSubject 的地方可以被 proxy 代替；</li>
</ul>
<h2 id="Proxy-类"><a href="#Proxy-类" class="headerlink" title="Proxy 类"></a>Proxy 类</h2><ul>
<li>代理类。</li>
</ul>
<h2 id="RealSubject-类"><a href="#RealSubject-类" class="headerlink" title="RealSubject 类"></a>RealSubject 类</h2><ul>
<li>被代理类</li>
</ul>
<h2 id="Client-类"><a href="#Client-类" class="headerlink" title="Client 类"></a>Client 类</h2><ul>
<li>客户端</li>
</ul>
<h1 id="数据流"><a href="#数据流" class="headerlink" title="数据流"></a>数据流</h1><ol>
<li>client 创建一个 Proxy ；</li>
<li>通过 Proxy 代理类访问原始类；</li>
</ol>
<h1 id="相关模式"><a href="#相关模式" class="headerlink" title="相关模式"></a>相关模式</h1><ul>
<li>适配器模式：适配器模式将给对象一个全新的接口，而代理模式使用相同接口；</li>
<li>装饰模式：装饰模式是给原始类增加功能，而代理关注访问和控制原始类；</li>
</ul>
<h1 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h1><ul>
<li>使用反射可以完成原始类的动态代理。</li>
<li>原始类能够定义接口，一般都是采用实现接口的方式。例如，Spring AOP。</li>
<li>原始类没有定义接口，也没办法给原始类重新定义接口，一般都是采用继承的方式实现代理。例如，cglib。</li>
</ul>
<h1 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h1><p><a href="https://github.com/hanzhang2566/design-patterns-examples/blob/main/go-patterns/structural/proxy/proxy_test.go">golang</a></p>
<p><a href="https://github.com/hanzhang2566/design-patterns-examples/blob/main/java-patterns/src/test/java/structural/proxy/ClientTest.java">java</a></p>
]]></content>
      <tags>
        <tag>design pattern</tag>
      </tags>
  </entry>
  <entry>
    <title>装饰模式</title>
    <url>/2023/04/26/structural-decorator/</url>
    <content><![CDATA[<h1 id="模式描述"><a href="#模式描述" class="headerlink" title="模式描述"></a>模式描述</h1><p>装饰模式(Decorator)，动态地给一个对象添加一些额外的职责，装饰模式比生成子类更加灵活。</p>
<h1 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h1><ol>
<li>比静态的继承更加灵活；</li>
<li>避免高层接口的功能太复杂。</li>
</ol>
<h1 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h1><ol>
<li>有很多小对象；</li>
</ol>
<h1 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h1><ol>
<li>不影响其他对象的情况下，以动态、透明的方式给单个对象添加职责；</li>
<li>不能使用子类扩充功能时；</li>
<li>撤销对象功能；</li>
</ol>
<span id="more"></span>

<table>
<thead>
<tr>
<th align="center">DATE</th>
<th align="center">CHANGELOG</th>
</tr>
</thead>
<tbody><tr>
<td align="center">2023年4月26日</td>
<td align="center">初始化</td>
</tr>
<tr>
<td align="center">2023年4月30日</td>
<td align="center">添加 Go 语言实现</td>
</tr>
</tbody></table>
<h1 id="UML-类图"><a href="#UML-类图" class="headerlink" title="UML 类图"></a>UML 类图</h1><pre><code class="highlight mermaid">classDiagram
class Component &#123;
	&lt;&lt;interface&gt;&gt;
	operation()
&#125;

class Decorator &#123;
	&lt;&lt;abstract&gt;&gt;
	-Component Component
	operation()
&#125;

class ConcreteComponent &#123;
	operation()
&#125;

class ConcreteDecoratorA &#123;
	operation()
	-addState
&#125;

class ConcreteDecoratorB &#123;
	operation()
    -addBehavior
&#125;

Component &lt;|.. ConcreteComponent
Component &lt;|.. Decorator
Decorator o.. Component
Decorator &lt;|-- ConcreteDecoratorA
Decorator &lt;|-- ConcreteDecoratorB

Component &lt;-- Client</code></pre>

<h1 id="参与者"><a href="#参与者" class="headerlink" title="参与者"></a>参与者</h1><h2 id="Component-接口"><a href="#Component-接口" class="headerlink" title="Component 接口"></a>Component 接口</h2><ul>
<li>定义方法，能够动态地添加职责。</li>
</ul>
<h2 id="ConcreteComponent-类"><a href="#ConcreteComponent-类" class="headerlink" title="ConcreteComponent 类"></a>ConcreteComponent 类</h2><ul>
<li>Component 接口的实现，有基础的功能。</li>
</ul>
<h2 id="Decorator-抽象类"><a href="#Decorator-抽象类" class="headerlink" title="Decorator 抽象类"></a>Decorator 抽象类</h2><ul>
<li>实现 Component 接口，并组合一个 Component 对象。</li>
</ul>
<h2 id="ConcreteDecoratorX-类"><a href="#ConcreteDecoratorX-类" class="headerlink" title="ConcreteDecoratorX 类"></a>ConcreteDecoratorX 类</h2><ul>
<li>继承 Decorator 抽象类，用来添加职责。</li>
</ul>
<h2 id="Client-类"><a href="#Client-类" class="headerlink" title="Client 类"></a>Client 类</h2><ul>
<li>客户端</li>
</ul>
<h1 id="数据流"><a href="#数据流" class="headerlink" title="数据流"></a>数据流</h1><ol>
<li>client 创建一个 Component；</li>
<li>通过 Decorator 层层包装 client；</li>
<li>调用 Component 提供的方法进行工作；</li>
</ol>
<h1 id="相关模式"><a href="#相关模式" class="headerlink" title="相关模式"></a>相关模式</h1><ul>
<li>适配器模式：装饰者模式仅改变对象职责，而适配器模式将给对象一个全新的接口；</li>
<li>组合模式：装饰器模式被认为是退化为只有一个组件的组合；</li>
<li>策略模式：装饰器模式改变的是对象外表，而策略模式改变对象内核。</li>
</ul>
<h1 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h1><ul>
<li>装饰模式使得核心职责和装饰功能区分开，减少重复的装饰逻辑；</li>
</ul>
<h1 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h1><p><a href="https://github.com/hanzhang2566/design-patterns-examples/blob/main/go-patterns/structural/decorator/decorator_test.go">golang</a></p>
<p><a href="https://github.com/hanzhang2566/design-patterns-examples/blob/main/java-patterns/src/test/java/structural/decorator/ClientTest.java">java</a></p>
]]></content>
      <tags>
        <tag>design pattern</tag>
      </tags>
  </entry>
  <entry>
    <title>策略模式</title>
    <url>/2023/04/25/behavioral-strategy/</url>
    <content><![CDATA[<h1 id="模式描述"><a href="#模式描述" class="headerlink" title="模式描述"></a>模式描述</h1><p>策略模式（Strategy）定义了一系列行为，将每个行为分别封装起来，让它们可以互相替换，使得行为的变化可以独立于使用它们的客户端。</p>
<h1 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h1><ol>
<li>提供了一组 Strategy；</li>
<li>组合代替了继承；</li>
<li>消除分支；</li>
<li>client 选择 Strategy 实现；</li>
</ol>
<h1 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h1><ol>
<li>client 需要了解 Strategy 实现的不同；</li>
<li>某些 Strategy 用不到所有 Context 传来的数据，增加通信成本；</li>
<li>增加了类的数目；</li>
</ol>
<h1 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h1><ol>
<li>替换的仅仅是类中的行为；</li>
<li>行为中的数据对用户是隐藏的；</li>
</ol>
<span id="more"></span>

<table>
<thead>
<tr>
<th align="center">DATE</th>
<th align="center">CHANGELOG</th>
</tr>
</thead>
<tbody><tr>
<td align="center">2023年4月25日</td>
<td align="center">初始化</td>
</tr>
<tr>
<td align="center">2023年4月30日</td>
<td align="center">添加 Go 语言实现</td>
</tr>
</tbody></table>
<h1 id="UML-类图"><a href="#UML-类图" class="headerlink" title="UML 类图"></a>UML 类图</h1><pre><code class="highlight mermaid">classDiagram
class Context &#123;
	&lt;&lt;interface&gt;&gt;
	getContext()
&#125;

class Strategy &#123;
	&lt;&lt;interface&gt;&gt;
	handle()
&#125;

Context o--&gt; Strategy

class ConcreteStrategyA &#123;
	handle()
&#125;

class ConcreteStrategyB &#123;
	handle()
&#125;

class ConcreteStrategyC &#123;
	handle()
&#125;

Strategy &lt;|.. ConcreteStrategyA
Strategy &lt;|.. ConcreteStrategyB
Strategy &lt;|.. ConcreteStrategyC

Context &lt;-- Client
Strategy &lt;-- Client</code></pre>

<h1 id="参与者"><a href="#参与者" class="headerlink" title="参与者"></a>参与者</h1><h2 id="Context-接口"><a href="#Context-接口" class="headerlink" title="Context 接口"></a>Context 接口</h2><ul>
<li><p>提供一个方法来配置自身；</p>
</li>
<li><p>维护对 Strategy 的引用；</p>
</li>
</ul>
<h2 id="Strategy-接口"><a href="#Strategy-接口" class="headerlink" title="Strategy 接口"></a>Strategy 接口</h2><p>支持行为的公共接口。Context 使用 Strategy 提供的方法来调用某个 ConcreteStrategyX。</p>
<h2 id="ConcreteStrategyX-类"><a href="#ConcreteStrategyX-类" class="headerlink" title="ConcreteStrategyX 类"></a>ConcreteStrategyX 类</h2><p>具体实现 Strategy 接口。</p>
<h2 id="Client-类"><a href="#Client-类" class="headerlink" title="Client 类"></a>Client 类</h2><p>客户端。</p>
<h1 id="数据流"><a href="#数据流" class="headerlink" title="数据流"></a>数据流</h1><ol>
<li>client 通常创建 ConcreteStrategyX 对象交给 Context 接收，这样 client 仅与 Context 进行交互；</li>
<li>当 client 调用时，Context 将 Strategy 所需的数据传递给 ConcreteStrategyX，处理完成后回调给 Context;</li>
</ol>
<h1 id="相关模式"><a href="#相关模式" class="headerlink" title="相关模式"></a>相关模式</h1><ul>
<li>享元模式（Flyweight）：Strategy 对象是很好的轻量级对象。</li>
</ul>
<h1 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h1><ul>
<li><p>Strategy 可以通过工厂模式来创建。</p>
</li>
<li><p>ConcreteStrategy 一般是无状态的，是纯粹的算法实现。可以将 ConcreteStrategy 对象缓存到工厂类中，不需要每次调用时创建；如果是有状态的，则需要新创建对象。</p>
</li>
<li><p>配置文件或注解指定 ConcreteStrategy 族，StrategyFactory 加载 ConcreteStrategy 族，使用反射在运行时动态决定 ConcreteStrategy 是最典型的用法。</p>
</li>
</ul>
<h1 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h1><p><a href="https://github.com/hanzhang2566/design-patterns-examples/blob/main/go-patterns/behavioral/strategy/strategy_test.go">golang</a></p>
<p><a href="https://github.com/hanzhang2566/design-patterns-examples/blob/main/java-patterns/src/test/java/behavioral/strategy/ClientTest.java">java</a></p>
]]></content>
      <tags>
        <tag>design pattern</tag>
      </tags>
  </entry>
  <entry>
    <title>工厂方法模式</title>
    <url>/2023/04/24/creational-factory-tmpl/</url>
    <content><![CDATA[<h1 id="模式描述"><a href="#模式描述" class="headerlink" title="模式描述"></a>模式描述</h1><p>工厂方法模式(Factory Method)，定义一个用于创建对象的接口，让子类决定实例化哪一个类，使得一个类的实例化延迟到其子类。</p>
<h1 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h1><ol>
<li>给子类创建对象预留扩展点；</li>
<li>client 通过 Creator 间接创建对象；</li>
</ol>
<h1 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h1><ol>
<li>Creator 实现变多；</li>
</ol>
<h1 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h1><ol>
<li>一个类希望由它的子类来创建对象时；</li>
<li>一个类不知道创建对象的类时；</li>
</ol>
<span id="more"></span>

<table>
<thead>
<tr>
<th align="center">DATE</th>
<th align="center">CHANGELOG</th>
</tr>
</thead>
<tbody><tr>
<td align="center">2023年4月24日</td>
<td align="center">初始化</td>
</tr>
<tr>
<td align="center">2023年4月30日</td>
<td align="center">添加 Go 语言实现</td>
</tr>
</tbody></table>
<h1 id="UML-类图"><a href="#UML-类图" class="headerlink" title="UML 类图"></a>UML 类图</h1><pre><code class="highlight mermaid">classDiagram
class Creator &#123;
	&lt;&lt;abstract&gt;&gt;
	getProduct() Product
&#125;

class ConcreteCreator &#123;
	getProduct() Product
&#125;
Creator &lt;|-- ConcreteCreator

class Product &#123;
	&lt;&lt;interface&gt;&gt;
	handle()
&#125;

class ConcreteProduct &#123;
	handle()
&#125;

Product &lt;|.. ConcreteProduct

ConcreteCreator &lt;-- Product
Creator &lt;-- Client</code></pre>

<h1 id="参与者"><a href="#参与者" class="headerlink" title="参与者"></a>参与者</h1><h2 id="Product-接口"><a href="#Product-接口" class="headerlink" title="Product 接口"></a>Product 接口</h2><ul>
<li>定义工厂方法创建对象的接口。</li>
</ul>
<h2 id="ConcreteProduct-类"><a href="#ConcreteProduct-类" class="headerlink" title="ConcreteProduct 类"></a>ConcreteProduct 类</h2><ul>
<li>Produce 接口的实现。</li>
</ul>
<h2 id="Creator-抽象类"><a href="#Creator-抽象类" class="headerlink" title="Creator 抽象类"></a>Creator 抽象类</h2><ul>
<li>声明一个抽象工厂方法，返回默认的 Product 对象。</li>
</ul>
<h2 id="ConcreteCreator-类"><a href="#ConcreteCreator-类" class="headerlink" title="ConcreteCreator 类"></a>ConcreteCreator 类</h2><ul>
<li>Creator 抽象类的实现，返回自定义 Product 对象。</li>
</ul>
<h2 id="Client-类"><a href="#Client-类" class="headerlink" title="Client 类"></a>Client 类</h2><ul>
<li>使用客户端。</li>
</ul>
<h1 id="数据流"><a href="#数据流" class="headerlink" title="数据流"></a>数据流</h1><ol>
<li>client 创建一个 Creator；</li>
<li>client 调用 Creator 提供的方法来返回 ConcreteProduct。</li>
</ol>
<h1 id="相关模式"><a href="#相关模式" class="headerlink" title="相关模式"></a>相关模式</h1><ul>
<li>抽象工厂模式（Abstract Factory）经常用工厂方法实现；</li>
<li>工厂方法通常在模板方法中被调用；</li>
</ul>
<h1 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h1><ul>
<li>基本的工厂方法中，一个 ConcreteProduct 对应一个 ConcreteCreator 的具体实现；</li>
<li>可以通过参数化的方式，来将 ConcreteProduct 分类；</li>
</ul>
<h1 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h1><p><a href="https://github.com/hanzhang2566/design-patterns-examples/blob/main/go-patterns/creational/factory/tmpl/factory_tmpl_test.go">golang</a></p>
<p><a href="https://github.com/hanzhang2566/design-patterns-examples/blob/main/java-patterns/src/test/java/creational/factory/tmpl/ClientTest.java">java</a></p>
]]></content>
      <tags>
        <tag>design pattern</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式</title>
    <url>/2023/04/23/design-patterns-readme/</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th align="center">DATE</th>
<th align="center">CHANGELOG</th>
</tr>
</thead>
<tbody><tr>
<td align="center">2023年4月23日</td>
<td align="center">初始化</td>
</tr>
<tr>
<td align="center">2023年4月30日</td>
<td align="center">添加代码库</td>
</tr>
<tr>
<td align="center">2023年5月9日</td>
<td align="center">添加参考书</td>
</tr>
</tbody></table>
<p>设计模式是记录 OOP 中重要和重复出现的设计，用来对抗未来的需求和变化，帮助设计者更快、更好地完成系统设计的模板或者说套路。</p>
<h1 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h1><table>
<thead>
<tr>
<th align="center">设计模式</th>
<th align="center">意图</th>
<th align="center">重构原因</th>
<th align="center">扩展点</th>
</tr>
</thead>
<tbody><tr>
<td align="center">抽象工厂模式</td>
<td align="center">提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类</td>
<td align="center">显式创建类对象 对平台的依赖 显式对象的依赖 紧耦合</td>
<td align="center">产品对象家族</td>
</tr>
<tr>
<td align="center">建造者模式</td>
<td align="center">将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示</td>
<td align="center">算法依赖</td>
<td align="center">如何创建一个组合对象</td>
</tr>
<tr>
<td align="center">工厂方法模式</td>
<td align="center">定义一个用于创建对象的接口，让子类决定将哪一个类实例化 Factory Method 使一个类的实例化延迟到其子类</td>
<td align="center">显式创建类对象</td>
<td align="center">被实例化的子类</td>
</tr>
<tr>
<td align="center">单例模式</td>
<td align="center">保证一个类仅有一个实例，并提供一个访问它的全局访问点</td>
<td align="center"></td>
<td align="center">一个类唯一实例</td>
</tr>
<tr>
<td align="center">适配器模式</td>
<td align="center">将一个类的接口转换成另外一个接口 Adapter 模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作</td>
<td align="center">无法方便对类进行修改</td>
<td align="center">对象的接口</td>
</tr>
<tr>
<td align="center">桥接模式</td>
<td align="center">将抽象部分与它的实现部分分离，使它们都可以独立地变化</td>
<td align="center">对平台的依赖 显式对象的依赖 通过生成子类扩充功能</td>
<td align="center">对象的实现</td>
</tr>
<tr>
<td align="center">装饰者模式</td>
<td align="center">动态地给一个对象添加一些额外的职责 就扩展功能而言，Decorator 模式比生成子类方式更为灵活</td>
<td align="center">无法方便对类进行修改 通过生成子类扩充功能</td>
<td align="center">对象的职责，不生成子类</td>
</tr>
<tr>
<td align="center">代理模式</td>
<td align="center">为其他对象提供一个代理以控制对这个对象的访问</td>
<td align="center">显式对象的依赖</td>
<td align="center">如何访问对象；对象的位置</td>
</tr>
<tr>
<td align="center">责任链模式</td>
<td align="center">为解除请求的发送者和接收者之间的耦合，而使多个对象都有机会处理这个请求 将这些对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它</td>
<td align="center">对特殊操作的依赖 通过生成子类扩充功能 紧耦合</td>
<td align="center">满足一个对象的请求</td>
</tr>
<tr>
<td align="center">迭代器模式</td>
<td align="center">提供一种方法顺序访问一个聚合对象中各个元素，而又不需要暴露该对象的内部表示</td>
<td align="center">算法依赖</td>
<td align="center">如何遍历、访问一个可迭代对象</td>
</tr>
<tr>
<td align="center">观察者模式</td>
<td align="center">定义对象间的一种一对多的依赖关系 以便当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并自动刷新</td>
<td align="center">通过生成子类扩充功能 紧耦合</td>
<td align="center">多个对象依赖另一个对象 这些对象如何保存</td>
</tr>
<tr>
<td align="center">状态模式</td>
<td align="center">允许一个对象在其内部状态改变时改变它的行为。对象看起来似乎修改了它所属的类</td>
<td align="center"></td>
<td align="center">对象的状态</td>
</tr>
<tr>
<td align="center">策略模式</td>
<td align="center">定义一系列的算法，把它们一个个封装起来，并且使它们可相互替换 本模式使得算法的变化可独立于使用它的客户。</td>
<td align="center">算法依赖 通过生成子类扩充功能</td>
<td align="center">算法</td>
</tr>
<tr>
<td align="center">模板方法模式</td>
<td align="center">定义一个操作中的算法的骨架，而将一些步骤延迟到子类中 Template Method 使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤</td>
<td align="center">算法依赖</td>
<td align="center">算法的某些步骤</td>
</tr>
<tr>
<td align="center">命令模式</td>
<td align="center">将一个请求封装为一个对象，从而使你可用不同的请求对客户进行参数化 对请求排队或记录请求日志，以及支持可取消的操作</td>
<td align="center">对特殊操作的依赖 紧耦合</td>
<td align="center">合适、怎样满足请求</td>
</tr>
<tr>
<td align="center">原型模式</td>
<td align="center">用原型实例指定创建对象的种类，并且通过拷贝这个原型来创建新的对象</td>
<td align="center">显式创建类对象</td>
<td align="center">被实例化的类</td>
</tr>
<tr>
<td align="center">组合模式</td>
<td align="center">将对象组合成树形结构以表示“部分－整体”的层次结构 Composite 使得客户对单个对象和复合对象的使用具有一致性</td>
<td align="center">通过生成子类扩充功能</td>
<td align="center">一个对象的结构和组成</td>
</tr>
<tr>
<td align="center">门面模式</td>
<td align="center">为子系统中的一组接口提供一个一致的界面 Façade模式定义了一个高层接口，这个接口使得这一子系统更加容易使用</td>
<td align="center">紧耦合</td>
<td align="center">一个子系统的接口</td>
</tr>
<tr>
<td align="center">享元模式</td>
<td align="center">运用共享技术有效地支持大量细粒度的对象</td>
<td align="center"></td>
<td align="center">对象的存储开销</td>
</tr>
<tr>
<td align="center">解释器模式</td>
<td align="center">给定一个语言，定义它的方法的一种表示，并定义一个解释器，该解释器使用该表示来解释语言中的句子</td>
<td align="center"></td>
<td align="center">一个语言的文法及解释</td>
</tr>
<tr>
<td align="center">中介者模式</td>
<td align="center">用一个中介对象来封装一系列的对象交互 中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互</td>
<td align="center">紧耦合</td>
<td align="center">对象间怎样交互、和谁交互</td>
</tr>
<tr>
<td align="center">备忘录模式</td>
<td align="center">在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态 这样以后就可将该对象恢复到保存的状态</td>
<td align="center">显式对象的依赖</td>
<td align="center">对象的哪些信息可以存放在对象外 何时存储在对象外</td>
</tr>
<tr>
<td align="center">访问者模式</td>
<td align="center">表示一个作用于某对象结构中的各元素的操作 它使你可以在不改变各元素的类的前提下定义作用于这些元素的新操作</td>
<td align="center">算法依赖 无法方便对类进行修改</td>
<td align="center">作用在对象的操作，不修改对象的类</td>
</tr>
</tbody></table>
<h1 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h1><p>加粗为常用的设计模式。</p>
<p>类范围是静态的，在编译期确定；对象范围是动态的，在运行时确定。</p>
<h2 id="创建型-creational"><a href="#创建型-creational" class="headerlink" title="创建型 creational"></a>创建型 creational</h2><p>关注对象的创建。类范围是将创建工作延迟到子类，对象范围则将创建工作延迟到另一个对象中。</p>
<table>
<thead>
<tr>
<th align="center">类</th>
<th align="center">对象</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><strong>工厂方法模式 (Factory Method)</strong></td>
<td align="center"><strong>抽象工厂模式 (Abstract Factory)</strong><br><strong>建造者模式 (Builder)</strong><br><strong>单例模式 (Singleton)</strong><br>原型模式 (Prototype)</td>
</tr>
</tbody></table>
<h2 id="结构型-structural"><a href="#结构型-structural" class="headerlink" title="结构型 structural"></a>结构型 structural</h2><p>关注类或对象的组装。类范围使用继承来组装类，对象范围则描述了对象的组装方式。</p>
<table>
<thead>
<tr>
<th align="center">类</th>
<th align="center">对象</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><strong>适配器模式 (Adapter)</strong></td>
<td align="center"><strong>适配器模式 (Adapter)</strong><br><strong>桥接模式 (Bridge)</strong><br><strong>装饰者模式 (Decorator)</strong><br><strong>代理模式 (Proxy)</strong><br>组合模式 (Composite)<br/>门面模式 (Facade)<br>享元模式 (Flyweight)<br></td>
</tr>
</tbody></table>
<h2 id="行为型-behavioral"><a href="#行为型-behavioral" class="headerlink" title="行为型 behavioral"></a>行为型 behavioral</h2><p>关注类或对象的交互和职责分配。类范围使用继承描述算法和控制流，对象范围则描述了一组对象如何协作完成单个对象无法完成的任务。</p>
<table>
<thead>
<tr>
<th align="center">类</th>
<th align="center">对象</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><strong>模板方法模式 (Template Method)</strong><br/>解释器模式 (Interpreter)</td>
<td align="center"><strong>责任链模式 (Chain of Responsibility)</strong><br><strong>迭代器模式 (Iterator)</strong><br><strong>观察者模式 (Observer)</strong><br><strong>状态模式 (State)</strong><br><strong>策略模式 (Strategy)</strong><br>中介者模式 (Mediator)<br/>命令模式 (Command)<br/>备忘录模式 (Memento)<br/>访问者模式 (Visitor)</td>
</tr>
</tbody></table>
<h1 id="模式如何解决设计问题"><a href="#模式如何解决设计问题" class="headerlink" title="模式如何解决设计问题"></a>模式如何解决设计问题</h1><ol>
<li>寻找合适的对象。如何挑选合适对象来对现实世界进行抽象，以灵活的设计应对未来需求的变化；</li>
<li>决定对象的粒度；</li>
<li>定义接口及操作；</li>
<li>实现接口。通过接口、类、抽象类来实现定义好的接口；</li>
<li>复用接口。通过组合、委托等方式来复用定义的接口；</li>
</ol>
<h1 id="选择模式的一般方法"><a href="#选择模式的一般方法" class="headerlink" title="选择模式的一般方法"></a>选择模式的一般方法</h1><ol>
<li>考虑模式如何解决设计问题；</li>
<li>浏览模式意图；</li>
<li>研究目的相似模式；</li>
<li>查看模式解决问题聚焦的领域；</li>
<li>确定模式可变的方面；</li>
</ol>
<h1 id="使用模式的一般方法"><a href="#使用模式的一般方法" class="headerlink" title="使用模式的一般方法"></a>使用模式的一般方法</h1><ol>
<li>浏览一遍模式。重点关注模式适用的场景和需要做出的权衡；</li>
<li>理解模式中类和对象的关联；</li>
<li>查看模式示例代码；</li>
<li>进行移植；</li>
</ol>
<h1 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h1><p>设计模式不可以随意使用。通常情况下，引入设计模式在获得灵活性和可变性的同时，会使设计变得更复杂和难以理解。</p>
<h1 id="代码库"><a href="#代码库" class="headerlink" title="代码库"></a>代码库</h1><p><a href="https://github.com/hanzhang2566/design-patterns-examples">design-patterns-examples</a></p>
<h1 id="参考书"><a href="#参考书" class="headerlink" title="参考书"></a>参考书</h1><ul>
<li><p><a href="https://book.douban.com/subject/34262305/">设计模式：可复用面向对象软件的基础</a></p>
</li>
<li><p><a href="https://book.douban.com/subject/35919931/">设计模式之美</a></p>
</li>
<li><p><a href="https://book.douban.com/subject/36116620/">大话设计模式：Java 溢彩加强版</a></p>
</li>
<li><p><a href="https://book.douban.com/subject/36262489/">Go语言设计模式（双色版）</a></p>
<p>⭐</p>
<p>设计模式中，主要关注 UML 类图，可作者却用第一张 70% 第一章的篇幅来介绍 UML 基础，对重点的类图并没有着墨太多。最后一章也用了 8% 的内容来介绍软件架构，有些凑字数。</p>
<p>我认为本书是对《设计模式:可复用面型对象软件的基础》中内容的转译，没有看到作者的独到见解。此外，书籍源代码竟然没有 POST 到扉页，而是要关注公众号获取，体验很差。</p>
<p>对于没有编程经验的人来说，设计模式来入门挑战比较大，不推荐作为前几部来阅读。对于有其他语言经验的人，本书不是一个好的选择。建议看 《设计模式:可复用面型对象软件的基础》和 《大话设计模式》。</p>
</li>
<li><p><a href="https://refactoringguru.cn/">refactoringguru</a></p>
</li>
</ul>
]]></content>
      <tags>
        <tag>readme</tag>
      </tags>
  </entry>
</search>
